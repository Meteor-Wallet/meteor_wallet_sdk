# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
  query: query_root
  subscription: subscription_root
}

"whether this query should be cached (Hasura Cloud only)"
directive @cached(
  "refresh the cache entry"
  refresh: Boolean! = false
  "measured in seconds"
  ttl: Int! = 60
) on QUERY

"columns and relationships of \"access_keys\""
type access_keys {
  account_id: String!
  created_by_receipt_id: String
  deleted_by_receipt_id: String
  last_update_block_height: numeric!
  permission_kind: access_key_permission_kind!
  public_key: String!
  "An object relationship"
  receipt: receipts
  "An object relationship"
  receiptByDeletedByReceiptId: receipts
  "An object relationship"
  transaction: transactions
}

"aggregated selection of \"access_keys\""
type access_keys_aggregate {
  aggregate: access_keys_aggregate_fields
  nodes: [access_keys!]!
}

"aggregate fields of \"access_keys\""
type access_keys_aggregate_fields {
  avg: access_keys_avg_fields
  count(columns: [access_keys_select_column!], distinct: Boolean): Int!
  max: access_keys_max_fields
  min: access_keys_min_fields
  stddev: access_keys_stddev_fields
  stddev_pop: access_keys_stddev_pop_fields
  stddev_samp: access_keys_stddev_samp_fields
  sum: access_keys_sum_fields
  var_pop: access_keys_var_pop_fields
  var_samp: access_keys_var_samp_fields
  variance: access_keys_variance_fields
}

"aggregate avg on columns"
type access_keys_avg_fields {
  last_update_block_height: Float
}

"aggregate max on columns"
type access_keys_max_fields {
  account_id: String
  created_by_receipt_id: String
  deleted_by_receipt_id: String
  last_update_block_height: numeric
  permission_kind: access_key_permission_kind
  public_key: String
}

"aggregate min on columns"
type access_keys_min_fields {
  account_id: String
  created_by_receipt_id: String
  deleted_by_receipt_id: String
  last_update_block_height: numeric
  permission_kind: access_key_permission_kind
  public_key: String
}

"aggregate stddev on columns"
type access_keys_stddev_fields {
  last_update_block_height: Float
}

"aggregate stddev_pop on columns"
type access_keys_stddev_pop_fields {
  last_update_block_height: Float
}

"aggregate stddev_samp on columns"
type access_keys_stddev_samp_fields {
  last_update_block_height: Float
}

"aggregate sum on columns"
type access_keys_sum_fields {
  last_update_block_height: numeric
}

"aggregate var_pop on columns"
type access_keys_var_pop_fields {
  last_update_block_height: Float
}

"aggregate var_samp on columns"
type access_keys_var_samp_fields {
  last_update_block_height: Float
}

"aggregate variance on columns"
type access_keys_variance_fields {
  last_update_block_height: Float
}

"columns and relationships of \"accounts\""
type accounts {
  account_id: String!
  "An object relationship"
  accounts_label: accounts_label
  created_by_receipt_id: String
  deleted_by_receipt_id: String
  id: bigint!
  last_update_block_height: numeric!
  "An object relationship"
  receipt: receipts
  "An object relationship"
  receiptByDeletedByReceiptId: receipts
}

"aggregated selection of \"accounts\""
type accounts_aggregate {
  aggregate: accounts_aggregate_fields
  nodes: [accounts!]!
}

"aggregate fields of \"accounts\""
type accounts_aggregate_fields {
  avg: accounts_avg_fields
  count(columns: [accounts_select_column!], distinct: Boolean): Int!
  max: accounts_max_fields
  min: accounts_min_fields
  stddev: accounts_stddev_fields
  stddev_pop: accounts_stddev_pop_fields
  stddev_samp: accounts_stddev_samp_fields
  sum: accounts_sum_fields
  var_pop: accounts_var_pop_fields
  var_samp: accounts_var_samp_fields
  variance: accounts_variance_fields
}

"aggregate avg on columns"
type accounts_avg_fields {
  id: Float
  last_update_block_height: Float
}

"columns and relationships of \"accounts_label\""
type accounts_label {
  "An object relationship"
  account: accounts!
  account_id: String!
  blog: String
  id: bigint!
  label: String!
  tag: String
  telegram: String
  twitter: String
  website: String
}

"aggregate max on columns"
type accounts_max_fields {
  account_id: String
  created_by_receipt_id: String
  deleted_by_receipt_id: String
  id: bigint
  last_update_block_height: numeric
}

"aggregate min on columns"
type accounts_min_fields {
  account_id: String
  created_by_receipt_id: String
  deleted_by_receipt_id: String
  id: bigint
  last_update_block_height: numeric
}

"aggregate stddev on columns"
type accounts_stddev_fields {
  id: Float
  last_update_block_height: Float
}

"aggregate stddev_pop on columns"
type accounts_stddev_pop_fields {
  id: Float
  last_update_block_height: Float
}

"aggregate stddev_samp on columns"
type accounts_stddev_samp_fields {
  id: Float
  last_update_block_height: Float
}

"aggregate sum on columns"
type accounts_sum_fields {
  id: bigint
  last_update_block_height: numeric
}

"aggregate var_pop on columns"
type accounts_var_pop_fields {
  id: Float
  last_update_block_height: Float
}

"aggregate var_samp on columns"
type accounts_var_samp_fields {
  id: Float
  last_update_block_height: Float
}

"aggregate variance on columns"
type accounts_variance_fields {
  id: Float
  last_update_block_height: Float
}

"columns and relationships of \"action_receipt_actions\""
type action_receipt_actions {
  action_kind: action_kind!
  args("JSON select path" path: String): jsonb!
  "An object relationship"
  ft: legacy_ft_meta
  index_in_action_receipt: Int!
  "An object relationship"
  nft: nft_contract_meta
  "An object relationship"
  receipt: receipts!
  receipt_id: String!
  receipt_included_in_block_timestamp: numeric!
  receipt_predecessor_account_id: String!
  receipt_receiver_account_id: String!
}

"aggregated selection of \"action_receipt_actions\""
type action_receipt_actions_aggregate {
  aggregate: action_receipt_actions_aggregate_fields
  nodes: [action_receipt_actions!]!
}

"aggregate fields of \"action_receipt_actions\""
type action_receipt_actions_aggregate_fields {
  avg: action_receipt_actions_avg_fields
  count(columns: [action_receipt_actions_select_column!], distinct: Boolean): Int!
  max: action_receipt_actions_max_fields
  min: action_receipt_actions_min_fields
  stddev: action_receipt_actions_stddev_fields
  stddev_pop: action_receipt_actions_stddev_pop_fields
  stddev_samp: action_receipt_actions_stddev_samp_fields
  sum: action_receipt_actions_sum_fields
  var_pop: action_receipt_actions_var_pop_fields
  var_samp: action_receipt_actions_var_samp_fields
  variance: action_receipt_actions_variance_fields
}

"aggregate avg on columns"
type action_receipt_actions_avg_fields {
  index_in_action_receipt: Float
  receipt_included_in_block_timestamp: Float
}

"aggregate max on columns"
type action_receipt_actions_max_fields {
  action_kind: action_kind
  index_in_action_receipt: Int
  receipt_id: String
  receipt_included_in_block_timestamp: numeric
  receipt_predecessor_account_id: String
  receipt_receiver_account_id: String
}

"aggregate min on columns"
type action_receipt_actions_min_fields {
  action_kind: action_kind
  index_in_action_receipt: Int
  receipt_id: String
  receipt_included_in_block_timestamp: numeric
  receipt_predecessor_account_id: String
  receipt_receiver_account_id: String
}

"aggregate stddev on columns"
type action_receipt_actions_stddev_fields {
  index_in_action_receipt: Float
  receipt_included_in_block_timestamp: Float
}

"aggregate stddev_pop on columns"
type action_receipt_actions_stddev_pop_fields {
  index_in_action_receipt: Float
  receipt_included_in_block_timestamp: Float
}

"aggregate stddev_samp on columns"
type action_receipt_actions_stddev_samp_fields {
  index_in_action_receipt: Float
  receipt_included_in_block_timestamp: Float
}

"aggregate sum on columns"
type action_receipt_actions_sum_fields {
  index_in_action_receipt: Int
  receipt_included_in_block_timestamp: numeric
}

"aggregate var_pop on columns"
type action_receipt_actions_var_pop_fields {
  index_in_action_receipt: Float
  receipt_included_in_block_timestamp: Float
}

"aggregate var_samp on columns"
type action_receipt_actions_var_samp_fields {
  index_in_action_receipt: Float
  receipt_included_in_block_timestamp: Float
}

"aggregate variance on columns"
type action_receipt_actions_variance_fields {
  index_in_action_receipt: Float
  receipt_included_in_block_timestamp: Float
}

"columns and relationships of \"assets__fungible_token_events\""
type assets__fungible_token_events {
  amount: String!
  emitted_at_block_timestamp: numeric!
  emitted_by_contract_account_id: String!
  emitted_for_receipt_id: String!
  emitted_in_shard_id: numeric!
  emitted_index_of_event_entry_in_shard: Int!
  event_kind: ft_event_kind!
  event_memo: String!
  "An object relationship"
  receipt: receipts!
  "An object relationship"
  token: fungible_tokens
  token_new_owner_account_id: String!
  token_old_owner_account_id: String!
}

"aggregated selection of \"assets__fungible_token_events\""
type assets__fungible_token_events_aggregate {
  aggregate: assets__fungible_token_events_aggregate_fields
  nodes: [assets__fungible_token_events!]!
}

"aggregate fields of \"assets__fungible_token_events\""
type assets__fungible_token_events_aggregate_fields {
  avg: assets__fungible_token_events_avg_fields
  count(columns: [assets__fungible_token_events_select_column!], distinct: Boolean): Int!
  max: assets__fungible_token_events_max_fields
  min: assets__fungible_token_events_min_fields
  stddev: assets__fungible_token_events_stddev_fields
  stddev_pop: assets__fungible_token_events_stddev_pop_fields
  stddev_samp: assets__fungible_token_events_stddev_samp_fields
  sum: assets__fungible_token_events_sum_fields
  var_pop: assets__fungible_token_events_var_pop_fields
  var_samp: assets__fungible_token_events_var_samp_fields
  variance: assets__fungible_token_events_variance_fields
}

"aggregate avg on columns"
type assets__fungible_token_events_avg_fields {
  emitted_at_block_timestamp: Float
  emitted_in_shard_id: Float
  emitted_index_of_event_entry_in_shard: Float
}

"aggregate max on columns"
type assets__fungible_token_events_max_fields {
  amount: String
  emitted_at_block_timestamp: numeric
  emitted_by_contract_account_id: String
  emitted_for_receipt_id: String
  emitted_in_shard_id: numeric
  emitted_index_of_event_entry_in_shard: Int
  event_kind: ft_event_kind
  event_memo: String
  token_new_owner_account_id: String
  token_old_owner_account_id: String
}

"aggregate min on columns"
type assets__fungible_token_events_min_fields {
  amount: String
  emitted_at_block_timestamp: numeric
  emitted_by_contract_account_id: String
  emitted_for_receipt_id: String
  emitted_in_shard_id: numeric
  emitted_index_of_event_entry_in_shard: Int
  event_kind: ft_event_kind
  event_memo: String
  token_new_owner_account_id: String
  token_old_owner_account_id: String
}

"aggregate stddev on columns"
type assets__fungible_token_events_stddev_fields {
  emitted_at_block_timestamp: Float
  emitted_in_shard_id: Float
  emitted_index_of_event_entry_in_shard: Float
}

"aggregate stddev_pop on columns"
type assets__fungible_token_events_stddev_pop_fields {
  emitted_at_block_timestamp: Float
  emitted_in_shard_id: Float
  emitted_index_of_event_entry_in_shard: Float
}

"aggregate stddev_samp on columns"
type assets__fungible_token_events_stddev_samp_fields {
  emitted_at_block_timestamp: Float
  emitted_in_shard_id: Float
  emitted_index_of_event_entry_in_shard: Float
}

"aggregate sum on columns"
type assets__fungible_token_events_sum_fields {
  emitted_at_block_timestamp: numeric
  emitted_in_shard_id: numeric
  emitted_index_of_event_entry_in_shard: Int
}

"aggregate var_pop on columns"
type assets__fungible_token_events_var_pop_fields {
  emitted_at_block_timestamp: Float
  emitted_in_shard_id: Float
  emitted_index_of_event_entry_in_shard: Float
}

"aggregate var_samp on columns"
type assets__fungible_token_events_var_samp_fields {
  emitted_at_block_timestamp: Float
  emitted_in_shard_id: Float
  emitted_index_of_event_entry_in_shard: Float
}

"aggregate variance on columns"
type assets__fungible_token_events_variance_fields {
  emitted_at_block_timestamp: Float
  emitted_in_shard_id: Float
  emitted_index_of_event_entry_in_shard: Float
}

"columns and relationships of \"assets__non_fungible_token_events\""
type assets__non_fungible_token_events {
  emitted_at_block_timestamp: numeric!
  emitted_by_contract_account_id: String!
  emitted_for_receipt_id: String!
  emitted_in_shard_id: numeric!
  emitted_index_of_event_entry_in_shard: Int!
  event_kind: nft_event_kind!
  event_memo: String!
  "An object relationship"
  meta: nft_contract_meta
  "An object relationship"
  receipt: receipts!
  "An object relationship"
  token: nft_token
  token_authorized_account_id: String!
  token_id: String!
  token_new_owner_account_id: String!
  token_old_owner_account_id: String!
}

"aggregated selection of \"assets__non_fungible_token_events\""
type assets__non_fungible_token_events_aggregate {
  aggregate: assets__non_fungible_token_events_aggregate_fields
  nodes: [assets__non_fungible_token_events!]!
}

"aggregate fields of \"assets__non_fungible_token_events\""
type assets__non_fungible_token_events_aggregate_fields {
  avg: assets__non_fungible_token_events_avg_fields
  count(columns: [assets__non_fungible_token_events_select_column!], distinct: Boolean): Int!
  max: assets__non_fungible_token_events_max_fields
  min: assets__non_fungible_token_events_min_fields
  stddev: assets__non_fungible_token_events_stddev_fields
  stddev_pop: assets__non_fungible_token_events_stddev_pop_fields
  stddev_samp: assets__non_fungible_token_events_stddev_samp_fields
  sum: assets__non_fungible_token_events_sum_fields
  var_pop: assets__non_fungible_token_events_var_pop_fields
  var_samp: assets__non_fungible_token_events_var_samp_fields
  variance: assets__non_fungible_token_events_variance_fields
}

"aggregate avg on columns"
type assets__non_fungible_token_events_avg_fields {
  emitted_at_block_timestamp: Float
  emitted_in_shard_id: Float
  emitted_index_of_event_entry_in_shard: Float
}

"aggregate max on columns"
type assets__non_fungible_token_events_max_fields {
  emitted_at_block_timestamp: numeric
  emitted_by_contract_account_id: String
  emitted_for_receipt_id: String
  emitted_in_shard_id: numeric
  emitted_index_of_event_entry_in_shard: Int
  event_kind: nft_event_kind
  event_memo: String
  token_authorized_account_id: String
  token_id: String
  token_new_owner_account_id: String
  token_old_owner_account_id: String
}

"aggregate min on columns"
type assets__non_fungible_token_events_min_fields {
  emitted_at_block_timestamp: numeric
  emitted_by_contract_account_id: String
  emitted_for_receipt_id: String
  emitted_in_shard_id: numeric
  emitted_index_of_event_entry_in_shard: Int
  event_kind: nft_event_kind
  event_memo: String
  token_authorized_account_id: String
  token_id: String
  token_new_owner_account_id: String
  token_old_owner_account_id: String
}

"aggregate stddev on columns"
type assets__non_fungible_token_events_stddev_fields {
  emitted_at_block_timestamp: Float
  emitted_in_shard_id: Float
  emitted_index_of_event_entry_in_shard: Float
}

"aggregate stddev_pop on columns"
type assets__non_fungible_token_events_stddev_pop_fields {
  emitted_at_block_timestamp: Float
  emitted_in_shard_id: Float
  emitted_index_of_event_entry_in_shard: Float
}

"aggregate stddev_samp on columns"
type assets__non_fungible_token_events_stddev_samp_fields {
  emitted_at_block_timestamp: Float
  emitted_in_shard_id: Float
  emitted_index_of_event_entry_in_shard: Float
}

"aggregate sum on columns"
type assets__non_fungible_token_events_sum_fields {
  emitted_at_block_timestamp: numeric
  emitted_in_shard_id: numeric
  emitted_index_of_event_entry_in_shard: Int
}

"aggregate var_pop on columns"
type assets__non_fungible_token_events_var_pop_fields {
  emitted_at_block_timestamp: Float
  emitted_in_shard_id: Float
  emitted_index_of_event_entry_in_shard: Float
}

"aggregate var_samp on columns"
type assets__non_fungible_token_events_var_samp_fields {
  emitted_at_block_timestamp: Float
  emitted_in_shard_id: Float
  emitted_index_of_event_entry_in_shard: Float
}

"aggregate variance on columns"
type assets__non_fungible_token_events_variance_fields {
  emitted_at_block_timestamp: Float
  emitted_in_shard_id: Float
  emitted_index_of_event_entry_in_shard: Float
}

"columns and relationships of \"blocks\""
type blocks {
  author_account_id: String!
  block_hash: String!
  block_height: numeric!
  block_timestamp: numeric!
  "An array relationship"
  chunks(
    "distinct select on columns"
    distinct_on: [chunks_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [chunks_order_by!]
    "filter the rows returned"
    where: chunks_bool_exp
  ): [chunks!]!
  "An aggregate relationship"
  chunks_aggregate(
    "distinct select on columns"
    distinct_on: [chunks_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [chunks_order_by!]
    "filter the rows returned"
    where: chunks_bool_exp
  ): chunks_aggregate!
  "An array relationship"
  execution_outcomes(
    "distinct select on columns"
    distinct_on: [execution_outcomes_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [execution_outcomes_order_by!]
    "filter the rows returned"
    where: execution_outcomes_bool_exp
  ): [execution_outcomes!]!
  gas_price: numeric!
  prev_block_hash: String!
  "An array relationship"
  receipts(
    "distinct select on columns"
    distinct_on: [receipts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [receipts_order_by!]
    "filter the rows returned"
    where: receipts_bool_exp
  ): [receipts!]!
  "An aggregate relationship"
  receipts_aggregate(
    "distinct select on columns"
    distinct_on: [receipts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [receipts_order_by!]
    "filter the rows returned"
    where: receipts_bool_exp
  ): receipts_aggregate!
  total_supply: numeric!
  "An array relationship"
  transactions(
    "distinct select on columns"
    distinct_on: [transactions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [transactions_order_by!]
    "filter the rows returned"
    where: transactions_bool_exp
  ): [transactions!]!
  "An aggregate relationship"
  transactions_aggregate(
    "distinct select on columns"
    distinct_on: [transactions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [transactions_order_by!]
    "filter the rows returned"
    where: transactions_bool_exp
  ): transactions_aggregate!
}

"aggregated selection of \"blocks\""
type blocks_aggregate {
  aggregate: blocks_aggregate_fields
  nodes: [blocks!]!
}

"aggregate fields of \"blocks\""
type blocks_aggregate_fields {
  avg: blocks_avg_fields
  count(columns: [blocks_select_column!], distinct: Boolean): Int!
  max: blocks_max_fields
  min: blocks_min_fields
  stddev: blocks_stddev_fields
  stddev_pop: blocks_stddev_pop_fields
  stddev_samp: blocks_stddev_samp_fields
  sum: blocks_sum_fields
  var_pop: blocks_var_pop_fields
  var_samp: blocks_var_samp_fields
  variance: blocks_variance_fields
}

"aggregate avg on columns"
type blocks_avg_fields {
  block_height: Float
  block_timestamp: Float
  gas_price: Float
  total_supply: Float
}

"aggregate max on columns"
type blocks_max_fields {
  author_account_id: String
  block_hash: String
  block_height: numeric
  block_timestamp: numeric
  gas_price: numeric
  prev_block_hash: String
  total_supply: numeric
}

"aggregate min on columns"
type blocks_min_fields {
  author_account_id: String
  block_hash: String
  block_height: numeric
  block_timestamp: numeric
  gas_price: numeric
  prev_block_hash: String
  total_supply: numeric
}

"aggregate stddev on columns"
type blocks_stddev_fields {
  block_height: Float
  block_timestamp: Float
  gas_price: Float
  total_supply: Float
}

"aggregate stddev_pop on columns"
type blocks_stddev_pop_fields {
  block_height: Float
  block_timestamp: Float
  gas_price: Float
  total_supply: Float
}

"aggregate stddev_samp on columns"
type blocks_stddev_samp_fields {
  block_height: Float
  block_timestamp: Float
  gas_price: Float
  total_supply: Float
}

"aggregate sum on columns"
type blocks_sum_fields {
  block_height: numeric
  block_timestamp: numeric
  gas_price: numeric
  total_supply: numeric
}

"aggregate var_pop on columns"
type blocks_var_pop_fields {
  block_height: Float
  block_timestamp: Float
  gas_price: Float
  total_supply: Float
}

"aggregate var_samp on columns"
type blocks_var_samp_fields {
  block_height: Float
  block_timestamp: Float
  gas_price: Float
  total_supply: Float
}

"aggregate variance on columns"
type blocks_variance_fields {
  block_height: Float
  block_timestamp: Float
  gas_price: Float
  total_supply: Float
}

"columns and relationships of \"chunks\""
type chunks {
  author_account_id: String!
  "An object relationship"
  block: blocks!
  chunk_hash: String!
  gas_limit: numeric!
  gas_used: numeric!
  included_in_block_hash: String!
  "An array relationship"
  receipts(
    "distinct select on columns"
    distinct_on: [receipts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [receipts_order_by!]
    "filter the rows returned"
    where: receipts_bool_exp
  ): [receipts!]!
  "An aggregate relationship"
  receipts_aggregate(
    "distinct select on columns"
    distinct_on: [receipts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [receipts_order_by!]
    "filter the rows returned"
    where: receipts_bool_exp
  ): receipts_aggregate!
  shard_id: numeric!
  signature: String!
  "An array relationship"
  transactions(
    "distinct select on columns"
    distinct_on: [transactions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [transactions_order_by!]
    "filter the rows returned"
    where: transactions_bool_exp
  ): [transactions!]!
  "An aggregate relationship"
  transactions_aggregate(
    "distinct select on columns"
    distinct_on: [transactions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [transactions_order_by!]
    "filter the rows returned"
    where: transactions_bool_exp
  ): transactions_aggregate!
}

"aggregated selection of \"chunks\""
type chunks_aggregate {
  aggregate: chunks_aggregate_fields
  nodes: [chunks!]!
}

"aggregate fields of \"chunks\""
type chunks_aggregate_fields {
  avg: chunks_avg_fields
  count(columns: [chunks_select_column!], distinct: Boolean): Int!
  max: chunks_max_fields
  min: chunks_min_fields
  stddev: chunks_stddev_fields
  stddev_pop: chunks_stddev_pop_fields
  stddev_samp: chunks_stddev_samp_fields
  sum: chunks_sum_fields
  var_pop: chunks_var_pop_fields
  var_samp: chunks_var_samp_fields
  variance: chunks_variance_fields
}

"aggregate avg on columns"
type chunks_avg_fields {
  gas_limit: Float
  gas_used: Float
  shard_id: Float
}

"aggregate max on columns"
type chunks_max_fields {
  author_account_id: String
  chunk_hash: String
  gas_limit: numeric
  gas_used: numeric
  included_in_block_hash: String
  shard_id: numeric
  signature: String
}

"aggregate min on columns"
type chunks_min_fields {
  author_account_id: String
  chunk_hash: String
  gas_limit: numeric
  gas_used: numeric
  included_in_block_hash: String
  shard_id: numeric
  signature: String
}

"aggregate stddev on columns"
type chunks_stddev_fields {
  gas_limit: Float
  gas_used: Float
  shard_id: Float
}

"aggregate stddev_pop on columns"
type chunks_stddev_pop_fields {
  gas_limit: Float
  gas_used: Float
  shard_id: Float
}

"aggregate stddev_samp on columns"
type chunks_stddev_samp_fields {
  gas_limit: Float
  gas_used: Float
  shard_id: Float
}

"aggregate sum on columns"
type chunks_sum_fields {
  gas_limit: numeric
  gas_used: numeric
  shard_id: numeric
}

"aggregate var_pop on columns"
type chunks_var_pop_fields {
  gas_limit: Float
  gas_used: Float
  shard_id: Float
}

"aggregate var_samp on columns"
type chunks_var_samp_fields {
  gas_limit: Float
  gas_used: Float
  shard_id: Float
}

"aggregate variance on columns"
type chunks_variance_fields {
  gas_limit: Float
  gas_used: Float
  shard_id: Float
}

"columns and relationships of \"daily_stats\""
type daily_stats {
  addresses: numeric!
  avg_gas_limit: String!
  avg_gas_price: String!
  avg_txn_fee: String!
  avg_txn_fee_usd: numeric!
  blocks: numeric!
  contracts: numeric!
  date: date!
  gas_fee: String!
  gas_used: String!
  id: bigint!
  market_cap: numeric!
  near_price: numeric!
  receiver_addresses: numeric!
  sender_addresses: numeric!
  total_addresses: numeric!
  total_contracts: numeric!
  total_supply: String!
  txn_fee: String!
  txn_fee_usd: numeric!
  txn_volume: String!
  txn_volume_usd: numeric!
  txns: numeric!
}

"columns and relationships of \"execution_outcomes\""
type execution_outcomes {
  "An object relationship"
  block: blocks!
  executed_in_block_hash: String!
  executed_in_block_timestamp: numeric!
  executor_account_id: String!
  gas_burnt: numeric!
  index_in_chunk: Int!
  "An object relationship"
  receipt: receipts!
  receipt_id: String!
  shard_id: numeric!
  status: execution_outcome_status!
  tokens_burnt: numeric!
}

"columns and relationships of \"ft_balance\""
type ft_balance {
  amount: numeric
  emitted_by_contract_account_id: String
  "An object relationship"
  ft_meta: ft_meta
}

"columns and relationships of \"ft_holder\""
type ft_holder {
  account: String!
  amount: numeric!
  rank: Int!
}

"aggregated selection of \"ft_holder\""
type ft_holder_aggregate {
  aggregate: ft_holder_aggregate_fields
  nodes: [ft_holder!]!
}

"aggregate fields of \"ft_holder\""
type ft_holder_aggregate_fields {
  avg: ft_holder_avg_fields
  count(columns: [ft_holder_select_column!], distinct: Boolean): Int!
  max: ft_holder_max_fields
  min: ft_holder_min_fields
  stddev: ft_holder_stddev_fields
  stddev_pop: ft_holder_stddev_pop_fields
  stddev_samp: ft_holder_stddev_samp_fields
  sum: ft_holder_sum_fields
  var_pop: ft_holder_var_pop_fields
  var_samp: ft_holder_var_samp_fields
  variance: ft_holder_variance_fields
}

"aggregate avg on columns"
type ft_holder_avg_fields {
  amount: Float
  rank: Float
}

"aggregate max on columns"
type ft_holder_max_fields {
  account: String
  amount: numeric
  rank: Int
}

"aggregate min on columns"
type ft_holder_min_fields {
  account: String
  amount: numeric
  rank: Int
}

"aggregate stddev on columns"
type ft_holder_stddev_fields {
  amount: Float
  rank: Float
}

"aggregate stddev_pop on columns"
type ft_holder_stddev_pop_fields {
  amount: Float
  rank: Float
}

"aggregate stddev_samp on columns"
type ft_holder_stddev_samp_fields {
  amount: Float
  rank: Float
}

"aggregate sum on columns"
type ft_holder_sum_fields {
  amount: numeric
  rank: Int
}

"aggregate var_pop on columns"
type ft_holder_var_pop_fields {
  amount: Float
  rank: Float
}

"aggregate var_samp on columns"
type ft_holder_var_samp_fields {
  amount: Float
  rank: Float
}

"aggregate variance on columns"
type ft_holder_variance_fields {
  amount: Float
  rank: Float
}

"columns and relationships of \"ft_meta\""
type ft_meta {
  change_24: numeric
  circulating_supply: numeric
  coingecko_id: String
  coinmarketcap_id: String
  decimals: numeric
  description: String
  emitted_by_contract_account_id: String!
  extra("JSON select path" path: String): jsonb
  facebook: String
  fully_diluted_market_cap: numeric
  market_cap: numeric
  name: String
  price: numeric
  price_btc: numeric
  price_eth: numeric
  reddit: String
  site_url: String
  symbol: String
  telegram: String
  twitter: String
  verified: Boolean
  volume_24h: numeric
}

"columns and relationships of \"ft_tokens_view\""
type ft_tokens_view {
  emitted_by_contract_account_id: String
  "An object relationship"
  ft_token_events: assets__fungible_token_events
  "An object relationship"
  metainfo: ft_meta
  "An array relationship"
  token_events(
    "distinct select on columns"
    distinct_on: [assets__fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__fungible_token_events_bool_exp
  ): [assets__fungible_token_events!]!
  "An aggregate relationship"
  token_events_aggregate(
    "distinct select on columns"
    distinct_on: [assets__fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__fungible_token_events_bool_exp
  ): assets__fungible_token_events_aggregate!
  totalsupply: numeric
}

"aggregated selection of \"ft_tokens_view\""
type ft_tokens_view_aggregate {
  aggregate: ft_tokens_view_aggregate_fields
  nodes: [ft_tokens_view!]!
}

"aggregate fields of \"ft_tokens_view\""
type ft_tokens_view_aggregate_fields {
  avg: ft_tokens_view_avg_fields
  count(columns: [ft_tokens_view_select_column!], distinct: Boolean): Int!
  max: ft_tokens_view_max_fields
  min: ft_tokens_view_min_fields
  stddev: ft_tokens_view_stddev_fields
  stddev_pop: ft_tokens_view_stddev_pop_fields
  stddev_samp: ft_tokens_view_stddev_samp_fields
  sum: ft_tokens_view_sum_fields
  var_pop: ft_tokens_view_var_pop_fields
  var_samp: ft_tokens_view_var_samp_fields
  variance: ft_tokens_view_variance_fields
}

"aggregate avg on columns"
type ft_tokens_view_avg_fields {
  totalsupply: Float
}

"aggregate max on columns"
type ft_tokens_view_max_fields {
  emitted_by_contract_account_id: String
  totalsupply: numeric
}

"aggregate min on columns"
type ft_tokens_view_min_fields {
  emitted_by_contract_account_id: String
  totalsupply: numeric
}

"aggregate stddev on columns"
type ft_tokens_view_stddev_fields {
  totalsupply: Float
}

"aggregate stddev_pop on columns"
type ft_tokens_view_stddev_pop_fields {
  totalsupply: Float
}

"aggregate stddev_samp on columns"
type ft_tokens_view_stddev_samp_fields {
  totalsupply: Float
}

"aggregate sum on columns"
type ft_tokens_view_sum_fields {
  totalsupply: numeric
}

"aggregate var_pop on columns"
type ft_tokens_view_var_pop_fields {
  totalsupply: Float
}

"aggregate var_samp on columns"
type ft_tokens_view_var_samp_fields {
  totalsupply: Float
}

"aggregate variance on columns"
type ft_tokens_view_variance_fields {
  totalsupply: Float
}

"columns and relationships of \"ft_transfer\""
type ft_transfer {
  action_kind: action_kind!
  args("JSON select path" path: String): jsonb!
  index_in_action_receipt: Int!
  originated_from_transaction_hash: String!
  receipt_id: String!
  receipt_included_in_block_timestamp: numeric!
  receipt_predecessor_account_id: String!
  receipt_receiver_account_id: String!
}

type ft_transfer_aggregate {
  aggregate: ft_transfer_aggregate_fields
  nodes: [ft_transfer!]!
}

"aggregate fields of \"ft_transfer\""
type ft_transfer_aggregate_fields {
  avg: ft_transfer_avg_fields
  count(columns: [ft_transfer_select_column!], distinct: Boolean): Int!
  max: ft_transfer_max_fields
  min: ft_transfer_min_fields
  stddev: ft_transfer_stddev_fields
  stddev_pop: ft_transfer_stddev_pop_fields
  stddev_samp: ft_transfer_stddev_samp_fields
  sum: ft_transfer_sum_fields
  var_pop: ft_transfer_var_pop_fields
  var_samp: ft_transfer_var_samp_fields
  variance: ft_transfer_variance_fields
}

"aggregate avg on columns"
type ft_transfer_avg_fields {
  index_in_action_receipt: Float
  receipt_included_in_block_timestamp: Float
}

"columns and relationships of \"ft_transfer_count\""
type ft_transfer_count {
  contract: String!
  transfers: numeric!
}

"aggregate max on columns"
type ft_transfer_max_fields {
  action_kind: action_kind
  index_in_action_receipt: Int
  originated_from_transaction_hash: String
  receipt_id: String
  receipt_included_in_block_timestamp: numeric
  receipt_predecessor_account_id: String
  receipt_receiver_account_id: String
}

"aggregate min on columns"
type ft_transfer_min_fields {
  action_kind: action_kind
  index_in_action_receipt: Int
  originated_from_transaction_hash: String
  receipt_id: String
  receipt_included_in_block_timestamp: numeric
  receipt_predecessor_account_id: String
  receipt_receiver_account_id: String
}

"aggregate stddev on columns"
type ft_transfer_stddev_fields {
  index_in_action_receipt: Float
  receipt_included_in_block_timestamp: Float
}

"aggregate stddev_pop on columns"
type ft_transfer_stddev_pop_fields {
  index_in_action_receipt: Float
  receipt_included_in_block_timestamp: Float
}

"aggregate stddev_samp on columns"
type ft_transfer_stddev_samp_fields {
  index_in_action_receipt: Float
  receipt_included_in_block_timestamp: Float
}

"aggregate sum on columns"
type ft_transfer_sum_fields {
  index_in_action_receipt: Int
  receipt_included_in_block_timestamp: numeric
}

"aggregate var_pop on columns"
type ft_transfer_var_pop_fields {
  index_in_action_receipt: Float
  receipt_included_in_block_timestamp: Float
}

"aggregate var_samp on columns"
type ft_transfer_var_samp_fields {
  index_in_action_receipt: Float
  receipt_included_in_block_timestamp: Float
}

"aggregate variance on columns"
type ft_transfer_variance_fields {
  index_in_action_receipt: Float
  receipt_included_in_block_timestamp: Float
}

"columns and relationships of \"fungible_tokens\""
type fungible_tokens {
  args("JSON select path" path: String): jsonb
  emitted_by_contract_account_id: String
  "An object relationship"
  ft_token_events: assets__fungible_token_events
  "An object relationship"
  metainfo: ft_meta
  "An array relationship"
  token_events(
    "distinct select on columns"
    distinct_on: [assets__fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__fungible_token_events_bool_exp
  ): [assets__fungible_token_events!]!
  "An aggregate relationship"
  token_events_aggregate(
    "distinct select on columns"
    distinct_on: [assets__fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__fungible_token_events_bool_exp
  ): assets__fungible_token_events_aggregate!
  totalsupply: numeric
}

"aggregated selection of \"fungible_tokens\""
type fungible_tokens_aggregate {
  aggregate: fungible_tokens_aggregate_fields
  nodes: [fungible_tokens!]!
}

"aggregate fields of \"fungible_tokens\""
type fungible_tokens_aggregate_fields {
  avg: fungible_tokens_avg_fields
  count(columns: [fungible_tokens_select_column!], distinct: Boolean): Int!
  max: fungible_tokens_max_fields
  min: fungible_tokens_min_fields
  stddev: fungible_tokens_stddev_fields
  stddev_pop: fungible_tokens_stddev_pop_fields
  stddev_samp: fungible_tokens_stddev_samp_fields
  sum: fungible_tokens_sum_fields
  var_pop: fungible_tokens_var_pop_fields
  var_samp: fungible_tokens_var_samp_fields
  variance: fungible_tokens_variance_fields
}

"aggregate avg on columns"
type fungible_tokens_avg_fields {
  totalsupply: Float
}

"aggregate max on columns"
type fungible_tokens_max_fields {
  emitted_by_contract_account_id: String
  totalsupply: numeric
}

"aggregate min on columns"
type fungible_tokens_min_fields {
  emitted_by_contract_account_id: String
  totalsupply: numeric
}

"aggregate stddev on columns"
type fungible_tokens_stddev_fields {
  totalsupply: Float
}

"aggregate stddev_pop on columns"
type fungible_tokens_stddev_pop_fields {
  totalsupply: Float
}

"aggregate stddev_samp on columns"
type fungible_tokens_stddev_samp_fields {
  totalsupply: Float
}

"aggregate sum on columns"
type fungible_tokens_sum_fields {
  totalsupply: numeric
}

"aggregate var_pop on columns"
type fungible_tokens_var_pop_fields {
  totalsupply: Float
}

"aggregate var_samp on columns"
type fungible_tokens_var_samp_fields {
  totalsupply: Float
}

"aggregate variance on columns"
type fungible_tokens_variance_fields {
  totalsupply: Float
}

"columns and relationships of \"legacy_ft_meta\""
type legacy_ft_meta {
  args("JSON select path" path: String): jsonb
  change_24: numeric
  circulating_supply: numeric
  coingecko_id: String
  coinmarketcap_id: String
  contract: String!
  decimals: Int!
  description: String
  facebook: String
  fully_diluted_market_cap: numeric
  icon: String
  market_cap: numeric
  name: String!
  price: numeric
  price_btc: numeric
  price_eth: numeric
  reddit: String
  status: Boolean
  symbol: String!
  telegram: String
  total_supply: numeric!
  twitter: String
  volume_24h: numeric
  website: String
}

"aggregated selection of \"legacy_ft_meta\""
type legacy_ft_meta_aggregate {
  aggregate: legacy_ft_meta_aggregate_fields
  nodes: [legacy_ft_meta!]!
}

"aggregate fields of \"legacy_ft_meta\""
type legacy_ft_meta_aggregate_fields {
  avg: legacy_ft_meta_avg_fields
  count(columns: [legacy_ft_meta_select_column!], distinct: Boolean): Int!
  max: legacy_ft_meta_max_fields
  min: legacy_ft_meta_min_fields
  stddev: legacy_ft_meta_stddev_fields
  stddev_pop: legacy_ft_meta_stddev_pop_fields
  stddev_samp: legacy_ft_meta_stddev_samp_fields
  sum: legacy_ft_meta_sum_fields
  var_pop: legacy_ft_meta_var_pop_fields
  var_samp: legacy_ft_meta_var_samp_fields
  variance: legacy_ft_meta_variance_fields
}

"aggregate avg on columns"
type legacy_ft_meta_avg_fields {
  change_24: Float
  circulating_supply: Float
  decimals: Float
  fully_diluted_market_cap: Float
  market_cap: Float
  price: Float
  price_btc: Float
  price_eth: Float
  total_supply: Float
  volume_24h: Float
}

"aggregate max on columns"
type legacy_ft_meta_max_fields {
  change_24: numeric
  circulating_supply: numeric
  coingecko_id: String
  coinmarketcap_id: String
  contract: String
  decimals: Int
  description: String
  facebook: String
  fully_diluted_market_cap: numeric
  icon: String
  market_cap: numeric
  name: String
  price: numeric
  price_btc: numeric
  price_eth: numeric
  reddit: String
  symbol: String
  telegram: String
  total_supply: numeric
  twitter: String
  volume_24h: numeric
  website: String
}

"aggregate min on columns"
type legacy_ft_meta_min_fields {
  change_24: numeric
  circulating_supply: numeric
  coingecko_id: String
  coinmarketcap_id: String
  contract: String
  decimals: Int
  description: String
  facebook: String
  fully_diluted_market_cap: numeric
  icon: String
  market_cap: numeric
  name: String
  price: numeric
  price_btc: numeric
  price_eth: numeric
  reddit: String
  symbol: String
  telegram: String
  total_supply: numeric
  twitter: String
  volume_24h: numeric
  website: String
}

"aggregate stddev on columns"
type legacy_ft_meta_stddev_fields {
  change_24: Float
  circulating_supply: Float
  decimals: Float
  fully_diluted_market_cap: Float
  market_cap: Float
  price: Float
  price_btc: Float
  price_eth: Float
  total_supply: Float
  volume_24h: Float
}

"aggregate stddev_pop on columns"
type legacy_ft_meta_stddev_pop_fields {
  change_24: Float
  circulating_supply: Float
  decimals: Float
  fully_diluted_market_cap: Float
  market_cap: Float
  price: Float
  price_btc: Float
  price_eth: Float
  total_supply: Float
  volume_24h: Float
}

"aggregate stddev_samp on columns"
type legacy_ft_meta_stddev_samp_fields {
  change_24: Float
  circulating_supply: Float
  decimals: Float
  fully_diluted_market_cap: Float
  market_cap: Float
  price: Float
  price_btc: Float
  price_eth: Float
  total_supply: Float
  volume_24h: Float
}

"aggregate sum on columns"
type legacy_ft_meta_sum_fields {
  change_24: numeric
  circulating_supply: numeric
  decimals: Int
  fully_diluted_market_cap: numeric
  market_cap: numeric
  price: numeric
  price_btc: numeric
  price_eth: numeric
  total_supply: numeric
  volume_24h: numeric
}

"aggregate var_pop on columns"
type legacy_ft_meta_var_pop_fields {
  change_24: Float
  circulating_supply: Float
  decimals: Float
  fully_diluted_market_cap: Float
  market_cap: Float
  price: Float
  price_btc: Float
  price_eth: Float
  total_supply: Float
  volume_24h: Float
}

"aggregate var_samp on columns"
type legacy_ft_meta_var_samp_fields {
  change_24: Float
  circulating_supply: Float
  decimals: Float
  fully_diluted_market_cap: Float
  market_cap: Float
  price: Float
  price_btc: Float
  price_eth: Float
  total_supply: Float
  volume_24h: Float
}

"aggregate variance on columns"
type legacy_ft_meta_variance_fields {
  change_24: Float
  circulating_supply: Float
  decimals: Float
  fully_diluted_market_cap: Float
  market_cap: Float
  price: Float
  price_btc: Float
  price_eth: Float
  total_supply: Float
  volume_24h: Float
}

"columns and relationships of \"nft_contract_meta\""
type nft_contract_meta {
  base_uri: String
  emitted_by_contract_account_id: String!
  icon: String
  name: String
  reference: String
  reference_hash: String
  spec: String
  symbol: String
  "An array relationship"
  tokens(
    "distinct select on columns"
    distinct_on: [nft_token_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [nft_token_order_by!]
    "filter the rows returned"
    where: nft_token_bool_exp
  ): [nft_token!]!
}

"columns and relationships of \"nft_token\""
type nft_token {
  "An object relationship"
  contract_meta: nft_contract_meta
  copies: String
  description: String
  emitted_by_contract_account_id: String!
  expires_at: String
  extra("JSON select path" path: String): jsonb
  issued_at: String
  media: String
  owner_id: String
  starts_at: String
  title: String
  token_id: String!
  updated_at: String
}

"columns and relationships of \"nft_token_holders\""
type nft_token_holders {
  account: String
  contract: String
  quantity: numeric
}

"aggregated selection of \"nft_token_holders\""
type nft_token_holders_aggregate {
  aggregate: nft_token_holders_aggregate_fields
  nodes: [nft_token_holders!]!
}

"aggregate fields of \"nft_token_holders\""
type nft_token_holders_aggregate_fields {
  avg: nft_token_holders_avg_fields
  count(columns: [nft_token_holders_select_column!], distinct: Boolean): Int!
  max: nft_token_holders_max_fields
  min: nft_token_holders_min_fields
  stddev: nft_token_holders_stddev_fields
  stddev_pop: nft_token_holders_stddev_pop_fields
  stddev_samp: nft_token_holders_stddev_samp_fields
  sum: nft_token_holders_sum_fields
  var_pop: nft_token_holders_var_pop_fields
  var_samp: nft_token_holders_var_samp_fields
  variance: nft_token_holders_variance_fields
}

"aggregate avg on columns"
type nft_token_holders_avg_fields {
  quantity: Float
}

"aggregate max on columns"
type nft_token_holders_max_fields {
  account: String
  contract: String
  quantity: numeric
}

"aggregate min on columns"
type nft_token_holders_min_fields {
  account: String
  contract: String
  quantity: numeric
}

"aggregate stddev on columns"
type nft_token_holders_stddev_fields {
  quantity: Float
}

"aggregate stddev_pop on columns"
type nft_token_holders_stddev_pop_fields {
  quantity: Float
}

"aggregate stddev_samp on columns"
type nft_token_holders_stddev_samp_fields {
  quantity: Float
}

"aggregate sum on columns"
type nft_token_holders_sum_fields {
  quantity: numeric
}

"aggregate var_pop on columns"
type nft_token_holders_var_pop_fields {
  quantity: Float
}

"aggregate var_samp on columns"
type nft_token_holders_var_samp_fields {
  quantity: Float
}

"aggregate variance on columns"
type nft_token_holders_variance_fields {
  quantity: Float
}

type query_root {
  "An array relationship"
  access_keys(
    "distinct select on columns"
    distinct_on: [access_keys_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [access_keys_order_by!]
    "filter the rows returned"
    where: access_keys_bool_exp
  ): [access_keys!]!
  "An aggregate relationship"
  access_keys_aggregate(
    "distinct select on columns"
    distinct_on: [access_keys_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [access_keys_order_by!]
    "filter the rows returned"
    where: access_keys_bool_exp
  ): access_keys_aggregate!
  "fetch data from the table: \"access_keys\" using primary key columns"
  access_keys_by_pk(account_id: String!, public_key: String!): access_keys
  "An array relationship"
  accounts(
    "distinct select on columns"
    distinct_on: [accounts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [accounts_order_by!]
    "filter the rows returned"
    where: accounts_bool_exp
  ): [accounts!]!
  "An aggregate relationship"
  accounts_aggregate(
    "distinct select on columns"
    distinct_on: [accounts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [accounts_order_by!]
    "filter the rows returned"
    where: accounts_bool_exp
  ): accounts_aggregate!
  "fetch data from the table: \"accounts\" using primary key columns"
  accounts_by_pk(id: bigint!): accounts
  "fetch data from the table: \"accounts_label\""
  accounts_label(
    "distinct select on columns"
    distinct_on: [accounts_label_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [accounts_label_order_by!]
    "filter the rows returned"
    where: accounts_label_bool_exp
  ): [accounts_label!]!
  "fetch data from the table: \"accounts_label\" using primary key columns"
  accounts_label_by_pk(id: bigint!): accounts_label
  "An array relationship"
  action_receipt_actions(
    "distinct select on columns"
    distinct_on: [action_receipt_actions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [action_receipt_actions_order_by!]
    "filter the rows returned"
    where: action_receipt_actions_bool_exp
  ): [action_receipt_actions!]!
  "An aggregate relationship"
  action_receipt_actions_aggregate(
    "distinct select on columns"
    distinct_on: [action_receipt_actions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [action_receipt_actions_order_by!]
    "filter the rows returned"
    where: action_receipt_actions_bool_exp
  ): action_receipt_actions_aggregate!
  "fetch data from the table: \"action_receipt_actions\" using primary key columns"
  action_receipt_actions_by_pk(
    index_in_action_receipt: Int!
    receipt_id: String!
  ): action_receipt_actions
  "An array relationship"
  assets__fungible_token_events(
    "distinct select on columns"
    distinct_on: [assets__fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__fungible_token_events_bool_exp
  ): [assets__fungible_token_events!]!
  "An aggregate relationship"
  assets__fungible_token_events_aggregate(
    "distinct select on columns"
    distinct_on: [assets__fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__fungible_token_events_bool_exp
  ): assets__fungible_token_events_aggregate!
  "fetch data from the table: \"assets__fungible_token_events\" using primary key columns"
  assets__fungible_token_events_by_pk(
    amount: String!
    emitted_at_block_timestamp: numeric!
    emitted_by_contract_account_id: String!
    emitted_for_receipt_id: String!
    emitted_in_shard_id: numeric!
    emitted_index_of_event_entry_in_shard: Int!
    event_kind: ft_event_kind!
    event_memo: String!
    token_new_owner_account_id: String!
    token_old_owner_account_id: String!
  ): assets__fungible_token_events
  "An array relationship"
  assets__non_fungible_token_events(
    "distinct select on columns"
    distinct_on: [assets__non_fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__non_fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__non_fungible_token_events_bool_exp
  ): [assets__non_fungible_token_events!]!
  "An aggregate relationship"
  assets__non_fungible_token_events_aggregate(
    "distinct select on columns"
    distinct_on: [assets__non_fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__non_fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__non_fungible_token_events_bool_exp
  ): assets__non_fungible_token_events_aggregate!
  "fetch data from the table: \"assets__non_fungible_token_events\" using primary key columns"
  assets__non_fungible_token_events_by_pk(
    emitted_at_block_timestamp: numeric!
    emitted_by_contract_account_id: String!
    emitted_for_receipt_id: String!
    emitted_in_shard_id: numeric!
    emitted_index_of_event_entry_in_shard: Int!
    event_kind: nft_event_kind!
    event_memo: String!
    token_authorized_account_id: String!
    token_id: String!
    token_new_owner_account_id: String!
    token_old_owner_account_id: String!
  ): assets__non_fungible_token_events
  "fetch data from the table: \"blocks\""
  blocks(
    "distinct select on columns"
    distinct_on: [blocks_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [blocks_order_by!]
    "filter the rows returned"
    where: blocks_bool_exp
  ): [blocks!]!
  "fetch aggregated fields from the table: \"blocks\""
  blocks_aggregate(
    "distinct select on columns"
    distinct_on: [blocks_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [blocks_order_by!]
    "filter the rows returned"
    where: blocks_bool_exp
  ): blocks_aggregate!
  "fetch data from the table: \"blocks\" using primary key columns"
  blocks_by_pk(block_hash: String!): blocks
  "An array relationship"
  chunks(
    "distinct select on columns"
    distinct_on: [chunks_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [chunks_order_by!]
    "filter the rows returned"
    where: chunks_bool_exp
  ): [chunks!]!
  "An aggregate relationship"
  chunks_aggregate(
    "distinct select on columns"
    distinct_on: [chunks_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [chunks_order_by!]
    "filter the rows returned"
    where: chunks_bool_exp
  ): chunks_aggregate!
  "fetch data from the table: \"chunks\" using primary key columns"
  chunks_by_pk(chunk_hash: String!): chunks
  "fetch data from the table: \"daily_stats\""
  daily_stats(
    "distinct select on columns"
    distinct_on: [daily_stats_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [daily_stats_order_by!]
    "filter the rows returned"
    where: daily_stats_bool_exp
  ): [daily_stats!]!
  "fetch data from the table: \"daily_stats\" using primary key columns"
  daily_stats_by_pk(id: bigint!): daily_stats
  "An array relationship"
  execution_outcomes(
    "distinct select on columns"
    distinct_on: [execution_outcomes_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [execution_outcomes_order_by!]
    "filter the rows returned"
    where: execution_outcomes_bool_exp
  ): [execution_outcomes!]!
  "fetch data from the table: \"execution_outcomes\" using primary key columns"
  execution_outcomes_by_pk(receipt_id: String!): execution_outcomes
  "fetch data from the table: \"ft_balance\""
  ft_balance(
    "distinct select on columns"
    distinct_on: [ft_balance_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_balance_order_by!]
    "filter the rows returned"
    where: ft_balance_bool_exp
  ): [ft_balance!]!
  "execute function \"ft_balances\" which returns \"ft_balance\""
  ft_balances(
    "input parameters for function \"ft_balances\""
    args: ft_balances_args!
    "distinct select on columns"
    distinct_on: [ft_balance_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_balance_order_by!]
    "filter the rows returned"
    where: ft_balance_bool_exp
  ): [ft_balance!]!
  "fetch data from the table: \"ft_holder\""
  ft_holder(
    "distinct select on columns"
    distinct_on: [ft_holder_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_holder_order_by!]
    "filter the rows returned"
    where: ft_holder_bool_exp
  ): [ft_holder!]!
  "fetch aggregated fields from the table: \"ft_holder\""
  ft_holder_aggregate(
    "distinct select on columns"
    distinct_on: [ft_holder_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_holder_order_by!]
    "filter the rows returned"
    where: ft_holder_bool_exp
  ): ft_holder_aggregate!
  "fetch data from the table: \"ft_holder\" using primary key columns"
  ft_holder_by_pk(account: String!): ft_holder
  "execute function \"ft_holders\" which returns \"ft_holder\""
  ft_holders(
    "input parameters for function \"ft_holders\""
    args: ft_holders_args!
    "distinct select on columns"
    distinct_on: [ft_holder_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_holder_order_by!]
    "filter the rows returned"
    where: ft_holder_bool_exp
  ): [ft_holder!]!
  "execute function \"ft_holders\" and query aggregates on result of table type \"ft_holder\""
  ft_holders_aggregate(
    "input parameters for function \"ft_holders_aggregate\""
    args: ft_holders_args!
    "distinct select on columns"
    distinct_on: [ft_holder_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_holder_order_by!]
    "filter the rows returned"
    where: ft_holder_bool_exp
  ): ft_holder_aggregate!
  "fetch data from the table: \"ft_meta\""
  ft_meta(
    "distinct select on columns"
    distinct_on: [ft_meta_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_meta_order_by!]
    "filter the rows returned"
    where: ft_meta_bool_exp
  ): [ft_meta!]!
  "fetch data from the table: \"ft_meta\" using primary key columns"
  ft_meta_by_pk(emitted_by_contract_account_id: String!): ft_meta
  "execute function \"ft_token_transfers\" which returns \"ft_transfer\""
  ft_token_transfers(
    "input parameters for function \"ft_token_transfers\""
    args: ft_token_transfers_args!
    "distinct select on columns"
    distinct_on: [ft_transfer_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_transfer_order_by!]
    "filter the rows returned"
    where: ft_transfer_bool_exp
  ): [ft_transfer!]!
  "execute function \"ft_token_transfers\" and query aggregates on result of table type \"ft_transfer\""
  ft_token_transfers_aggregate(
    "input parameters for function \"ft_token_transfers_aggregate\""
    args: ft_token_transfers_args!
    "distinct select on columns"
    distinct_on: [ft_transfer_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_transfer_order_by!]
    "filter the rows returned"
    where: ft_transfer_bool_exp
  ): ft_transfer_aggregate!
  "execute function \"ft_token_transfers_count\" which returns \"ft_transfer_count\""
  ft_token_transfers_count(
    "input parameters for function \"ft_token_transfers_count\""
    args: ft_token_transfers_count_args!
    "distinct select on columns"
    distinct_on: [ft_transfer_count_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_transfer_count_order_by!]
    "filter the rows returned"
    where: ft_transfer_count_bool_exp
  ): [ft_transfer_count!]!
  "fetch data from the table: \"ft_tokens_view\""
  ft_tokens_view(
    "distinct select on columns"
    distinct_on: [ft_tokens_view_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_tokens_view_order_by!]
    "filter the rows returned"
    where: ft_tokens_view_bool_exp
  ): [ft_tokens_view!]!
  "fetch aggregated fields from the table: \"ft_tokens_view\""
  ft_tokens_view_aggregate(
    "distinct select on columns"
    distinct_on: [ft_tokens_view_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_tokens_view_order_by!]
    "filter the rows returned"
    where: ft_tokens_view_bool_exp
  ): ft_tokens_view_aggregate!
  "execute function \"ft_transaction_export\" which returns \"transactions\""
  ft_transaction_export(
    "input parameters for function \"ft_transaction_export\""
    args: ft_transaction_export_args!
    "distinct select on columns"
    distinct_on: [transactions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [transactions_order_by!]
    "filter the rows returned"
    where: transactions_bool_exp
  ): [transactions!]!
  "execute function \"ft_transaction_export\" and query aggregates on result of table type \"transactions\""
  ft_transaction_export_aggregate(
    "input parameters for function \"ft_transaction_export_aggregate\""
    args: ft_transaction_export_args!
    "distinct select on columns"
    distinct_on: [transactions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [transactions_order_by!]
    "filter the rows returned"
    where: transactions_bool_exp
  ): transactions_aggregate!
  "fetch data from the table: \"ft_transfer\""
  ft_transfer(
    "distinct select on columns"
    distinct_on: [ft_transfer_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_transfer_order_by!]
    "filter the rows returned"
    where: ft_transfer_bool_exp
  ): [ft_transfer!]!
  "fetch aggregated fields from the table: \"ft_transfer\""
  ft_transfer_aggregate(
    "distinct select on columns"
    distinct_on: [ft_transfer_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_transfer_order_by!]
    "filter the rows returned"
    where: ft_transfer_bool_exp
  ): ft_transfer_aggregate!
  "fetch data from the table: \"ft_transfer\" using primary key columns"
  ft_transfer_by_pk(index_in_action_receipt: Int!, receipt_id: String!): ft_transfer
  "fetch data from the table: \"ft_transfer_count\""
  ft_transfer_count(
    "distinct select on columns"
    distinct_on: [ft_transfer_count_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_transfer_count_order_by!]
    "filter the rows returned"
    where: ft_transfer_count_bool_exp
  ): [ft_transfer_count!]!
  "fetch data from the table: \"ft_transfer_count\" using primary key columns"
  ft_transfer_count_by_pk(contract: String!): ft_transfer_count
  "execute function \"ft_transfers\" which returns \"ft_transfer\""
  ft_transfers(
    "distinct select on columns"
    distinct_on: [ft_transfer_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_transfer_order_by!]
    "filter the rows returned"
    where: ft_transfer_bool_exp
  ): [ft_transfer!]!
  "execute function \"ft_transfers\" and query aggregates on result of table type \"ft_transfer\""
  ft_transfers_aggregate(
    "distinct select on columns"
    distinct_on: [ft_transfer_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_transfer_order_by!]
    "filter the rows returned"
    where: ft_transfer_bool_exp
  ): ft_transfer_aggregate!
  "fetch data from the table: \"fungible_tokens\""
  fungible_tokens(
    "distinct select on columns"
    distinct_on: [fungible_tokens_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [fungible_tokens_order_by!]
    "filter the rows returned"
    where: fungible_tokens_bool_exp
  ): [fungible_tokens!]!
  "fetch aggregated fields from the table: \"fungible_tokens\""
  fungible_tokens_aggregate(
    "distinct select on columns"
    distinct_on: [fungible_tokens_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [fungible_tokens_order_by!]
    "filter the rows returned"
    where: fungible_tokens_bool_exp
  ): fungible_tokens_aggregate!
  "fetch data from the table: \"legacy_ft_meta\""
  legacy_ft_meta(
    "distinct select on columns"
    distinct_on: [legacy_ft_meta_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [legacy_ft_meta_order_by!]
    "filter the rows returned"
    where: legacy_ft_meta_bool_exp
  ): [legacy_ft_meta!]!
  "fetch aggregated fields from the table: \"legacy_ft_meta\""
  legacy_ft_meta_aggregate(
    "distinct select on columns"
    distinct_on: [legacy_ft_meta_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [legacy_ft_meta_order_by!]
    "filter the rows returned"
    where: legacy_ft_meta_bool_exp
  ): legacy_ft_meta_aggregate!
  "fetch data from the table: \"legacy_ft_meta\" using primary key columns"
  legacy_ft_meta_by_pk(contract: String!): legacy_ft_meta
  "fetch data from the table: \"nft_contract_meta\""
  nft_contract_meta(
    "distinct select on columns"
    distinct_on: [nft_contract_meta_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [nft_contract_meta_order_by!]
    "filter the rows returned"
    where: nft_contract_meta_bool_exp
  ): [nft_contract_meta!]!
  "fetch data from the table: \"nft_contract_meta\" using primary key columns"
  nft_contract_meta_by_pk(emitted_by_contract_account_id: String!): nft_contract_meta
  "fetch data from the table: \"nft_token\""
  nft_token(
    "distinct select on columns"
    distinct_on: [nft_token_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [nft_token_order_by!]
    "filter the rows returned"
    where: nft_token_bool_exp
  ): [nft_token!]!
  "fetch data from the table: \"nft_token\" using primary key columns"
  nft_token_by_pk(emitted_by_contract_account_id: String!, token_id: String!): nft_token
  "fetch data from the table: \"nft_token_holders\""
  nft_token_holders(
    "distinct select on columns"
    distinct_on: [nft_token_holders_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [nft_token_holders_order_by!]
    "filter the rows returned"
    where: nft_token_holders_bool_exp
  ): [nft_token_holders!]!
  "fetch aggregated fields from the table: \"nft_token_holders\""
  nft_token_holders_aggregate(
    "distinct select on columns"
    distinct_on: [nft_token_holders_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [nft_token_holders_order_by!]
    "filter the rows returned"
    where: nft_token_holders_bool_exp
  ): nft_token_holders_aggregate!
  "execute function \"nft_token_inventory\" which returns \"assets__non_fungible_token_events\""
  nft_token_inventory(
    "input parameters for function \"nft_token_inventory\""
    args: nft_token_inventory_args!
    "distinct select on columns"
    distinct_on: [assets__non_fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__non_fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__non_fungible_token_events_bool_exp
  ): [assets__non_fungible_token_events!]!
  "execute function \"nft_token_inventory\" and query aggregates on result of table type \"assets__non_fungible_token_events\""
  nft_token_inventory_aggregate(
    "input parameters for function \"nft_token_inventory_aggregate\""
    args: nft_token_inventory_args!
    "distinct select on columns"
    distinct_on: [assets__non_fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__non_fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__non_fungible_token_events_bool_exp
  ): assets__non_fungible_token_events_aggregate!
  "execute function \"nft_token_inventory_count\" which returns \"tokens_count\""
  nft_token_inventory_count(
    "input parameters for function \"nft_token_inventory_count\""
    args: nft_token_inventory_count_args!
    "distinct select on columns"
    distinct_on: [tokens_count_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [tokens_count_order_by!]
    "filter the rows returned"
    where: tokens_count_bool_exp
  ): [tokens_count!]!
  "execute function \"nft_token_inventory_count\" and query aggregates on result of table type \"tokens_count\""
  nft_token_inventory_count_aggregate(
    "input parameters for function \"nft_token_inventory_count_aggregate\""
    args: nft_token_inventory_count_args!
    "distinct select on columns"
    distinct_on: [tokens_count_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [tokens_count_order_by!]
    "filter the rows returned"
    where: tokens_count_bool_exp
  ): tokens_count_aggregate!
  "An array relationship"
  receipts(
    "distinct select on columns"
    distinct_on: [receipts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [receipts_order_by!]
    "filter the rows returned"
    where: receipts_bool_exp
  ): [receipts!]!
  "An aggregate relationship"
  receipts_aggregate(
    "distinct select on columns"
    distinct_on: [receipts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [receipts_order_by!]
    "filter the rows returned"
    where: receipts_bool_exp
  ): receipts_aggregate!
  "fetch data from the table: \"receipts\" using primary key columns"
  receipts_by_pk(receipt_id: String!): receipts
  "fetch data from the table: \"stats\""
  stats(
    "distinct select on columns"
    distinct_on: [stats_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [stats_order_by!]
    "filter the rows returned"
    where: stats_bool_exp
  ): [stats!]!
  "fetch data from the table: \"stats\" using primary key columns"
  stats_by_pk(id: Int!): stats
  "fetch data from the table: \"tokens_count\""
  tokens_count(
    "distinct select on columns"
    distinct_on: [tokens_count_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [tokens_count_order_by!]
    "filter the rows returned"
    where: tokens_count_bool_exp
  ): [tokens_count!]!
  "fetch aggregated fields from the table: \"tokens_count\""
  tokens_count_aggregate(
    "distinct select on columns"
    distinct_on: [tokens_count_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [tokens_count_order_by!]
    "filter the rows returned"
    where: tokens_count_bool_exp
  ): tokens_count_aggregate!
  "fetch data from the table: \"tokens_count\" using primary key columns"
  tokens_count_by_pk(count: Int!): tokens_count
  "fetch data from the table: \"top_nft_token\""
  top_nft_token(
    "distinct select on columns"
    distinct_on: [top_nft_token_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [top_nft_token_order_by!]
    "filter the rows returned"
    where: top_nft_token_bool_exp
  ): [top_nft_token!]!
  "fetch aggregated fields from the table: \"top_nft_token\""
  top_nft_token_aggregate(
    "distinct select on columns"
    distinct_on: [top_nft_token_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [top_nft_token_order_by!]
    "filter the rows returned"
    where: top_nft_token_bool_exp
  ): top_nft_token_aggregate!
  "fetch data from the table: \"top_nft_token\" using primary key columns"
  top_nft_token_by_pk(contract: String!): top_nft_token
  "execute function \"top_nft_tokens\" which returns \"top_nft_token\""
  top_nft_tokens(
    "distinct select on columns"
    distinct_on: [top_nft_token_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [top_nft_token_order_by!]
    "filter the rows returned"
    where: top_nft_token_bool_exp
  ): [top_nft_token!]!
  "execute function \"top_nft_tokens\" and query aggregates on result of table type \"top_nft_token\""
  top_nft_tokens_aggregate(
    "distinct select on columns"
    distinct_on: [top_nft_token_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [top_nft_token_order_by!]
    "filter the rows returned"
    where: top_nft_token_bool_exp
  ): top_nft_token_aggregate!
  "An array relationship"
  transaction_actions(
    "distinct select on columns"
    distinct_on: [transaction_actions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [transaction_actions_order_by!]
    "filter the rows returned"
    where: transaction_actions_bool_exp
  ): [transaction_actions!]!
  "fetch data from the table: \"transaction_actions\" using primary key columns"
  transaction_actions_by_pk(
    index_in_transaction: Int!
    transaction_hash: String!
  ): transaction_actions
  "An array relationship"
  transactions(
    "distinct select on columns"
    distinct_on: [transactions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [transactions_order_by!]
    "filter the rows returned"
    where: transactions_bool_exp
  ): [transactions!]!
  "An aggregate relationship"
  transactions_aggregate(
    "distinct select on columns"
    distinct_on: [transactions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [transactions_order_by!]
    "filter the rows returned"
    where: transactions_bool_exp
  ): transactions_aggregate!
  "fetch data from the table: \"transactions\" using primary key columns"
  transactions_by_pk(transaction_hash: String!): transactions
}

"columns and relationships of \"receipts\""
type receipts {
  "An array relationship"
  accessKeysByDeletedByReceiptId(
    "distinct select on columns"
    distinct_on: [access_keys_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [access_keys_order_by!]
    "filter the rows returned"
    where: access_keys_bool_exp
  ): [access_keys!]!
  "An aggregate relationship"
  accessKeysByDeletedByReceiptId_aggregate(
    "distinct select on columns"
    distinct_on: [access_keys_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [access_keys_order_by!]
    "filter the rows returned"
    where: access_keys_bool_exp
  ): access_keys_aggregate!
  "An array relationship"
  access_keys(
    "distinct select on columns"
    distinct_on: [access_keys_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [access_keys_order_by!]
    "filter the rows returned"
    where: access_keys_bool_exp
  ): [access_keys!]!
  "An aggregate relationship"
  access_keys_aggregate(
    "distinct select on columns"
    distinct_on: [access_keys_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [access_keys_order_by!]
    "filter the rows returned"
    where: access_keys_bool_exp
  ): access_keys_aggregate!
  "An array relationship"
  accounts(
    "distinct select on columns"
    distinct_on: [accounts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [accounts_order_by!]
    "filter the rows returned"
    where: accounts_bool_exp
  ): [accounts!]!
  "An array relationship"
  accountsByDeletedByReceiptId(
    "distinct select on columns"
    distinct_on: [accounts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [accounts_order_by!]
    "filter the rows returned"
    where: accounts_bool_exp
  ): [accounts!]!
  "An aggregate relationship"
  accountsByDeletedByReceiptId_aggregate(
    "distinct select on columns"
    distinct_on: [accounts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [accounts_order_by!]
    "filter the rows returned"
    where: accounts_bool_exp
  ): accounts_aggregate!
  "An aggregate relationship"
  accounts_aggregate(
    "distinct select on columns"
    distinct_on: [accounts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [accounts_order_by!]
    "filter the rows returned"
    where: accounts_bool_exp
  ): accounts_aggregate!
  "An array relationship"
  action_receipt_actions(
    "distinct select on columns"
    distinct_on: [action_receipt_actions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [action_receipt_actions_order_by!]
    "filter the rows returned"
    where: action_receipt_actions_bool_exp
  ): [action_receipt_actions!]!
  "An aggregate relationship"
  action_receipt_actions_aggregate(
    "distinct select on columns"
    distinct_on: [action_receipt_actions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [action_receipt_actions_order_by!]
    "filter the rows returned"
    where: action_receipt_actions_bool_exp
  ): action_receipt_actions_aggregate!
  "An array relationship"
  assets__fungible_token_events(
    "distinct select on columns"
    distinct_on: [assets__fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__fungible_token_events_bool_exp
  ): [assets__fungible_token_events!]!
  "An aggregate relationship"
  assets__fungible_token_events_aggregate(
    "distinct select on columns"
    distinct_on: [assets__fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__fungible_token_events_bool_exp
  ): assets__fungible_token_events_aggregate!
  "An array relationship"
  assets__non_fungible_token_events(
    "distinct select on columns"
    distinct_on: [assets__non_fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__non_fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__non_fungible_token_events_bool_exp
  ): [assets__non_fungible_token_events!]!
  "An aggregate relationship"
  assets__non_fungible_token_events_aggregate(
    "distinct select on columns"
    distinct_on: [assets__non_fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__non_fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__non_fungible_token_events_bool_exp
  ): assets__non_fungible_token_events_aggregate!
  "An object relationship"
  block: blocks!
  "An object relationship"
  chunk: chunks!
  "An object relationship"
  execution_outcome: execution_outcomes
  included_in_block_hash: String!
  included_in_block_timestamp: numeric!
  included_in_chunk_hash: String!
  index_in_chunk: Int!
  originated_from_transaction_hash: String!
  predecessor_account_id: String!
  receipt_id: String!
  receipt_kind: receipt_kind!
  receiver_account_id: String!
  "An object relationship"
  transaction: transactions!
}

"aggregated selection of \"receipts\""
type receipts_aggregate {
  aggregate: receipts_aggregate_fields
  nodes: [receipts!]!
}

"aggregate fields of \"receipts\""
type receipts_aggregate_fields {
  avg: receipts_avg_fields
  count(columns: [receipts_select_column!], distinct: Boolean): Int!
  max: receipts_max_fields
  min: receipts_min_fields
  stddev: receipts_stddev_fields
  stddev_pop: receipts_stddev_pop_fields
  stddev_samp: receipts_stddev_samp_fields
  sum: receipts_sum_fields
  var_pop: receipts_var_pop_fields
  var_samp: receipts_var_samp_fields
  variance: receipts_variance_fields
}

"aggregate avg on columns"
type receipts_avg_fields {
  included_in_block_timestamp: Float
  index_in_chunk: Float
}

"aggregate max on columns"
type receipts_max_fields {
  included_in_block_hash: String
  included_in_block_timestamp: numeric
  included_in_chunk_hash: String
  index_in_chunk: Int
  originated_from_transaction_hash: String
  predecessor_account_id: String
  receipt_id: String
  receipt_kind: receipt_kind
  receiver_account_id: String
}

"aggregate min on columns"
type receipts_min_fields {
  included_in_block_hash: String
  included_in_block_timestamp: numeric
  included_in_chunk_hash: String
  index_in_chunk: Int
  originated_from_transaction_hash: String
  predecessor_account_id: String
  receipt_id: String
  receipt_kind: receipt_kind
  receiver_account_id: String
}

"aggregate stddev on columns"
type receipts_stddev_fields {
  included_in_block_timestamp: Float
  index_in_chunk: Float
}

"aggregate stddev_pop on columns"
type receipts_stddev_pop_fields {
  included_in_block_timestamp: Float
  index_in_chunk: Float
}

"aggregate stddev_samp on columns"
type receipts_stddev_samp_fields {
  included_in_block_timestamp: Float
  index_in_chunk: Float
}

"aggregate sum on columns"
type receipts_sum_fields {
  included_in_block_timestamp: numeric
  index_in_chunk: Int
}

"aggregate var_pop on columns"
type receipts_var_pop_fields {
  included_in_block_timestamp: Float
  index_in_chunk: Float
}

"aggregate var_samp on columns"
type receipts_var_samp_fields {
  included_in_block_timestamp: Float
  index_in_chunk: Float
}

"aggregate variance on columns"
type receipts_variance_fields {
  included_in_block_timestamp: Float
  index_in_chunk: Float
}

"columns and relationships of \"stats\""
type stats {
  avg_block_time: numeric
  block: bigint
  change_24: numeric
  gas_price: bigint
  high_24h: numeric
  high_all: numeric
  id: Int!
  low_24h: numeric
  low_all: numeric
  market_cap: numeric
  near_btc_price: numeric
  near_price: numeric
  nodes: Int
  nodes_online: Int
  total_supply: String
  total_txns: bigint
  volume: numeric
}

type subscription_root {
  "An array relationship"
  access_keys(
    "distinct select on columns"
    distinct_on: [access_keys_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [access_keys_order_by!]
    "filter the rows returned"
    where: access_keys_bool_exp
  ): [access_keys!]!
  "An aggregate relationship"
  access_keys_aggregate(
    "distinct select on columns"
    distinct_on: [access_keys_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [access_keys_order_by!]
    "filter the rows returned"
    where: access_keys_bool_exp
  ): access_keys_aggregate!
  "fetch data from the table: \"access_keys\" using primary key columns"
  access_keys_by_pk(account_id: String!, public_key: String!): access_keys
  "An array relationship"
  accounts(
    "distinct select on columns"
    distinct_on: [accounts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [accounts_order_by!]
    "filter the rows returned"
    where: accounts_bool_exp
  ): [accounts!]!
  "An aggregate relationship"
  accounts_aggregate(
    "distinct select on columns"
    distinct_on: [accounts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [accounts_order_by!]
    "filter the rows returned"
    where: accounts_bool_exp
  ): accounts_aggregate!
  "fetch data from the table: \"accounts\" using primary key columns"
  accounts_by_pk(id: bigint!): accounts
  "fetch data from the table: \"accounts_label\""
  accounts_label(
    "distinct select on columns"
    distinct_on: [accounts_label_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [accounts_label_order_by!]
    "filter the rows returned"
    where: accounts_label_bool_exp
  ): [accounts_label!]!
  "fetch data from the table: \"accounts_label\" using primary key columns"
  accounts_label_by_pk(id: bigint!): accounts_label
  "An array relationship"
  action_receipt_actions(
    "distinct select on columns"
    distinct_on: [action_receipt_actions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [action_receipt_actions_order_by!]
    "filter the rows returned"
    where: action_receipt_actions_bool_exp
  ): [action_receipt_actions!]!
  "An aggregate relationship"
  action_receipt_actions_aggregate(
    "distinct select on columns"
    distinct_on: [action_receipt_actions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [action_receipt_actions_order_by!]
    "filter the rows returned"
    where: action_receipt_actions_bool_exp
  ): action_receipt_actions_aggregate!
  "fetch data from the table: \"action_receipt_actions\" using primary key columns"
  action_receipt_actions_by_pk(
    index_in_action_receipt: Int!
    receipt_id: String!
  ): action_receipt_actions
  "An array relationship"
  assets__fungible_token_events(
    "distinct select on columns"
    distinct_on: [assets__fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__fungible_token_events_bool_exp
  ): [assets__fungible_token_events!]!
  "An aggregate relationship"
  assets__fungible_token_events_aggregate(
    "distinct select on columns"
    distinct_on: [assets__fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__fungible_token_events_bool_exp
  ): assets__fungible_token_events_aggregate!
  "fetch data from the table: \"assets__fungible_token_events\" using primary key columns"
  assets__fungible_token_events_by_pk(
    amount: String!
    emitted_at_block_timestamp: numeric!
    emitted_by_contract_account_id: String!
    emitted_for_receipt_id: String!
    emitted_in_shard_id: numeric!
    emitted_index_of_event_entry_in_shard: Int!
    event_kind: ft_event_kind!
    event_memo: String!
    token_new_owner_account_id: String!
    token_old_owner_account_id: String!
  ): assets__fungible_token_events
  "An array relationship"
  assets__non_fungible_token_events(
    "distinct select on columns"
    distinct_on: [assets__non_fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__non_fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__non_fungible_token_events_bool_exp
  ): [assets__non_fungible_token_events!]!
  "An aggregate relationship"
  assets__non_fungible_token_events_aggregate(
    "distinct select on columns"
    distinct_on: [assets__non_fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__non_fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__non_fungible_token_events_bool_exp
  ): assets__non_fungible_token_events_aggregate!
  "fetch data from the table: \"assets__non_fungible_token_events\" using primary key columns"
  assets__non_fungible_token_events_by_pk(
    emitted_at_block_timestamp: numeric!
    emitted_by_contract_account_id: String!
    emitted_for_receipt_id: String!
    emitted_in_shard_id: numeric!
    emitted_index_of_event_entry_in_shard: Int!
    event_kind: nft_event_kind!
    event_memo: String!
    token_authorized_account_id: String!
    token_id: String!
    token_new_owner_account_id: String!
    token_old_owner_account_id: String!
  ): assets__non_fungible_token_events
  "fetch data from the table: \"blocks\""
  blocks(
    "distinct select on columns"
    distinct_on: [blocks_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [blocks_order_by!]
    "filter the rows returned"
    where: blocks_bool_exp
  ): [blocks!]!
  "fetch aggregated fields from the table: \"blocks\""
  blocks_aggregate(
    "distinct select on columns"
    distinct_on: [blocks_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [blocks_order_by!]
    "filter the rows returned"
    where: blocks_bool_exp
  ): blocks_aggregate!
  "fetch data from the table: \"blocks\" using primary key columns"
  blocks_by_pk(block_hash: String!): blocks
  "An array relationship"
  chunks(
    "distinct select on columns"
    distinct_on: [chunks_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [chunks_order_by!]
    "filter the rows returned"
    where: chunks_bool_exp
  ): [chunks!]!
  "An aggregate relationship"
  chunks_aggregate(
    "distinct select on columns"
    distinct_on: [chunks_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [chunks_order_by!]
    "filter the rows returned"
    where: chunks_bool_exp
  ): chunks_aggregate!
  "fetch data from the table: \"chunks\" using primary key columns"
  chunks_by_pk(chunk_hash: String!): chunks
  "fetch data from the table: \"daily_stats\""
  daily_stats(
    "distinct select on columns"
    distinct_on: [daily_stats_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [daily_stats_order_by!]
    "filter the rows returned"
    where: daily_stats_bool_exp
  ): [daily_stats!]!
  "fetch data from the table: \"daily_stats\" using primary key columns"
  daily_stats_by_pk(id: bigint!): daily_stats
  "An array relationship"
  execution_outcomes(
    "distinct select on columns"
    distinct_on: [execution_outcomes_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [execution_outcomes_order_by!]
    "filter the rows returned"
    where: execution_outcomes_bool_exp
  ): [execution_outcomes!]!
  "fetch data from the table: \"execution_outcomes\" using primary key columns"
  execution_outcomes_by_pk(receipt_id: String!): execution_outcomes
  "fetch data from the table: \"ft_balance\""
  ft_balance(
    "distinct select on columns"
    distinct_on: [ft_balance_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_balance_order_by!]
    "filter the rows returned"
    where: ft_balance_bool_exp
  ): [ft_balance!]!
  "execute function \"ft_balances\" which returns \"ft_balance\""
  ft_balances(
    "input parameters for function \"ft_balances\""
    args: ft_balances_args!
    "distinct select on columns"
    distinct_on: [ft_balance_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_balance_order_by!]
    "filter the rows returned"
    where: ft_balance_bool_exp
  ): [ft_balance!]!
  "fetch data from the table: \"ft_holder\""
  ft_holder(
    "distinct select on columns"
    distinct_on: [ft_holder_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_holder_order_by!]
    "filter the rows returned"
    where: ft_holder_bool_exp
  ): [ft_holder!]!
  "fetch aggregated fields from the table: \"ft_holder\""
  ft_holder_aggregate(
    "distinct select on columns"
    distinct_on: [ft_holder_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_holder_order_by!]
    "filter the rows returned"
    where: ft_holder_bool_exp
  ): ft_holder_aggregate!
  "fetch data from the table: \"ft_holder\" using primary key columns"
  ft_holder_by_pk(account: String!): ft_holder
  "execute function \"ft_holders\" which returns \"ft_holder\""
  ft_holders(
    "input parameters for function \"ft_holders\""
    args: ft_holders_args!
    "distinct select on columns"
    distinct_on: [ft_holder_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_holder_order_by!]
    "filter the rows returned"
    where: ft_holder_bool_exp
  ): [ft_holder!]!
  "execute function \"ft_holders\" and query aggregates on result of table type \"ft_holder\""
  ft_holders_aggregate(
    "input parameters for function \"ft_holders_aggregate\""
    args: ft_holders_args!
    "distinct select on columns"
    distinct_on: [ft_holder_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_holder_order_by!]
    "filter the rows returned"
    where: ft_holder_bool_exp
  ): ft_holder_aggregate!
  "fetch data from the table: \"ft_meta\""
  ft_meta(
    "distinct select on columns"
    distinct_on: [ft_meta_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_meta_order_by!]
    "filter the rows returned"
    where: ft_meta_bool_exp
  ): [ft_meta!]!
  "fetch data from the table: \"ft_meta\" using primary key columns"
  ft_meta_by_pk(emitted_by_contract_account_id: String!): ft_meta
  "execute function \"ft_token_transfers\" which returns \"ft_transfer\""
  ft_token_transfers(
    "input parameters for function \"ft_token_transfers\""
    args: ft_token_transfers_args!
    "distinct select on columns"
    distinct_on: [ft_transfer_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_transfer_order_by!]
    "filter the rows returned"
    where: ft_transfer_bool_exp
  ): [ft_transfer!]!
  "execute function \"ft_token_transfers\" and query aggregates on result of table type \"ft_transfer\""
  ft_token_transfers_aggregate(
    "input parameters for function \"ft_token_transfers_aggregate\""
    args: ft_token_transfers_args!
    "distinct select on columns"
    distinct_on: [ft_transfer_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_transfer_order_by!]
    "filter the rows returned"
    where: ft_transfer_bool_exp
  ): ft_transfer_aggregate!
  "execute function \"ft_token_transfers_count\" which returns \"ft_transfer_count\""
  ft_token_transfers_count(
    "input parameters for function \"ft_token_transfers_count\""
    args: ft_token_transfers_count_args!
    "distinct select on columns"
    distinct_on: [ft_transfer_count_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_transfer_count_order_by!]
    "filter the rows returned"
    where: ft_transfer_count_bool_exp
  ): [ft_transfer_count!]!
  "fetch data from the table: \"ft_tokens_view\""
  ft_tokens_view(
    "distinct select on columns"
    distinct_on: [ft_tokens_view_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_tokens_view_order_by!]
    "filter the rows returned"
    where: ft_tokens_view_bool_exp
  ): [ft_tokens_view!]!
  "fetch aggregated fields from the table: \"ft_tokens_view\""
  ft_tokens_view_aggregate(
    "distinct select on columns"
    distinct_on: [ft_tokens_view_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_tokens_view_order_by!]
    "filter the rows returned"
    where: ft_tokens_view_bool_exp
  ): ft_tokens_view_aggregate!
  "execute function \"ft_transaction_export\" which returns \"transactions\""
  ft_transaction_export(
    "input parameters for function \"ft_transaction_export\""
    args: ft_transaction_export_args!
    "distinct select on columns"
    distinct_on: [transactions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [transactions_order_by!]
    "filter the rows returned"
    where: transactions_bool_exp
  ): [transactions!]!
  "execute function \"ft_transaction_export\" and query aggregates on result of table type \"transactions\""
  ft_transaction_export_aggregate(
    "input parameters for function \"ft_transaction_export_aggregate\""
    args: ft_transaction_export_args!
    "distinct select on columns"
    distinct_on: [transactions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [transactions_order_by!]
    "filter the rows returned"
    where: transactions_bool_exp
  ): transactions_aggregate!
  "fetch data from the table: \"ft_transfer\""
  ft_transfer(
    "distinct select on columns"
    distinct_on: [ft_transfer_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_transfer_order_by!]
    "filter the rows returned"
    where: ft_transfer_bool_exp
  ): [ft_transfer!]!
  "fetch aggregated fields from the table: \"ft_transfer\""
  ft_transfer_aggregate(
    "distinct select on columns"
    distinct_on: [ft_transfer_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_transfer_order_by!]
    "filter the rows returned"
    where: ft_transfer_bool_exp
  ): ft_transfer_aggregate!
  "fetch data from the table: \"ft_transfer\" using primary key columns"
  ft_transfer_by_pk(index_in_action_receipt: Int!, receipt_id: String!): ft_transfer
  "fetch data from the table: \"ft_transfer_count\""
  ft_transfer_count(
    "distinct select on columns"
    distinct_on: [ft_transfer_count_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_transfer_count_order_by!]
    "filter the rows returned"
    where: ft_transfer_count_bool_exp
  ): [ft_transfer_count!]!
  "fetch data from the table: \"ft_transfer_count\" using primary key columns"
  ft_transfer_count_by_pk(contract: String!): ft_transfer_count
  "execute function \"ft_transfers\" which returns \"ft_transfer\""
  ft_transfers(
    "distinct select on columns"
    distinct_on: [ft_transfer_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_transfer_order_by!]
    "filter the rows returned"
    where: ft_transfer_bool_exp
  ): [ft_transfer!]!
  "execute function \"ft_transfers\" and query aggregates on result of table type \"ft_transfer\""
  ft_transfers_aggregate(
    "distinct select on columns"
    distinct_on: [ft_transfer_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_transfer_order_by!]
    "filter the rows returned"
    where: ft_transfer_bool_exp
  ): ft_transfer_aggregate!
  "fetch data from the table: \"fungible_tokens\""
  fungible_tokens(
    "distinct select on columns"
    distinct_on: [fungible_tokens_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [fungible_tokens_order_by!]
    "filter the rows returned"
    where: fungible_tokens_bool_exp
  ): [fungible_tokens!]!
  "fetch aggregated fields from the table: \"fungible_tokens\""
  fungible_tokens_aggregate(
    "distinct select on columns"
    distinct_on: [fungible_tokens_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [fungible_tokens_order_by!]
    "filter the rows returned"
    where: fungible_tokens_bool_exp
  ): fungible_tokens_aggregate!
  "fetch data from the table: \"legacy_ft_meta\""
  legacy_ft_meta(
    "distinct select on columns"
    distinct_on: [legacy_ft_meta_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [legacy_ft_meta_order_by!]
    "filter the rows returned"
    where: legacy_ft_meta_bool_exp
  ): [legacy_ft_meta!]!
  "fetch aggregated fields from the table: \"legacy_ft_meta\""
  legacy_ft_meta_aggregate(
    "distinct select on columns"
    distinct_on: [legacy_ft_meta_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [legacy_ft_meta_order_by!]
    "filter the rows returned"
    where: legacy_ft_meta_bool_exp
  ): legacy_ft_meta_aggregate!
  "fetch data from the table: \"legacy_ft_meta\" using primary key columns"
  legacy_ft_meta_by_pk(contract: String!): legacy_ft_meta
  "fetch data from the table: \"nft_contract_meta\""
  nft_contract_meta(
    "distinct select on columns"
    distinct_on: [nft_contract_meta_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [nft_contract_meta_order_by!]
    "filter the rows returned"
    where: nft_contract_meta_bool_exp
  ): [nft_contract_meta!]!
  "fetch data from the table: \"nft_contract_meta\" using primary key columns"
  nft_contract_meta_by_pk(emitted_by_contract_account_id: String!): nft_contract_meta
  "fetch data from the table: \"nft_token\""
  nft_token(
    "distinct select on columns"
    distinct_on: [nft_token_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [nft_token_order_by!]
    "filter the rows returned"
    where: nft_token_bool_exp
  ): [nft_token!]!
  "fetch data from the table: \"nft_token\" using primary key columns"
  nft_token_by_pk(emitted_by_contract_account_id: String!, token_id: String!): nft_token
  "fetch data from the table: \"nft_token_holders\""
  nft_token_holders(
    "distinct select on columns"
    distinct_on: [nft_token_holders_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [nft_token_holders_order_by!]
    "filter the rows returned"
    where: nft_token_holders_bool_exp
  ): [nft_token_holders!]!
  "fetch aggregated fields from the table: \"nft_token_holders\""
  nft_token_holders_aggregate(
    "distinct select on columns"
    distinct_on: [nft_token_holders_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [nft_token_holders_order_by!]
    "filter the rows returned"
    where: nft_token_holders_bool_exp
  ): nft_token_holders_aggregate!
  "execute function \"nft_token_inventory\" which returns \"assets__non_fungible_token_events\""
  nft_token_inventory(
    "input parameters for function \"nft_token_inventory\""
    args: nft_token_inventory_args!
    "distinct select on columns"
    distinct_on: [assets__non_fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__non_fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__non_fungible_token_events_bool_exp
  ): [assets__non_fungible_token_events!]!
  "execute function \"nft_token_inventory\" and query aggregates on result of table type \"assets__non_fungible_token_events\""
  nft_token_inventory_aggregate(
    "input parameters for function \"nft_token_inventory_aggregate\""
    args: nft_token_inventory_args!
    "distinct select on columns"
    distinct_on: [assets__non_fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__non_fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__non_fungible_token_events_bool_exp
  ): assets__non_fungible_token_events_aggregate!
  "execute function \"nft_token_inventory_count\" which returns \"tokens_count\""
  nft_token_inventory_count(
    "input parameters for function \"nft_token_inventory_count\""
    args: nft_token_inventory_count_args!
    "distinct select on columns"
    distinct_on: [tokens_count_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [tokens_count_order_by!]
    "filter the rows returned"
    where: tokens_count_bool_exp
  ): [tokens_count!]!
  "execute function \"nft_token_inventory_count\" and query aggregates on result of table type \"tokens_count\""
  nft_token_inventory_count_aggregate(
    "input parameters for function \"nft_token_inventory_count_aggregate\""
    args: nft_token_inventory_count_args!
    "distinct select on columns"
    distinct_on: [tokens_count_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [tokens_count_order_by!]
    "filter the rows returned"
    where: tokens_count_bool_exp
  ): tokens_count_aggregate!
  "An array relationship"
  receipts(
    "distinct select on columns"
    distinct_on: [receipts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [receipts_order_by!]
    "filter the rows returned"
    where: receipts_bool_exp
  ): [receipts!]!
  "An aggregate relationship"
  receipts_aggregate(
    "distinct select on columns"
    distinct_on: [receipts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [receipts_order_by!]
    "filter the rows returned"
    where: receipts_bool_exp
  ): receipts_aggregate!
  "fetch data from the table: \"receipts\" using primary key columns"
  receipts_by_pk(receipt_id: String!): receipts
  "fetch data from the table: \"stats\""
  stats(
    "distinct select on columns"
    distinct_on: [stats_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [stats_order_by!]
    "filter the rows returned"
    where: stats_bool_exp
  ): [stats!]!
  "fetch data from the table: \"stats\" using primary key columns"
  stats_by_pk(id: Int!): stats
  "fetch data from the table: \"tokens_count\""
  tokens_count(
    "distinct select on columns"
    distinct_on: [tokens_count_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [tokens_count_order_by!]
    "filter the rows returned"
    where: tokens_count_bool_exp
  ): [tokens_count!]!
  "fetch aggregated fields from the table: \"tokens_count\""
  tokens_count_aggregate(
    "distinct select on columns"
    distinct_on: [tokens_count_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [tokens_count_order_by!]
    "filter the rows returned"
    where: tokens_count_bool_exp
  ): tokens_count_aggregate!
  "fetch data from the table: \"tokens_count\" using primary key columns"
  tokens_count_by_pk(count: Int!): tokens_count
  "fetch data from the table: \"top_nft_token\""
  top_nft_token(
    "distinct select on columns"
    distinct_on: [top_nft_token_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [top_nft_token_order_by!]
    "filter the rows returned"
    where: top_nft_token_bool_exp
  ): [top_nft_token!]!
  "fetch aggregated fields from the table: \"top_nft_token\""
  top_nft_token_aggregate(
    "distinct select on columns"
    distinct_on: [top_nft_token_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [top_nft_token_order_by!]
    "filter the rows returned"
    where: top_nft_token_bool_exp
  ): top_nft_token_aggregate!
  "fetch data from the table: \"top_nft_token\" using primary key columns"
  top_nft_token_by_pk(contract: String!): top_nft_token
  "execute function \"top_nft_tokens\" which returns \"top_nft_token\""
  top_nft_tokens(
    "distinct select on columns"
    distinct_on: [top_nft_token_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [top_nft_token_order_by!]
    "filter the rows returned"
    where: top_nft_token_bool_exp
  ): [top_nft_token!]!
  "execute function \"top_nft_tokens\" and query aggregates on result of table type \"top_nft_token\""
  top_nft_tokens_aggregate(
    "distinct select on columns"
    distinct_on: [top_nft_token_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [top_nft_token_order_by!]
    "filter the rows returned"
    where: top_nft_token_bool_exp
  ): top_nft_token_aggregate!
  "An array relationship"
  transaction_actions(
    "distinct select on columns"
    distinct_on: [transaction_actions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [transaction_actions_order_by!]
    "filter the rows returned"
    where: transaction_actions_bool_exp
  ): [transaction_actions!]!
  "fetch data from the table: \"transaction_actions\" using primary key columns"
  transaction_actions_by_pk(
    index_in_transaction: Int!
    transaction_hash: String!
  ): transaction_actions
  "An array relationship"
  transactions(
    "distinct select on columns"
    distinct_on: [transactions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [transactions_order_by!]
    "filter the rows returned"
    where: transactions_bool_exp
  ): [transactions!]!
  "An aggregate relationship"
  transactions_aggregate(
    "distinct select on columns"
    distinct_on: [transactions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [transactions_order_by!]
    "filter the rows returned"
    where: transactions_bool_exp
  ): transactions_aggregate!
  "fetch data from the table: \"transactions\" using primary key columns"
  transactions_by_pk(transaction_hash: String!): transactions
}

"columns and relationships of \"tokens_count\""
type tokens_count {
  count: Int!
}

type tokens_count_aggregate {
  aggregate: tokens_count_aggregate_fields
  nodes: [tokens_count!]!
}

"aggregate fields of \"tokens_count\""
type tokens_count_aggregate_fields {
  avg: tokens_count_avg_fields
  count(columns: [tokens_count_select_column!], distinct: Boolean): Int!
  max: tokens_count_max_fields
  min: tokens_count_min_fields
  stddev: tokens_count_stddev_fields
  stddev_pop: tokens_count_stddev_pop_fields
  stddev_samp: tokens_count_stddev_samp_fields
  sum: tokens_count_sum_fields
  var_pop: tokens_count_var_pop_fields
  var_samp: tokens_count_var_samp_fields
  variance: tokens_count_variance_fields
}

"aggregate avg on columns"
type tokens_count_avg_fields {
  count: Float
}

"aggregate max on columns"
type tokens_count_max_fields {
  count: Int
}

"aggregate min on columns"
type tokens_count_min_fields {
  count: Int
}

"aggregate stddev on columns"
type tokens_count_stddev_fields {
  count: Float
}

"aggregate stddev_pop on columns"
type tokens_count_stddev_pop_fields {
  count: Float
}

"aggregate stddev_samp on columns"
type tokens_count_stddev_samp_fields {
  count: Float
}

"aggregate sum on columns"
type tokens_count_sum_fields {
  count: Int
}

"aggregate var_pop on columns"
type tokens_count_var_pop_fields {
  count: Float
}

"aggregate var_samp on columns"
type tokens_count_var_samp_fields {
  count: Float
}

"aggregate variance on columns"
type tokens_count_variance_fields {
  count: Float
}

"columns and relationships of \"top_nft_token\""
type top_nft_token {
  contract: String!
  "An object relationship"
  meta: nft_contract_meta
  transfers_3days: Int!
  transfers_day: Int!
}

"aggregated selection of \"top_nft_token\""
type top_nft_token_aggregate {
  aggregate: top_nft_token_aggregate_fields
  nodes: [top_nft_token!]!
}

"aggregate fields of \"top_nft_token\""
type top_nft_token_aggregate_fields {
  avg: top_nft_token_avg_fields
  count(columns: [top_nft_token_select_column!], distinct: Boolean): Int!
  max: top_nft_token_max_fields
  min: top_nft_token_min_fields
  stddev: top_nft_token_stddev_fields
  stddev_pop: top_nft_token_stddev_pop_fields
  stddev_samp: top_nft_token_stddev_samp_fields
  sum: top_nft_token_sum_fields
  var_pop: top_nft_token_var_pop_fields
  var_samp: top_nft_token_var_samp_fields
  variance: top_nft_token_variance_fields
}

"aggregate avg on columns"
type top_nft_token_avg_fields {
  transfers_3days: Float
  transfers_day: Float
}

"aggregate max on columns"
type top_nft_token_max_fields {
  contract: String
  transfers_3days: Int
  transfers_day: Int
}

"aggregate min on columns"
type top_nft_token_min_fields {
  contract: String
  transfers_3days: Int
  transfers_day: Int
}

"aggregate stddev on columns"
type top_nft_token_stddev_fields {
  transfers_3days: Float
  transfers_day: Float
}

"aggregate stddev_pop on columns"
type top_nft_token_stddev_pop_fields {
  transfers_3days: Float
  transfers_day: Float
}

"aggregate stddev_samp on columns"
type top_nft_token_stddev_samp_fields {
  transfers_3days: Float
  transfers_day: Float
}

"aggregate sum on columns"
type top_nft_token_sum_fields {
  transfers_3days: Int
  transfers_day: Int
}

"aggregate var_pop on columns"
type top_nft_token_var_pop_fields {
  transfers_3days: Float
  transfers_day: Float
}

"aggregate var_samp on columns"
type top_nft_token_var_samp_fields {
  transfers_3days: Float
  transfers_day: Float
}

"aggregate variance on columns"
type top_nft_token_variance_fields {
  transfers_3days: Float
  transfers_day: Float
}

"columns and relationships of \"transaction_actions\""
type transaction_actions {
  action_kind: action_kind!
  args("JSON select path" path: String): jsonb!
  index_in_transaction: Int!
  "An object relationship"
  transaction: transactions!
  transaction_hash: String!
}

"columns and relationships of \"transactions\""
type transactions {
  "An object relationship"
  block: blocks!
  block_timestamp: numeric!
  "An object relationship"
  chunk: chunks!
  converted_into_receipt_id: String!
  included_in_block_hash: String!
  included_in_chunk_hash: String!
  index_in_chunk: Int!
  nonce: numeric!
  receipt_conversion_gas_burnt: numeric
  receipt_conversion_tokens_burnt: numeric
  "An array relationship"
  receipts(
    "distinct select on columns"
    distinct_on: [receipts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [receipts_order_by!]
    "filter the rows returned"
    where: receipts_bool_exp
  ): [receipts!]!
  "An aggregate relationship"
  receipts_aggregate(
    "distinct select on columns"
    distinct_on: [receipts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [receipts_order_by!]
    "filter the rows returned"
    where: receipts_bool_exp
  ): receipts_aggregate!
  receiver_account_id: String!
  signature: String!
  signer_account_id: String!
  signer_public_key: String!
  status: execution_outcome_status!
  "An array relationship"
  transaction_actions(
    "distinct select on columns"
    distinct_on: [transaction_actions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [transaction_actions_order_by!]
    "filter the rows returned"
    where: transaction_actions_bool_exp
  ): [transaction_actions!]!
  transaction_hash: String!
}

"aggregated selection of \"transactions\""
type transactions_aggregate {
  aggregate: transactions_aggregate_fields
  nodes: [transactions!]!
}

"aggregate fields of \"transactions\""
type transactions_aggregate_fields {
  avg: transactions_avg_fields
  count(columns: [transactions_select_column!], distinct: Boolean): Int!
  max: transactions_max_fields
  min: transactions_min_fields
  stddev: transactions_stddev_fields
  stddev_pop: transactions_stddev_pop_fields
  stddev_samp: transactions_stddev_samp_fields
  sum: transactions_sum_fields
  var_pop: transactions_var_pop_fields
  var_samp: transactions_var_samp_fields
  variance: transactions_variance_fields
}

"aggregate avg on columns"
type transactions_avg_fields {
  block_timestamp: Float
  index_in_chunk: Float
  nonce: Float
  receipt_conversion_gas_burnt: Float
  receipt_conversion_tokens_burnt: Float
}

"aggregate max on columns"
type transactions_max_fields {
  block_timestamp: numeric
  converted_into_receipt_id: String
  included_in_block_hash: String
  included_in_chunk_hash: String
  index_in_chunk: Int
  nonce: numeric
  receipt_conversion_gas_burnt: numeric
  receipt_conversion_tokens_burnt: numeric
  receiver_account_id: String
  signature: String
  signer_account_id: String
  signer_public_key: String
  status: execution_outcome_status
  transaction_hash: String
}

"aggregate min on columns"
type transactions_min_fields {
  block_timestamp: numeric
  converted_into_receipt_id: String
  included_in_block_hash: String
  included_in_chunk_hash: String
  index_in_chunk: Int
  nonce: numeric
  receipt_conversion_gas_burnt: numeric
  receipt_conversion_tokens_burnt: numeric
  receiver_account_id: String
  signature: String
  signer_account_id: String
  signer_public_key: String
  status: execution_outcome_status
  transaction_hash: String
}

"aggregate stddev on columns"
type transactions_stddev_fields {
  block_timestamp: Float
  index_in_chunk: Float
  nonce: Float
  receipt_conversion_gas_burnt: Float
  receipt_conversion_tokens_burnt: Float
}

"aggregate stddev_pop on columns"
type transactions_stddev_pop_fields {
  block_timestamp: Float
  index_in_chunk: Float
  nonce: Float
  receipt_conversion_gas_burnt: Float
  receipt_conversion_tokens_burnt: Float
}

"aggregate stddev_samp on columns"
type transactions_stddev_samp_fields {
  block_timestamp: Float
  index_in_chunk: Float
  nonce: Float
  receipt_conversion_gas_burnt: Float
  receipt_conversion_tokens_burnt: Float
}

"aggregate sum on columns"
type transactions_sum_fields {
  block_timestamp: numeric
  index_in_chunk: Int
  nonce: numeric
  receipt_conversion_gas_burnt: numeric
  receipt_conversion_tokens_burnt: numeric
}

"aggregate var_pop on columns"
type transactions_var_pop_fields {
  block_timestamp: Float
  index_in_chunk: Float
  nonce: Float
  receipt_conversion_gas_burnt: Float
  receipt_conversion_tokens_burnt: Float
}

"aggregate var_samp on columns"
type transactions_var_samp_fields {
  block_timestamp: Float
  index_in_chunk: Float
  nonce: Float
  receipt_conversion_gas_burnt: Float
  receipt_conversion_tokens_burnt: Float
}

"aggregate variance on columns"
type transactions_variance_fields {
  block_timestamp: Float
  index_in_chunk: Float
  nonce: Float
  receipt_conversion_gas_burnt: Float
  receipt_conversion_tokens_burnt: Float
}

"select columns of table \"access_keys\""
enum access_keys_select_column {
  "column name"
  account_id
  "column name"
  created_by_receipt_id
  "column name"
  deleted_by_receipt_id
  "column name"
  last_update_block_height
  "column name"
  permission_kind
  "column name"
  public_key
}

"select columns of table \"accounts_label\""
enum accounts_label_select_column {
  "column name"
  account_id
  "column name"
  blog
  "column name"
  id
  "column name"
  label
  "column name"
  tag
  "column name"
  telegram
  "column name"
  twitter
  "column name"
  website
}

"select columns of table \"accounts\""
enum accounts_select_column {
  "column name"
  account_id
  "column name"
  created_by_receipt_id
  "column name"
  deleted_by_receipt_id
  "column name"
  id
  "column name"
  last_update_block_height
}

"select columns of table \"action_receipt_actions\""
enum action_receipt_actions_select_column {
  "column name"
  action_kind
  "column name"
  args
  "column name"
  index_in_action_receipt
  "column name"
  receipt_id
  "column name"
  receipt_included_in_block_timestamp
  "column name"
  receipt_predecessor_account_id
  "column name"
  receipt_receiver_account_id
}

"select columns of table \"assets__fungible_token_events\""
enum assets__fungible_token_events_select_column {
  "column name"
  amount
  "column name"
  emitted_at_block_timestamp
  "column name"
  emitted_by_contract_account_id
  "column name"
  emitted_for_receipt_id
  "column name"
  emitted_in_shard_id
  "column name"
  emitted_index_of_event_entry_in_shard
  "column name"
  event_kind
  "column name"
  event_memo
  "column name"
  token_new_owner_account_id
  "column name"
  token_old_owner_account_id
}

"select columns of table \"assets__non_fungible_token_events\""
enum assets__non_fungible_token_events_select_column {
  "column name"
  emitted_at_block_timestamp
  "column name"
  emitted_by_contract_account_id
  "column name"
  emitted_for_receipt_id
  "column name"
  emitted_in_shard_id
  "column name"
  emitted_index_of_event_entry_in_shard
  "column name"
  event_kind
  "column name"
  event_memo
  "column name"
  token_authorized_account_id
  "column name"
  token_id
  "column name"
  token_new_owner_account_id
  "column name"
  token_old_owner_account_id
}

"select columns of table \"blocks\""
enum blocks_select_column {
  "column name"
  author_account_id
  "column name"
  block_hash
  "column name"
  block_height
  "column name"
  block_timestamp
  "column name"
  gas_price
  "column name"
  prev_block_hash
  "column name"
  total_supply
}

"select columns of table \"chunks\""
enum chunks_select_column {
  "column name"
  author_account_id
  "column name"
  chunk_hash
  "column name"
  gas_limit
  "column name"
  gas_used
  "column name"
  included_in_block_hash
  "column name"
  shard_id
  "column name"
  signature
}

"select columns of table \"daily_stats\""
enum daily_stats_select_column {
  "column name"
  addresses
  "column name"
  avg_gas_limit
  "column name"
  avg_gas_price
  "column name"
  avg_txn_fee
  "column name"
  avg_txn_fee_usd
  "column name"
  blocks
  "column name"
  contracts
  "column name"
  date
  "column name"
  gas_fee
  "column name"
  gas_used
  "column name"
  id
  "column name"
  market_cap
  "column name"
  near_price
  "column name"
  receiver_addresses
  "column name"
  sender_addresses
  "column name"
  total_addresses
  "column name"
  total_contracts
  "column name"
  total_supply
  "column name"
  txn_fee
  "column name"
  txn_fee_usd
  "column name"
  txn_volume
  "column name"
  txn_volume_usd
  "column name"
  txns
}

"select columns of table \"execution_outcomes\""
enum execution_outcomes_select_column {
  "column name"
  executed_in_block_hash
  "column name"
  executed_in_block_timestamp
  "column name"
  executor_account_id
  "column name"
  gas_burnt
  "column name"
  index_in_chunk
  "column name"
  receipt_id
  "column name"
  shard_id
  "column name"
  status
  "column name"
  tokens_burnt
}

"select columns of table \"ft_balance\""
enum ft_balance_select_column {
  "column name"
  amount
  "column name"
  emitted_by_contract_account_id
}

"select columns of table \"ft_holder\""
enum ft_holder_select_column {
  "column name"
  account
  "column name"
  amount
  "column name"
  rank
}

"select columns of table \"ft_meta\""
enum ft_meta_select_column {
  "column name"
  change_24
  "column name"
  circulating_supply
  "column name"
  coingecko_id
  "column name"
  coinmarketcap_id
  "column name"
  decimals
  "column name"
  description
  "column name"
  emitted_by_contract_account_id
  "column name"
  extra
  "column name"
  facebook
  "column name"
  fully_diluted_market_cap
  "column name"
  market_cap
  "column name"
  name
  "column name"
  price
  "column name"
  price_btc
  "column name"
  price_eth
  "column name"
  reddit
  "column name"
  site_url
  "column name"
  symbol
  "column name"
  telegram
  "column name"
  twitter
  "column name"
  verified
  "column name"
  volume_24h
}

"select columns of table \"ft_tokens_view\""
enum ft_tokens_view_select_column {
  "column name"
  emitted_by_contract_account_id
  "column name"
  totalsupply
}

"select columns of table \"ft_transfer_count\""
enum ft_transfer_count_select_column {
  "column name"
  contract
  "column name"
  transfers
}

"select columns of table \"ft_transfer\""
enum ft_transfer_select_column {
  "column name"
  action_kind
  "column name"
  args
  "column name"
  index_in_action_receipt
  "column name"
  originated_from_transaction_hash
  "column name"
  receipt_id
  "column name"
  receipt_included_in_block_timestamp
  "column name"
  receipt_predecessor_account_id
  "column name"
  receipt_receiver_account_id
}

"select columns of table \"fungible_tokens\""
enum fungible_tokens_select_column {
  "column name"
  args
  "column name"
  emitted_by_contract_account_id
  "column name"
  totalsupply
}

"select columns of table \"legacy_ft_meta\""
enum legacy_ft_meta_select_column {
  "column name"
  args
  "column name"
  change_24
  "column name"
  circulating_supply
  "column name"
  coingecko_id
  "column name"
  coinmarketcap_id
  "column name"
  contract
  "column name"
  decimals
  "column name"
  description
  "column name"
  facebook
  "column name"
  fully_diluted_market_cap
  "column name"
  icon
  "column name"
  market_cap
  "column name"
  name
  "column name"
  price
  "column name"
  price_btc
  "column name"
  price_eth
  "column name"
  reddit
  "column name"
  status
  "column name"
  symbol
  "column name"
  telegram
  "column name"
  total_supply
  "column name"
  twitter
  "column name"
  volume_24h
  "column name"
  website
}

"select columns of table \"nft_contract_meta\""
enum nft_contract_meta_select_column {
  "column name"
  base_uri
  "column name"
  emitted_by_contract_account_id
  "column name"
  icon
  "column name"
  name
  "column name"
  reference
  "column name"
  reference_hash
  "column name"
  spec
  "column name"
  symbol
}

"select columns of table \"nft_token_holders\""
enum nft_token_holders_select_column {
  "column name"
  account
  "column name"
  contract
  "column name"
  quantity
}

"select columns of table \"nft_token\""
enum nft_token_select_column {
  "column name"
  copies
  "column name"
  description
  "column name"
  emitted_by_contract_account_id
  "column name"
  expires_at
  "column name"
  extra
  "column name"
  issued_at
  "column name"
  media
  "column name"
  owner_id
  "column name"
  starts_at
  "column name"
  title
  "column name"
  token_id
  "column name"
  updated_at
}

"column ordering options"
enum order_by {
  "in ascending order, nulls last"
  asc
  "in ascending order, nulls first"
  asc_nulls_first
  "in ascending order, nulls last"
  asc_nulls_last
  "in descending order, nulls first"
  desc
  "in descending order, nulls first"
  desc_nulls_first
  "in descending order, nulls last"
  desc_nulls_last
}

"select columns of table \"receipts\""
enum receipts_select_column {
  "column name"
  included_in_block_hash
  "column name"
  included_in_block_timestamp
  "column name"
  included_in_chunk_hash
  "column name"
  index_in_chunk
  "column name"
  originated_from_transaction_hash
  "column name"
  predecessor_account_id
  "column name"
  receipt_id
  "column name"
  receipt_kind
  "column name"
  receiver_account_id
}

"select columns of table \"stats\""
enum stats_select_column {
  "column name"
  avg_block_time
  "column name"
  block
  "column name"
  change_24
  "column name"
  gas_price
  "column name"
  high_24h
  "column name"
  high_all
  "column name"
  id
  "column name"
  low_24h
  "column name"
  low_all
  "column name"
  market_cap
  "column name"
  near_btc_price
  "column name"
  near_price
  "column name"
  nodes
  "column name"
  nodes_online
  "column name"
  total_supply
  "column name"
  total_txns
  "column name"
  volume
}

"select columns of table \"tokens_count\""
enum tokens_count_select_column {
  "column name"
  count
}

"select columns of table \"top_nft_token\""
enum top_nft_token_select_column {
  "column name"
  contract
  "column name"
  transfers_3days
  "column name"
  transfers_day
}

"select columns of table \"transaction_actions\""
enum transaction_actions_select_column {
  "column name"
  action_kind
  "column name"
  args
  "column name"
  index_in_transaction
  "column name"
  transaction_hash
}

"select columns of table \"transactions\""
enum transactions_select_column {
  "column name"
  block_timestamp
  "column name"
  converted_into_receipt_id
  "column name"
  included_in_block_hash
  "column name"
  included_in_chunk_hash
  "column name"
  index_in_chunk
  "column name"
  nonce
  "column name"
  receipt_conversion_gas_burnt
  "column name"
  receipt_conversion_tokens_burnt
  "column name"
  receiver_account_id
  "column name"
  signature
  "column name"
  signer_account_id
  "column name"
  signer_public_key
  "column name"
  status
  "column name"
  transaction_hash
}

scalar access_key_permission_kind

scalar action_kind

scalar bigint

scalar date

scalar execution_outcome_status

scalar ft_event_kind

scalar jsonb

scalar nft_event_kind

scalar numeric

scalar receipt_kind

"Boolean expression to compare columns of type \"Boolean\". All fields are combined with logical 'AND'."
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"Boolean expression to compare columns of type \"Int\". All fields are combined with logical 'AND'."
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"Boolean expression to compare columns of type \"String\". All fields are combined with logical 'AND'."
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  "does the column match the given case-insensitive pattern"
  _ilike: String
  _in: [String!]
  "does the column match the given POSIX regular expression, case insensitive"
  _iregex: String
  _is_null: Boolean
  "does the column match the given pattern"
  _like: String
  _lt: String
  _lte: String
  _neq: String
  "does the column NOT match the given case-insensitive pattern"
  _nilike: String
  _nin: [String!]
  "does the column NOT match the given POSIX regular expression, case insensitive"
  _niregex: String
  "does the column NOT match the given pattern"
  _nlike: String
  "does the column NOT match the given POSIX regular expression, case sensitive"
  _nregex: String
  "does the column NOT match the given SQL regular expression"
  _nsimilar: String
  "does the column match the given POSIX regular expression, case sensitive"
  _regex: String
  "does the column match the given SQL regular expression"
  _similar: String
}

"Boolean expression to compare columns of type \"access_key_permission_kind\". All fields are combined with logical 'AND'."
input access_key_permission_kind_comparison_exp {
  _eq: access_key_permission_kind
  _gt: access_key_permission_kind
  _gte: access_key_permission_kind
  _in: [access_key_permission_kind!]
  _is_null: Boolean
  _lt: access_key_permission_kind
  _lte: access_key_permission_kind
  _neq: access_key_permission_kind
  _nin: [access_key_permission_kind!]
}

"order by aggregate values of table \"access_keys\""
input access_keys_aggregate_order_by {
  avg: access_keys_avg_order_by
  count: order_by
  max: access_keys_max_order_by
  min: access_keys_min_order_by
  stddev: access_keys_stddev_order_by
  stddev_pop: access_keys_stddev_pop_order_by
  stddev_samp: access_keys_stddev_samp_order_by
  sum: access_keys_sum_order_by
  var_pop: access_keys_var_pop_order_by
  var_samp: access_keys_var_samp_order_by
  variance: access_keys_variance_order_by
}

"order by avg() on columns of table \"access_keys\""
input access_keys_avg_order_by {
  last_update_block_height: order_by
}

"Boolean expression to filter rows from the table \"access_keys\". All fields are combined with a logical 'AND'."
input access_keys_bool_exp {
  _and: [access_keys_bool_exp!]
  _not: access_keys_bool_exp
  _or: [access_keys_bool_exp!]
  account_id: String_comparison_exp
  created_by_receipt_id: String_comparison_exp
  deleted_by_receipt_id: String_comparison_exp
  last_update_block_height: numeric_comparison_exp
  permission_kind: access_key_permission_kind_comparison_exp
  public_key: String_comparison_exp
  receipt: receipts_bool_exp
  receiptByDeletedByReceiptId: receipts_bool_exp
  transaction: transactions_bool_exp
}

"order by max() on columns of table \"access_keys\""
input access_keys_max_order_by {
  account_id: order_by
  created_by_receipt_id: order_by
  deleted_by_receipt_id: order_by
  last_update_block_height: order_by
  permission_kind: order_by
  public_key: order_by
}

"order by min() on columns of table \"access_keys\""
input access_keys_min_order_by {
  account_id: order_by
  created_by_receipt_id: order_by
  deleted_by_receipt_id: order_by
  last_update_block_height: order_by
  permission_kind: order_by
  public_key: order_by
}

"Ordering options when selecting data from \"access_keys\"."
input access_keys_order_by {
  account_id: order_by
  created_by_receipt_id: order_by
  deleted_by_receipt_id: order_by
  last_update_block_height: order_by
  permission_kind: order_by
  public_key: order_by
  receipt: receipts_order_by
  receiptByDeletedByReceiptId: receipts_order_by
  transaction: transactions_order_by
}

"order by stddev() on columns of table \"access_keys\""
input access_keys_stddev_order_by {
  last_update_block_height: order_by
}

"order by stddev_pop() on columns of table \"access_keys\""
input access_keys_stddev_pop_order_by {
  last_update_block_height: order_by
}

"order by stddev_samp() on columns of table \"access_keys\""
input access_keys_stddev_samp_order_by {
  last_update_block_height: order_by
}

"order by sum() on columns of table \"access_keys\""
input access_keys_sum_order_by {
  last_update_block_height: order_by
}

"order by var_pop() on columns of table \"access_keys\""
input access_keys_var_pop_order_by {
  last_update_block_height: order_by
}

"order by var_samp() on columns of table \"access_keys\""
input access_keys_var_samp_order_by {
  last_update_block_height: order_by
}

"order by variance() on columns of table \"access_keys\""
input access_keys_variance_order_by {
  last_update_block_height: order_by
}

"order by aggregate values of table \"accounts\""
input accounts_aggregate_order_by {
  avg: accounts_avg_order_by
  count: order_by
  max: accounts_max_order_by
  min: accounts_min_order_by
  stddev: accounts_stddev_order_by
  stddev_pop: accounts_stddev_pop_order_by
  stddev_samp: accounts_stddev_samp_order_by
  sum: accounts_sum_order_by
  var_pop: accounts_var_pop_order_by
  var_samp: accounts_var_samp_order_by
  variance: accounts_variance_order_by
}

"order by avg() on columns of table \"accounts\""
input accounts_avg_order_by {
  id: order_by
  last_update_block_height: order_by
}

"Boolean expression to filter rows from the table \"accounts\". All fields are combined with a logical 'AND'."
input accounts_bool_exp {
  _and: [accounts_bool_exp!]
  _not: accounts_bool_exp
  _or: [accounts_bool_exp!]
  account_id: String_comparison_exp
  accounts_label: accounts_label_bool_exp
  created_by_receipt_id: String_comparison_exp
  deleted_by_receipt_id: String_comparison_exp
  id: bigint_comparison_exp
  last_update_block_height: numeric_comparison_exp
  receipt: receipts_bool_exp
  receiptByDeletedByReceiptId: receipts_bool_exp
}

"Boolean expression to filter rows from the table \"accounts_label\". All fields are combined with a logical 'AND'."
input accounts_label_bool_exp {
  _and: [accounts_label_bool_exp!]
  _not: accounts_label_bool_exp
  _or: [accounts_label_bool_exp!]
  account: accounts_bool_exp
  account_id: String_comparison_exp
  blog: String_comparison_exp
  id: bigint_comparison_exp
  label: String_comparison_exp
  tag: String_comparison_exp
  telegram: String_comparison_exp
  twitter: String_comparison_exp
  website: String_comparison_exp
}

"Ordering options when selecting data from \"accounts_label\"."
input accounts_label_order_by {
  account: accounts_order_by
  account_id: order_by
  blog: order_by
  id: order_by
  label: order_by
  tag: order_by
  telegram: order_by
  twitter: order_by
  website: order_by
}

"order by max() on columns of table \"accounts\""
input accounts_max_order_by {
  account_id: order_by
  created_by_receipt_id: order_by
  deleted_by_receipt_id: order_by
  id: order_by
  last_update_block_height: order_by
}

"order by min() on columns of table \"accounts\""
input accounts_min_order_by {
  account_id: order_by
  created_by_receipt_id: order_by
  deleted_by_receipt_id: order_by
  id: order_by
  last_update_block_height: order_by
}

"Ordering options when selecting data from \"accounts\"."
input accounts_order_by {
  account_id: order_by
  accounts_label: accounts_label_order_by
  created_by_receipt_id: order_by
  deleted_by_receipt_id: order_by
  id: order_by
  last_update_block_height: order_by
  receipt: receipts_order_by
  receiptByDeletedByReceiptId: receipts_order_by
}

"order by stddev() on columns of table \"accounts\""
input accounts_stddev_order_by {
  id: order_by
  last_update_block_height: order_by
}

"order by stddev_pop() on columns of table \"accounts\""
input accounts_stddev_pop_order_by {
  id: order_by
  last_update_block_height: order_by
}

"order by stddev_samp() on columns of table \"accounts\""
input accounts_stddev_samp_order_by {
  id: order_by
  last_update_block_height: order_by
}

"order by sum() on columns of table \"accounts\""
input accounts_sum_order_by {
  id: order_by
  last_update_block_height: order_by
}

"order by var_pop() on columns of table \"accounts\""
input accounts_var_pop_order_by {
  id: order_by
  last_update_block_height: order_by
}

"order by var_samp() on columns of table \"accounts\""
input accounts_var_samp_order_by {
  id: order_by
  last_update_block_height: order_by
}

"order by variance() on columns of table \"accounts\""
input accounts_variance_order_by {
  id: order_by
  last_update_block_height: order_by
}

"Boolean expression to compare columns of type \"action_kind\". All fields are combined with logical 'AND'."
input action_kind_comparison_exp {
  _eq: action_kind
  _gt: action_kind
  _gte: action_kind
  _in: [action_kind!]
  _is_null: Boolean
  _lt: action_kind
  _lte: action_kind
  _neq: action_kind
  _nin: [action_kind!]
}

"order by aggregate values of table \"action_receipt_actions\""
input action_receipt_actions_aggregate_order_by {
  avg: action_receipt_actions_avg_order_by
  count: order_by
  max: action_receipt_actions_max_order_by
  min: action_receipt_actions_min_order_by
  stddev: action_receipt_actions_stddev_order_by
  stddev_pop: action_receipt_actions_stddev_pop_order_by
  stddev_samp: action_receipt_actions_stddev_samp_order_by
  sum: action_receipt_actions_sum_order_by
  var_pop: action_receipt_actions_var_pop_order_by
  var_samp: action_receipt_actions_var_samp_order_by
  variance: action_receipt_actions_variance_order_by
}

"order by avg() on columns of table \"action_receipt_actions\""
input action_receipt_actions_avg_order_by {
  index_in_action_receipt: order_by
  receipt_included_in_block_timestamp: order_by
}

"Boolean expression to filter rows from the table \"action_receipt_actions\". All fields are combined with a logical 'AND'."
input action_receipt_actions_bool_exp {
  _and: [action_receipt_actions_bool_exp!]
  _not: action_receipt_actions_bool_exp
  _or: [action_receipt_actions_bool_exp!]
  action_kind: action_kind_comparison_exp
  args: jsonb_comparison_exp
  ft: legacy_ft_meta_bool_exp
  index_in_action_receipt: Int_comparison_exp
  nft: nft_contract_meta_bool_exp
  receipt: receipts_bool_exp
  receipt_id: String_comparison_exp
  receipt_included_in_block_timestamp: numeric_comparison_exp
  receipt_predecessor_account_id: String_comparison_exp
  receipt_receiver_account_id: String_comparison_exp
}

"order by max() on columns of table \"action_receipt_actions\""
input action_receipt_actions_max_order_by {
  action_kind: order_by
  index_in_action_receipt: order_by
  receipt_id: order_by
  receipt_included_in_block_timestamp: order_by
  receipt_predecessor_account_id: order_by
  receipt_receiver_account_id: order_by
}

"order by min() on columns of table \"action_receipt_actions\""
input action_receipt_actions_min_order_by {
  action_kind: order_by
  index_in_action_receipt: order_by
  receipt_id: order_by
  receipt_included_in_block_timestamp: order_by
  receipt_predecessor_account_id: order_by
  receipt_receiver_account_id: order_by
}

"Ordering options when selecting data from \"action_receipt_actions\"."
input action_receipt_actions_order_by {
  action_kind: order_by
  args: order_by
  ft: legacy_ft_meta_order_by
  index_in_action_receipt: order_by
  nft: nft_contract_meta_order_by
  receipt: receipts_order_by
  receipt_id: order_by
  receipt_included_in_block_timestamp: order_by
  receipt_predecessor_account_id: order_by
  receipt_receiver_account_id: order_by
}

"order by stddev() on columns of table \"action_receipt_actions\""
input action_receipt_actions_stddev_order_by {
  index_in_action_receipt: order_by
  receipt_included_in_block_timestamp: order_by
}

"order by stddev_pop() on columns of table \"action_receipt_actions\""
input action_receipt_actions_stddev_pop_order_by {
  index_in_action_receipt: order_by
  receipt_included_in_block_timestamp: order_by
}

"order by stddev_samp() on columns of table \"action_receipt_actions\""
input action_receipt_actions_stddev_samp_order_by {
  index_in_action_receipt: order_by
  receipt_included_in_block_timestamp: order_by
}

"order by sum() on columns of table \"action_receipt_actions\""
input action_receipt_actions_sum_order_by {
  index_in_action_receipt: order_by
  receipt_included_in_block_timestamp: order_by
}

"order by var_pop() on columns of table \"action_receipt_actions\""
input action_receipt_actions_var_pop_order_by {
  index_in_action_receipt: order_by
  receipt_included_in_block_timestamp: order_by
}

"order by var_samp() on columns of table \"action_receipt_actions\""
input action_receipt_actions_var_samp_order_by {
  index_in_action_receipt: order_by
  receipt_included_in_block_timestamp: order_by
}

"order by variance() on columns of table \"action_receipt_actions\""
input action_receipt_actions_variance_order_by {
  index_in_action_receipt: order_by
  receipt_included_in_block_timestamp: order_by
}

"order by aggregate values of table \"assets__fungible_token_events\""
input assets__fungible_token_events_aggregate_order_by {
  avg: assets__fungible_token_events_avg_order_by
  count: order_by
  max: assets__fungible_token_events_max_order_by
  min: assets__fungible_token_events_min_order_by
  stddev: assets__fungible_token_events_stddev_order_by
  stddev_pop: assets__fungible_token_events_stddev_pop_order_by
  stddev_samp: assets__fungible_token_events_stddev_samp_order_by
  sum: assets__fungible_token_events_sum_order_by
  var_pop: assets__fungible_token_events_var_pop_order_by
  var_samp: assets__fungible_token_events_var_samp_order_by
  variance: assets__fungible_token_events_variance_order_by
}

"order by avg() on columns of table \"assets__fungible_token_events\""
input assets__fungible_token_events_avg_order_by {
  emitted_at_block_timestamp: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
}

"Boolean expression to filter rows from the table \"assets__fungible_token_events\". All fields are combined with a logical 'AND'."
input assets__fungible_token_events_bool_exp {
  _and: [assets__fungible_token_events_bool_exp!]
  _not: assets__fungible_token_events_bool_exp
  _or: [assets__fungible_token_events_bool_exp!]
  amount: String_comparison_exp
  emitted_at_block_timestamp: numeric_comparison_exp
  emitted_by_contract_account_id: String_comparison_exp
  emitted_for_receipt_id: String_comparison_exp
  emitted_in_shard_id: numeric_comparison_exp
  emitted_index_of_event_entry_in_shard: Int_comparison_exp
  event_kind: ft_event_kind_comparison_exp
  event_memo: String_comparison_exp
  receipt: receipts_bool_exp
  token: fungible_tokens_bool_exp
  token_new_owner_account_id: String_comparison_exp
  token_old_owner_account_id: String_comparison_exp
}

"order by max() on columns of table \"assets__fungible_token_events\""
input assets__fungible_token_events_max_order_by {
  amount: order_by
  emitted_at_block_timestamp: order_by
  emitted_by_contract_account_id: order_by
  emitted_for_receipt_id: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
  event_kind: order_by
  event_memo: order_by
  token_new_owner_account_id: order_by
  token_old_owner_account_id: order_by
}

"order by min() on columns of table \"assets__fungible_token_events\""
input assets__fungible_token_events_min_order_by {
  amount: order_by
  emitted_at_block_timestamp: order_by
  emitted_by_contract_account_id: order_by
  emitted_for_receipt_id: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
  event_kind: order_by
  event_memo: order_by
  token_new_owner_account_id: order_by
  token_old_owner_account_id: order_by
}

"Ordering options when selecting data from \"assets__fungible_token_events\"."
input assets__fungible_token_events_order_by {
  amount: order_by
  emitted_at_block_timestamp: order_by
  emitted_by_contract_account_id: order_by
  emitted_for_receipt_id: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
  event_kind: order_by
  event_memo: order_by
  receipt: receipts_order_by
  token: fungible_tokens_order_by
  token_new_owner_account_id: order_by
  token_old_owner_account_id: order_by
}

"order by stddev() on columns of table \"assets__fungible_token_events\""
input assets__fungible_token_events_stddev_order_by {
  emitted_at_block_timestamp: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
}

"order by stddev_pop() on columns of table \"assets__fungible_token_events\""
input assets__fungible_token_events_stddev_pop_order_by {
  emitted_at_block_timestamp: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
}

"order by stddev_samp() on columns of table \"assets__fungible_token_events\""
input assets__fungible_token_events_stddev_samp_order_by {
  emitted_at_block_timestamp: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
}

"order by sum() on columns of table \"assets__fungible_token_events\""
input assets__fungible_token_events_sum_order_by {
  emitted_at_block_timestamp: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
}

"order by var_pop() on columns of table \"assets__fungible_token_events\""
input assets__fungible_token_events_var_pop_order_by {
  emitted_at_block_timestamp: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
}

"order by var_samp() on columns of table \"assets__fungible_token_events\""
input assets__fungible_token_events_var_samp_order_by {
  emitted_at_block_timestamp: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
}

"order by variance() on columns of table \"assets__fungible_token_events\""
input assets__fungible_token_events_variance_order_by {
  emitted_at_block_timestamp: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
}

"order by aggregate values of table \"assets__non_fungible_token_events\""
input assets__non_fungible_token_events_aggregate_order_by {
  avg: assets__non_fungible_token_events_avg_order_by
  count: order_by
  max: assets__non_fungible_token_events_max_order_by
  min: assets__non_fungible_token_events_min_order_by
  stddev: assets__non_fungible_token_events_stddev_order_by
  stddev_pop: assets__non_fungible_token_events_stddev_pop_order_by
  stddev_samp: assets__non_fungible_token_events_stddev_samp_order_by
  sum: assets__non_fungible_token_events_sum_order_by
  var_pop: assets__non_fungible_token_events_var_pop_order_by
  var_samp: assets__non_fungible_token_events_var_samp_order_by
  variance: assets__non_fungible_token_events_variance_order_by
}

"order by avg() on columns of table \"assets__non_fungible_token_events\""
input assets__non_fungible_token_events_avg_order_by {
  emitted_at_block_timestamp: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
}

"Boolean expression to filter rows from the table \"assets__non_fungible_token_events\". All fields are combined with a logical 'AND'."
input assets__non_fungible_token_events_bool_exp {
  _and: [assets__non_fungible_token_events_bool_exp!]
  _not: assets__non_fungible_token_events_bool_exp
  _or: [assets__non_fungible_token_events_bool_exp!]
  emitted_at_block_timestamp: numeric_comparison_exp
  emitted_by_contract_account_id: String_comparison_exp
  emitted_for_receipt_id: String_comparison_exp
  emitted_in_shard_id: numeric_comparison_exp
  emitted_index_of_event_entry_in_shard: Int_comparison_exp
  event_kind: nft_event_kind_comparison_exp
  event_memo: String_comparison_exp
  meta: nft_contract_meta_bool_exp
  receipt: receipts_bool_exp
  token: nft_token_bool_exp
  token_authorized_account_id: String_comparison_exp
  token_id: String_comparison_exp
  token_new_owner_account_id: String_comparison_exp
  token_old_owner_account_id: String_comparison_exp
}

"order by max() on columns of table \"assets__non_fungible_token_events\""
input assets__non_fungible_token_events_max_order_by {
  emitted_at_block_timestamp: order_by
  emitted_by_contract_account_id: order_by
  emitted_for_receipt_id: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
  event_kind: order_by
  event_memo: order_by
  token_authorized_account_id: order_by
  token_id: order_by
  token_new_owner_account_id: order_by
  token_old_owner_account_id: order_by
}

"order by min() on columns of table \"assets__non_fungible_token_events\""
input assets__non_fungible_token_events_min_order_by {
  emitted_at_block_timestamp: order_by
  emitted_by_contract_account_id: order_by
  emitted_for_receipt_id: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
  event_kind: order_by
  event_memo: order_by
  token_authorized_account_id: order_by
  token_id: order_by
  token_new_owner_account_id: order_by
  token_old_owner_account_id: order_by
}

"Ordering options when selecting data from \"assets__non_fungible_token_events\"."
input assets__non_fungible_token_events_order_by {
  emitted_at_block_timestamp: order_by
  emitted_by_contract_account_id: order_by
  emitted_for_receipt_id: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
  event_kind: order_by
  event_memo: order_by
  meta: nft_contract_meta_order_by
  receipt: receipts_order_by
  token: nft_token_order_by
  token_authorized_account_id: order_by
  token_id: order_by
  token_new_owner_account_id: order_by
  token_old_owner_account_id: order_by
}

"order by stddev() on columns of table \"assets__non_fungible_token_events\""
input assets__non_fungible_token_events_stddev_order_by {
  emitted_at_block_timestamp: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
}

"order by stddev_pop() on columns of table \"assets__non_fungible_token_events\""
input assets__non_fungible_token_events_stddev_pop_order_by {
  emitted_at_block_timestamp: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
}

"order by stddev_samp() on columns of table \"assets__non_fungible_token_events\""
input assets__non_fungible_token_events_stddev_samp_order_by {
  emitted_at_block_timestamp: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
}

"order by sum() on columns of table \"assets__non_fungible_token_events\""
input assets__non_fungible_token_events_sum_order_by {
  emitted_at_block_timestamp: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
}

"order by var_pop() on columns of table \"assets__non_fungible_token_events\""
input assets__non_fungible_token_events_var_pop_order_by {
  emitted_at_block_timestamp: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
}

"order by var_samp() on columns of table \"assets__non_fungible_token_events\""
input assets__non_fungible_token_events_var_samp_order_by {
  emitted_at_block_timestamp: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
}

"order by variance() on columns of table \"assets__non_fungible_token_events\""
input assets__non_fungible_token_events_variance_order_by {
  emitted_at_block_timestamp: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
}

"Boolean expression to compare columns of type \"bigint\". All fields are combined with logical 'AND'."
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"Boolean expression to filter rows from the table \"blocks\". All fields are combined with a logical 'AND'."
input blocks_bool_exp {
  _and: [blocks_bool_exp!]
  _not: blocks_bool_exp
  _or: [blocks_bool_exp!]
  author_account_id: String_comparison_exp
  block_hash: String_comparison_exp
  block_height: numeric_comparison_exp
  block_timestamp: numeric_comparison_exp
  chunks: chunks_bool_exp
  execution_outcomes: execution_outcomes_bool_exp
  gas_price: numeric_comparison_exp
  prev_block_hash: String_comparison_exp
  receipts: receipts_bool_exp
  total_supply: numeric_comparison_exp
  transactions: transactions_bool_exp
}

"Ordering options when selecting data from \"blocks\"."
input blocks_order_by {
  author_account_id: order_by
  block_hash: order_by
  block_height: order_by
  block_timestamp: order_by
  chunks_aggregate: chunks_aggregate_order_by
  execution_outcomes_aggregate: execution_outcomes_aggregate_order_by
  gas_price: order_by
  prev_block_hash: order_by
  receipts_aggregate: receipts_aggregate_order_by
  total_supply: order_by
  transactions_aggregate: transactions_aggregate_order_by
}

"order by aggregate values of table \"chunks\""
input chunks_aggregate_order_by {
  avg: chunks_avg_order_by
  count: order_by
  max: chunks_max_order_by
  min: chunks_min_order_by
  stddev: chunks_stddev_order_by
  stddev_pop: chunks_stddev_pop_order_by
  stddev_samp: chunks_stddev_samp_order_by
  sum: chunks_sum_order_by
  var_pop: chunks_var_pop_order_by
  var_samp: chunks_var_samp_order_by
  variance: chunks_variance_order_by
}

"order by avg() on columns of table \"chunks\""
input chunks_avg_order_by {
  gas_limit: order_by
  gas_used: order_by
  shard_id: order_by
}

"Boolean expression to filter rows from the table \"chunks\". All fields are combined with a logical 'AND'."
input chunks_bool_exp {
  _and: [chunks_bool_exp!]
  _not: chunks_bool_exp
  _or: [chunks_bool_exp!]
  author_account_id: String_comparison_exp
  block: blocks_bool_exp
  chunk_hash: String_comparison_exp
  gas_limit: numeric_comparison_exp
  gas_used: numeric_comparison_exp
  included_in_block_hash: String_comparison_exp
  receipts: receipts_bool_exp
  shard_id: numeric_comparison_exp
  signature: String_comparison_exp
  transactions: transactions_bool_exp
}

"order by max() on columns of table \"chunks\""
input chunks_max_order_by {
  author_account_id: order_by
  chunk_hash: order_by
  gas_limit: order_by
  gas_used: order_by
  included_in_block_hash: order_by
  shard_id: order_by
  signature: order_by
}

"order by min() on columns of table \"chunks\""
input chunks_min_order_by {
  author_account_id: order_by
  chunk_hash: order_by
  gas_limit: order_by
  gas_used: order_by
  included_in_block_hash: order_by
  shard_id: order_by
  signature: order_by
}

"Ordering options when selecting data from \"chunks\"."
input chunks_order_by {
  author_account_id: order_by
  block: blocks_order_by
  chunk_hash: order_by
  gas_limit: order_by
  gas_used: order_by
  included_in_block_hash: order_by
  receipts_aggregate: receipts_aggregate_order_by
  shard_id: order_by
  signature: order_by
  transactions_aggregate: transactions_aggregate_order_by
}

"order by stddev() on columns of table \"chunks\""
input chunks_stddev_order_by {
  gas_limit: order_by
  gas_used: order_by
  shard_id: order_by
}

"order by stddev_pop() on columns of table \"chunks\""
input chunks_stddev_pop_order_by {
  gas_limit: order_by
  gas_used: order_by
  shard_id: order_by
}

"order by stddev_samp() on columns of table \"chunks\""
input chunks_stddev_samp_order_by {
  gas_limit: order_by
  gas_used: order_by
  shard_id: order_by
}

"order by sum() on columns of table \"chunks\""
input chunks_sum_order_by {
  gas_limit: order_by
  gas_used: order_by
  shard_id: order_by
}

"order by var_pop() on columns of table \"chunks\""
input chunks_var_pop_order_by {
  gas_limit: order_by
  gas_used: order_by
  shard_id: order_by
}

"order by var_samp() on columns of table \"chunks\""
input chunks_var_samp_order_by {
  gas_limit: order_by
  gas_used: order_by
  shard_id: order_by
}

"order by variance() on columns of table \"chunks\""
input chunks_variance_order_by {
  gas_limit: order_by
  gas_used: order_by
  shard_id: order_by
}

"Boolean expression to filter rows from the table \"daily_stats\". All fields are combined with a logical 'AND'."
input daily_stats_bool_exp {
  _and: [daily_stats_bool_exp!]
  _not: daily_stats_bool_exp
  _or: [daily_stats_bool_exp!]
  addresses: numeric_comparison_exp
  avg_gas_limit: String_comparison_exp
  avg_gas_price: String_comparison_exp
  avg_txn_fee: String_comparison_exp
  avg_txn_fee_usd: numeric_comparison_exp
  blocks: numeric_comparison_exp
  contracts: numeric_comparison_exp
  date: date_comparison_exp
  gas_fee: String_comparison_exp
  gas_used: String_comparison_exp
  id: bigint_comparison_exp
  market_cap: numeric_comparison_exp
  near_price: numeric_comparison_exp
  receiver_addresses: numeric_comparison_exp
  sender_addresses: numeric_comparison_exp
  total_addresses: numeric_comparison_exp
  total_contracts: numeric_comparison_exp
  total_supply: String_comparison_exp
  txn_fee: String_comparison_exp
  txn_fee_usd: numeric_comparison_exp
  txn_volume: String_comparison_exp
  txn_volume_usd: numeric_comparison_exp
  txns: numeric_comparison_exp
}

"Ordering options when selecting data from \"daily_stats\"."
input daily_stats_order_by {
  addresses: order_by
  avg_gas_limit: order_by
  avg_gas_price: order_by
  avg_txn_fee: order_by
  avg_txn_fee_usd: order_by
  blocks: order_by
  contracts: order_by
  date: order_by
  gas_fee: order_by
  gas_used: order_by
  id: order_by
  market_cap: order_by
  near_price: order_by
  receiver_addresses: order_by
  sender_addresses: order_by
  total_addresses: order_by
  total_contracts: order_by
  total_supply: order_by
  txn_fee: order_by
  txn_fee_usd: order_by
  txn_volume: order_by
  txn_volume_usd: order_by
  txns: order_by
}

"Boolean expression to compare columns of type \"date\". All fields are combined with logical 'AND'."
input date_comparison_exp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _is_null: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

"Boolean expression to compare columns of type \"execution_outcome_status\". All fields are combined with logical 'AND'."
input execution_outcome_status_comparison_exp {
  _eq: execution_outcome_status
  _gt: execution_outcome_status
  _gte: execution_outcome_status
  _in: [execution_outcome_status!]
  _is_null: Boolean
  _lt: execution_outcome_status
  _lte: execution_outcome_status
  _neq: execution_outcome_status
  _nin: [execution_outcome_status!]
}

"order by aggregate values of table \"execution_outcomes\""
input execution_outcomes_aggregate_order_by {
  avg: execution_outcomes_avg_order_by
  count: order_by
  max: execution_outcomes_max_order_by
  min: execution_outcomes_min_order_by
  stddev: execution_outcomes_stddev_order_by
  stddev_pop: execution_outcomes_stddev_pop_order_by
  stddev_samp: execution_outcomes_stddev_samp_order_by
  sum: execution_outcomes_sum_order_by
  var_pop: execution_outcomes_var_pop_order_by
  var_samp: execution_outcomes_var_samp_order_by
  variance: execution_outcomes_variance_order_by
}

"order by avg() on columns of table \"execution_outcomes\""
input execution_outcomes_avg_order_by {
  executed_in_block_timestamp: order_by
  gas_burnt: order_by
  index_in_chunk: order_by
  shard_id: order_by
  tokens_burnt: order_by
}

"Boolean expression to filter rows from the table \"execution_outcomes\". All fields are combined with a logical 'AND'."
input execution_outcomes_bool_exp {
  _and: [execution_outcomes_bool_exp!]
  _not: execution_outcomes_bool_exp
  _or: [execution_outcomes_bool_exp!]
  block: blocks_bool_exp
  executed_in_block_hash: String_comparison_exp
  executed_in_block_timestamp: numeric_comparison_exp
  executor_account_id: String_comparison_exp
  gas_burnt: numeric_comparison_exp
  index_in_chunk: Int_comparison_exp
  receipt: receipts_bool_exp
  receipt_id: String_comparison_exp
  shard_id: numeric_comparison_exp
  status: execution_outcome_status_comparison_exp
  tokens_burnt: numeric_comparison_exp
}

"order by max() on columns of table \"execution_outcomes\""
input execution_outcomes_max_order_by {
  executed_in_block_hash: order_by
  executed_in_block_timestamp: order_by
  executor_account_id: order_by
  gas_burnt: order_by
  index_in_chunk: order_by
  receipt_id: order_by
  shard_id: order_by
  status: order_by
  tokens_burnt: order_by
}

"order by min() on columns of table \"execution_outcomes\""
input execution_outcomes_min_order_by {
  executed_in_block_hash: order_by
  executed_in_block_timestamp: order_by
  executor_account_id: order_by
  gas_burnt: order_by
  index_in_chunk: order_by
  receipt_id: order_by
  shard_id: order_by
  status: order_by
  tokens_burnt: order_by
}

"Ordering options when selecting data from \"execution_outcomes\"."
input execution_outcomes_order_by {
  block: blocks_order_by
  executed_in_block_hash: order_by
  executed_in_block_timestamp: order_by
  executor_account_id: order_by
  gas_burnt: order_by
  index_in_chunk: order_by
  receipt: receipts_order_by
  receipt_id: order_by
  shard_id: order_by
  status: order_by
  tokens_burnt: order_by
}

"order by stddev() on columns of table \"execution_outcomes\""
input execution_outcomes_stddev_order_by {
  executed_in_block_timestamp: order_by
  gas_burnt: order_by
  index_in_chunk: order_by
  shard_id: order_by
  tokens_burnt: order_by
}

"order by stddev_pop() on columns of table \"execution_outcomes\""
input execution_outcomes_stddev_pop_order_by {
  executed_in_block_timestamp: order_by
  gas_burnt: order_by
  index_in_chunk: order_by
  shard_id: order_by
  tokens_burnt: order_by
}

"order by stddev_samp() on columns of table \"execution_outcomes\""
input execution_outcomes_stddev_samp_order_by {
  executed_in_block_timestamp: order_by
  gas_burnt: order_by
  index_in_chunk: order_by
  shard_id: order_by
  tokens_burnt: order_by
}

"order by sum() on columns of table \"execution_outcomes\""
input execution_outcomes_sum_order_by {
  executed_in_block_timestamp: order_by
  gas_burnt: order_by
  index_in_chunk: order_by
  shard_id: order_by
  tokens_burnt: order_by
}

"order by var_pop() on columns of table \"execution_outcomes\""
input execution_outcomes_var_pop_order_by {
  executed_in_block_timestamp: order_by
  gas_burnt: order_by
  index_in_chunk: order_by
  shard_id: order_by
  tokens_burnt: order_by
}

"order by var_samp() on columns of table \"execution_outcomes\""
input execution_outcomes_var_samp_order_by {
  executed_in_block_timestamp: order_by
  gas_burnt: order_by
  index_in_chunk: order_by
  shard_id: order_by
  tokens_burnt: order_by
}

"order by variance() on columns of table \"execution_outcomes\""
input execution_outcomes_variance_order_by {
  executed_in_block_timestamp: order_by
  gas_burnt: order_by
  index_in_chunk: order_by
  shard_id: order_by
  tokens_burnt: order_by
}

"Boolean expression to filter rows from the table \"ft_balance\". All fields are combined with a logical 'AND'."
input ft_balance_bool_exp {
  _and: [ft_balance_bool_exp!]
  _not: ft_balance_bool_exp
  _or: [ft_balance_bool_exp!]
  amount: numeric_comparison_exp
  emitted_by_contract_account_id: String_comparison_exp
  ft_meta: ft_meta_bool_exp
}

"Ordering options when selecting data from \"ft_balance\"."
input ft_balance_order_by {
  amount: order_by
  emitted_by_contract_account_id: order_by
  ft_meta: ft_meta_order_by
}

input ft_balances_args {
  address: String
}

"Boolean expression to compare columns of type \"ft_event_kind\". All fields are combined with logical 'AND'."
input ft_event_kind_comparison_exp {
  _eq: ft_event_kind
  _gt: ft_event_kind
  _gte: ft_event_kind
  _in: [ft_event_kind!]
  _is_null: Boolean
  _lt: ft_event_kind
  _lte: ft_event_kind
  _neq: ft_event_kind
  _nin: [ft_event_kind!]
}

"Boolean expression to filter rows from the table \"ft_holder\". All fields are combined with a logical 'AND'."
input ft_holder_bool_exp {
  _and: [ft_holder_bool_exp!]
  _not: ft_holder_bool_exp
  _or: [ft_holder_bool_exp!]
  account: String_comparison_exp
  amount: numeric_comparison_exp
  rank: Int_comparison_exp
}

"Ordering options when selecting data from \"ft_holder\"."
input ft_holder_order_by {
  account: order_by
  amount: order_by
  rank: order_by
}

input ft_holders_args {
  token: String
}

"Boolean expression to filter rows from the table \"ft_meta\". All fields are combined with a logical 'AND'."
input ft_meta_bool_exp {
  _and: [ft_meta_bool_exp!]
  _not: ft_meta_bool_exp
  _or: [ft_meta_bool_exp!]
  change_24: numeric_comparison_exp
  circulating_supply: numeric_comparison_exp
  coingecko_id: String_comparison_exp
  coinmarketcap_id: String_comparison_exp
  decimals: numeric_comparison_exp
  description: String_comparison_exp
  emitted_by_contract_account_id: String_comparison_exp
  extra: jsonb_comparison_exp
  facebook: String_comparison_exp
  fully_diluted_market_cap: numeric_comparison_exp
  market_cap: numeric_comparison_exp
  name: String_comparison_exp
  price: numeric_comparison_exp
  price_btc: numeric_comparison_exp
  price_eth: numeric_comparison_exp
  reddit: String_comparison_exp
  site_url: String_comparison_exp
  symbol: String_comparison_exp
  telegram: String_comparison_exp
  twitter: String_comparison_exp
  verified: Boolean_comparison_exp
  volume_24h: numeric_comparison_exp
}

"Ordering options when selecting data from \"ft_meta\"."
input ft_meta_order_by {
  change_24: order_by
  circulating_supply: order_by
  coingecko_id: order_by
  coinmarketcap_id: order_by
  decimals: order_by
  description: order_by
  emitted_by_contract_account_id: order_by
  extra: order_by
  facebook: order_by
  fully_diluted_market_cap: order_by
  market_cap: order_by
  name: order_by
  price: order_by
  price_btc: order_by
  price_eth: order_by
  reddit: order_by
  site_url: order_by
  symbol: order_by
  telegram: order_by
  twitter: order_by
  verified: order_by
  volume_24h: order_by
}

input ft_token_transfers_args {
  skip: Int
  take: Int
  token: String
}

input ft_token_transfers_count_args {
  token: String
}

"Boolean expression to filter rows from the table \"ft_tokens_view\". All fields are combined with a logical 'AND'."
input ft_tokens_view_bool_exp {
  _and: [ft_tokens_view_bool_exp!]
  _not: ft_tokens_view_bool_exp
  _or: [ft_tokens_view_bool_exp!]
  emitted_by_contract_account_id: String_comparison_exp
  ft_token_events: assets__fungible_token_events_bool_exp
  metainfo: ft_meta_bool_exp
  token_events: assets__fungible_token_events_bool_exp
  totalsupply: numeric_comparison_exp
}

"Ordering options when selecting data from \"ft_tokens_view\"."
input ft_tokens_view_order_by {
  emitted_by_contract_account_id: order_by
  ft_token_events: assets__fungible_token_events_order_by
  metainfo: ft_meta_order_by
  token_events_aggregate: assets__fungible_token_events_aggregate_order_by
  totalsupply: order_by
}

input ft_transaction_export_args {
  address: String
  endtime: String
  starttime: String
}

"Boolean expression to filter rows from the table \"ft_transfer\". All fields are combined with a logical 'AND'."
input ft_transfer_bool_exp {
  _and: [ft_transfer_bool_exp!]
  _not: ft_transfer_bool_exp
  _or: [ft_transfer_bool_exp!]
  action_kind: action_kind_comparison_exp
  args: jsonb_comparison_exp
  index_in_action_receipt: Int_comparison_exp
  originated_from_transaction_hash: String_comparison_exp
  receipt_id: String_comparison_exp
  receipt_included_in_block_timestamp: numeric_comparison_exp
  receipt_predecessor_account_id: String_comparison_exp
  receipt_receiver_account_id: String_comparison_exp
}

"Boolean expression to filter rows from the table \"ft_transfer_count\". All fields are combined with a logical 'AND'."
input ft_transfer_count_bool_exp {
  _and: [ft_transfer_count_bool_exp!]
  _not: ft_transfer_count_bool_exp
  _or: [ft_transfer_count_bool_exp!]
  contract: String_comparison_exp
  transfers: numeric_comparison_exp
}

"Ordering options when selecting data from \"ft_transfer_count\"."
input ft_transfer_count_order_by {
  contract: order_by
  transfers: order_by
}

"Ordering options when selecting data from \"ft_transfer\"."
input ft_transfer_order_by {
  action_kind: order_by
  args: order_by
  index_in_action_receipt: order_by
  originated_from_transaction_hash: order_by
  receipt_id: order_by
  receipt_included_in_block_timestamp: order_by
  receipt_predecessor_account_id: order_by
  receipt_receiver_account_id: order_by
}

"Boolean expression to filter rows from the table \"fungible_tokens\". All fields are combined with a logical 'AND'."
input fungible_tokens_bool_exp {
  _and: [fungible_tokens_bool_exp!]
  _not: fungible_tokens_bool_exp
  _or: [fungible_tokens_bool_exp!]
  args: jsonb_comparison_exp
  emitted_by_contract_account_id: String_comparison_exp
  ft_token_events: assets__fungible_token_events_bool_exp
  metainfo: ft_meta_bool_exp
  token_events: assets__fungible_token_events_bool_exp
  totalsupply: numeric_comparison_exp
}

"Ordering options when selecting data from \"fungible_tokens\"."
input fungible_tokens_order_by {
  args: order_by
  emitted_by_contract_account_id: order_by
  ft_token_events: assets__fungible_token_events_order_by
  metainfo: ft_meta_order_by
  token_events_aggregate: assets__fungible_token_events_aggregate_order_by
  totalsupply: order_by
}

input jsonb_cast_exp {
  String: String_comparison_exp
}

"Boolean expression to compare columns of type \"jsonb\". All fields are combined with logical 'AND'."
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp
  "is the column contained in the given json value"
  _contained_in: jsonb
  "does the column contain the given json value at the top level"
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb
  "does the string exist as a top-level key in the column"
  _has_key: String
  "do all of these strings exist as top-level keys in the column"
  _has_keys_all: [String!]
  "do any of these strings exist as top-level keys in the column"
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"Boolean expression to filter rows from the table \"legacy_ft_meta\". All fields are combined with a logical 'AND'."
input legacy_ft_meta_bool_exp {
  _and: [legacy_ft_meta_bool_exp!]
  _not: legacy_ft_meta_bool_exp
  _or: [legacy_ft_meta_bool_exp!]
  args: jsonb_comparison_exp
  change_24: numeric_comparison_exp
  circulating_supply: numeric_comparison_exp
  coingecko_id: String_comparison_exp
  coinmarketcap_id: String_comparison_exp
  contract: String_comparison_exp
  decimals: Int_comparison_exp
  description: String_comparison_exp
  facebook: String_comparison_exp
  fully_diluted_market_cap: numeric_comparison_exp
  icon: String_comparison_exp
  market_cap: numeric_comparison_exp
  name: String_comparison_exp
  price: numeric_comparison_exp
  price_btc: numeric_comparison_exp
  price_eth: numeric_comparison_exp
  reddit: String_comparison_exp
  status: Boolean_comparison_exp
  symbol: String_comparison_exp
  telegram: String_comparison_exp
  total_supply: numeric_comparison_exp
  twitter: String_comparison_exp
  volume_24h: numeric_comparison_exp
  website: String_comparison_exp
}

"Ordering options when selecting data from \"legacy_ft_meta\"."
input legacy_ft_meta_order_by {
  args: order_by
  change_24: order_by
  circulating_supply: order_by
  coingecko_id: order_by
  coinmarketcap_id: order_by
  contract: order_by
  decimals: order_by
  description: order_by
  facebook: order_by
  fully_diluted_market_cap: order_by
  icon: order_by
  market_cap: order_by
  name: order_by
  price: order_by
  price_btc: order_by
  price_eth: order_by
  reddit: order_by
  status: order_by
  symbol: order_by
  telegram: order_by
  total_supply: order_by
  twitter: order_by
  volume_24h: order_by
  website: order_by
}

"Boolean expression to filter rows from the table \"nft_contract_meta\". All fields are combined with a logical 'AND'."
input nft_contract_meta_bool_exp {
  _and: [nft_contract_meta_bool_exp!]
  _not: nft_contract_meta_bool_exp
  _or: [nft_contract_meta_bool_exp!]
  base_uri: String_comparison_exp
  emitted_by_contract_account_id: String_comparison_exp
  icon: String_comparison_exp
  name: String_comparison_exp
  reference: String_comparison_exp
  reference_hash: String_comparison_exp
  spec: String_comparison_exp
  symbol: String_comparison_exp
  tokens: nft_token_bool_exp
}

"Ordering options when selecting data from \"nft_contract_meta\"."
input nft_contract_meta_order_by {
  base_uri: order_by
  emitted_by_contract_account_id: order_by
  icon: order_by
  name: order_by
  reference: order_by
  reference_hash: order_by
  spec: order_by
  symbol: order_by
  tokens_aggregate: nft_token_aggregate_order_by
}

"Boolean expression to compare columns of type \"nft_event_kind\". All fields are combined with logical 'AND'."
input nft_event_kind_comparison_exp {
  _eq: nft_event_kind
  _gt: nft_event_kind
  _gte: nft_event_kind
  _in: [nft_event_kind!]
  _is_null: Boolean
  _lt: nft_event_kind
  _lte: nft_event_kind
  _neq: nft_event_kind
  _nin: [nft_event_kind!]
}

"order by aggregate values of table \"nft_token\""
input nft_token_aggregate_order_by {
  count: order_by
  max: nft_token_max_order_by
  min: nft_token_min_order_by
}

"Boolean expression to filter rows from the table \"nft_token\". All fields are combined with a logical 'AND'."
input nft_token_bool_exp {
  _and: [nft_token_bool_exp!]
  _not: nft_token_bool_exp
  _or: [nft_token_bool_exp!]
  contract_meta: nft_contract_meta_bool_exp
  copies: String_comparison_exp
  description: String_comparison_exp
  emitted_by_contract_account_id: String_comparison_exp
  expires_at: String_comparison_exp
  extra: jsonb_comparison_exp
  issued_at: String_comparison_exp
  media: String_comparison_exp
  owner_id: String_comparison_exp
  starts_at: String_comparison_exp
  title: String_comparison_exp
  token_id: String_comparison_exp
  updated_at: String_comparison_exp
}

"Boolean expression to filter rows from the table \"nft_token_holders\". All fields are combined with a logical 'AND'."
input nft_token_holders_bool_exp {
  _and: [nft_token_holders_bool_exp!]
  _not: nft_token_holders_bool_exp
  _or: [nft_token_holders_bool_exp!]
  account: String_comparison_exp
  contract: String_comparison_exp
  quantity: numeric_comparison_exp
}

"Ordering options when selecting data from \"nft_token_holders\"."
input nft_token_holders_order_by {
  account: order_by
  contract: order_by
  quantity: order_by
}

input nft_token_inventory_args {
  contract: String
  skip: Int
  take: Int
}

input nft_token_inventory_count_args {
  contract: String
}

"order by max() on columns of table \"nft_token\""
input nft_token_max_order_by {
  copies: order_by
  description: order_by
  emitted_by_contract_account_id: order_by
  expires_at: order_by
  issued_at: order_by
  media: order_by
  owner_id: order_by
  starts_at: order_by
  title: order_by
  token_id: order_by
  updated_at: order_by
}

"order by min() on columns of table \"nft_token\""
input nft_token_min_order_by {
  copies: order_by
  description: order_by
  emitted_by_contract_account_id: order_by
  expires_at: order_by
  issued_at: order_by
  media: order_by
  owner_id: order_by
  starts_at: order_by
  title: order_by
  token_id: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"nft_token\"."
input nft_token_order_by {
  contract_meta: nft_contract_meta_order_by
  copies: order_by
  description: order_by
  emitted_by_contract_account_id: order_by
  expires_at: order_by
  extra: order_by
  issued_at: order_by
  media: order_by
  owner_id: order_by
  starts_at: order_by
  title: order_by
  token_id: order_by
  updated_at: order_by
}

"Boolean expression to compare columns of type \"numeric\". All fields are combined with logical 'AND'."
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"Boolean expression to compare columns of type \"receipt_kind\". All fields are combined with logical 'AND'."
input receipt_kind_comparison_exp {
  _eq: receipt_kind
  _gt: receipt_kind
  _gte: receipt_kind
  _in: [receipt_kind!]
  _is_null: Boolean
  _lt: receipt_kind
  _lte: receipt_kind
  _neq: receipt_kind
  _nin: [receipt_kind!]
}

"order by aggregate values of table \"receipts\""
input receipts_aggregate_order_by {
  avg: receipts_avg_order_by
  count: order_by
  max: receipts_max_order_by
  min: receipts_min_order_by
  stddev: receipts_stddev_order_by
  stddev_pop: receipts_stddev_pop_order_by
  stddev_samp: receipts_stddev_samp_order_by
  sum: receipts_sum_order_by
  var_pop: receipts_var_pop_order_by
  var_samp: receipts_var_samp_order_by
  variance: receipts_variance_order_by
}

"order by avg() on columns of table \"receipts\""
input receipts_avg_order_by {
  included_in_block_timestamp: order_by
  index_in_chunk: order_by
}

"Boolean expression to filter rows from the table \"receipts\". All fields are combined with a logical 'AND'."
input receipts_bool_exp {
  _and: [receipts_bool_exp!]
  _not: receipts_bool_exp
  _or: [receipts_bool_exp!]
  accessKeysByDeletedByReceiptId: access_keys_bool_exp
  access_keys: access_keys_bool_exp
  accounts: accounts_bool_exp
  accountsByDeletedByReceiptId: accounts_bool_exp
  action_receipt_actions: action_receipt_actions_bool_exp
  assets__fungible_token_events: assets__fungible_token_events_bool_exp
  assets__non_fungible_token_events: assets__non_fungible_token_events_bool_exp
  block: blocks_bool_exp
  chunk: chunks_bool_exp
  execution_outcome: execution_outcomes_bool_exp
  included_in_block_hash: String_comparison_exp
  included_in_block_timestamp: numeric_comparison_exp
  included_in_chunk_hash: String_comparison_exp
  index_in_chunk: Int_comparison_exp
  originated_from_transaction_hash: String_comparison_exp
  predecessor_account_id: String_comparison_exp
  receipt_id: String_comparison_exp
  receipt_kind: receipt_kind_comparison_exp
  receiver_account_id: String_comparison_exp
  transaction: transactions_bool_exp
}

"order by max() on columns of table \"receipts\""
input receipts_max_order_by {
  included_in_block_hash: order_by
  included_in_block_timestamp: order_by
  included_in_chunk_hash: order_by
  index_in_chunk: order_by
  originated_from_transaction_hash: order_by
  predecessor_account_id: order_by
  receipt_id: order_by
  receipt_kind: order_by
  receiver_account_id: order_by
}

"order by min() on columns of table \"receipts\""
input receipts_min_order_by {
  included_in_block_hash: order_by
  included_in_block_timestamp: order_by
  included_in_chunk_hash: order_by
  index_in_chunk: order_by
  originated_from_transaction_hash: order_by
  predecessor_account_id: order_by
  receipt_id: order_by
  receipt_kind: order_by
  receiver_account_id: order_by
}

"Ordering options when selecting data from \"receipts\"."
input receipts_order_by {
  accessKeysByDeletedByReceiptId_aggregate: access_keys_aggregate_order_by
  access_keys_aggregate: access_keys_aggregate_order_by
  accountsByDeletedByReceiptId_aggregate: accounts_aggregate_order_by
  accounts_aggregate: accounts_aggregate_order_by
  action_receipt_actions_aggregate: action_receipt_actions_aggregate_order_by
  assets__fungible_token_events_aggregate: assets__fungible_token_events_aggregate_order_by
  assets__non_fungible_token_events_aggregate: assets__non_fungible_token_events_aggregate_order_by
  block: blocks_order_by
  chunk: chunks_order_by
  execution_outcome: execution_outcomes_order_by
  included_in_block_hash: order_by
  included_in_block_timestamp: order_by
  included_in_chunk_hash: order_by
  index_in_chunk: order_by
  originated_from_transaction_hash: order_by
  predecessor_account_id: order_by
  receipt_id: order_by
  receipt_kind: order_by
  receiver_account_id: order_by
  transaction: transactions_order_by
}

"order by stddev() on columns of table \"receipts\""
input receipts_stddev_order_by {
  included_in_block_timestamp: order_by
  index_in_chunk: order_by
}

"order by stddev_pop() on columns of table \"receipts\""
input receipts_stddev_pop_order_by {
  included_in_block_timestamp: order_by
  index_in_chunk: order_by
}

"order by stddev_samp() on columns of table \"receipts\""
input receipts_stddev_samp_order_by {
  included_in_block_timestamp: order_by
  index_in_chunk: order_by
}

"order by sum() on columns of table \"receipts\""
input receipts_sum_order_by {
  included_in_block_timestamp: order_by
  index_in_chunk: order_by
}

"order by var_pop() on columns of table \"receipts\""
input receipts_var_pop_order_by {
  included_in_block_timestamp: order_by
  index_in_chunk: order_by
}

"order by var_samp() on columns of table \"receipts\""
input receipts_var_samp_order_by {
  included_in_block_timestamp: order_by
  index_in_chunk: order_by
}

"order by variance() on columns of table \"receipts\""
input receipts_variance_order_by {
  included_in_block_timestamp: order_by
  index_in_chunk: order_by
}

"Boolean expression to filter rows from the table \"stats\". All fields are combined with a logical 'AND'."
input stats_bool_exp {
  _and: [stats_bool_exp!]
  _not: stats_bool_exp
  _or: [stats_bool_exp!]
  avg_block_time: numeric_comparison_exp
  block: bigint_comparison_exp
  change_24: numeric_comparison_exp
  gas_price: bigint_comparison_exp
  high_24h: numeric_comparison_exp
  high_all: numeric_comparison_exp
  id: Int_comparison_exp
  low_24h: numeric_comparison_exp
  low_all: numeric_comparison_exp
  market_cap: numeric_comparison_exp
  near_btc_price: numeric_comparison_exp
  near_price: numeric_comparison_exp
  nodes: Int_comparison_exp
  nodes_online: Int_comparison_exp
  total_supply: String_comparison_exp
  total_txns: bigint_comparison_exp
  volume: numeric_comparison_exp
}

"Ordering options when selecting data from \"stats\"."
input stats_order_by {
  avg_block_time: order_by
  block: order_by
  change_24: order_by
  gas_price: order_by
  high_24h: order_by
  high_all: order_by
  id: order_by
  low_24h: order_by
  low_all: order_by
  market_cap: order_by
  near_btc_price: order_by
  near_price: order_by
  nodes: order_by
  nodes_online: order_by
  total_supply: order_by
  total_txns: order_by
  volume: order_by
}

"Boolean expression to filter rows from the table \"tokens_count\". All fields are combined with a logical 'AND'."
input tokens_count_bool_exp {
  _and: [tokens_count_bool_exp!]
  _not: tokens_count_bool_exp
  _or: [tokens_count_bool_exp!]
  count: Int_comparison_exp
}

"Ordering options when selecting data from \"tokens_count\"."
input tokens_count_order_by {
  count: order_by
}

"Boolean expression to filter rows from the table \"top_nft_token\". All fields are combined with a logical 'AND'."
input top_nft_token_bool_exp {
  _and: [top_nft_token_bool_exp!]
  _not: top_nft_token_bool_exp
  _or: [top_nft_token_bool_exp!]
  contract: String_comparison_exp
  meta: nft_contract_meta_bool_exp
  transfers_3days: Int_comparison_exp
  transfers_day: Int_comparison_exp
}

"Ordering options when selecting data from \"top_nft_token\"."
input top_nft_token_order_by {
  contract: order_by
  meta: nft_contract_meta_order_by
  transfers_3days: order_by
  transfers_day: order_by
}

"order by aggregate values of table \"transaction_actions\""
input transaction_actions_aggregate_order_by {
  avg: transaction_actions_avg_order_by
  count: order_by
  max: transaction_actions_max_order_by
  min: transaction_actions_min_order_by
  stddev: transaction_actions_stddev_order_by
  stddev_pop: transaction_actions_stddev_pop_order_by
  stddev_samp: transaction_actions_stddev_samp_order_by
  sum: transaction_actions_sum_order_by
  var_pop: transaction_actions_var_pop_order_by
  var_samp: transaction_actions_var_samp_order_by
  variance: transaction_actions_variance_order_by
}

"order by avg() on columns of table \"transaction_actions\""
input transaction_actions_avg_order_by {
  index_in_transaction: order_by
}

"Boolean expression to filter rows from the table \"transaction_actions\". All fields are combined with a logical 'AND'."
input transaction_actions_bool_exp {
  _and: [transaction_actions_bool_exp!]
  _not: transaction_actions_bool_exp
  _or: [transaction_actions_bool_exp!]
  action_kind: action_kind_comparison_exp
  args: jsonb_comparison_exp
  index_in_transaction: Int_comparison_exp
  transaction: transactions_bool_exp
  transaction_hash: String_comparison_exp
}

"order by max() on columns of table \"transaction_actions\""
input transaction_actions_max_order_by {
  action_kind: order_by
  index_in_transaction: order_by
  transaction_hash: order_by
}

"order by min() on columns of table \"transaction_actions\""
input transaction_actions_min_order_by {
  action_kind: order_by
  index_in_transaction: order_by
  transaction_hash: order_by
}

"Ordering options when selecting data from \"transaction_actions\"."
input transaction_actions_order_by {
  action_kind: order_by
  args: order_by
  index_in_transaction: order_by
  transaction: transactions_order_by
  transaction_hash: order_by
}

"order by stddev() on columns of table \"transaction_actions\""
input transaction_actions_stddev_order_by {
  index_in_transaction: order_by
}

"order by stddev_pop() on columns of table \"transaction_actions\""
input transaction_actions_stddev_pop_order_by {
  index_in_transaction: order_by
}

"order by stddev_samp() on columns of table \"transaction_actions\""
input transaction_actions_stddev_samp_order_by {
  index_in_transaction: order_by
}

"order by sum() on columns of table \"transaction_actions\""
input transaction_actions_sum_order_by {
  index_in_transaction: order_by
}

"order by var_pop() on columns of table \"transaction_actions\""
input transaction_actions_var_pop_order_by {
  index_in_transaction: order_by
}

"order by var_samp() on columns of table \"transaction_actions\""
input transaction_actions_var_samp_order_by {
  index_in_transaction: order_by
}

"order by variance() on columns of table \"transaction_actions\""
input transaction_actions_variance_order_by {
  index_in_transaction: order_by
}

"order by aggregate values of table \"transactions\""
input transactions_aggregate_order_by {
  avg: transactions_avg_order_by
  count: order_by
  max: transactions_max_order_by
  min: transactions_min_order_by
  stddev: transactions_stddev_order_by
  stddev_pop: transactions_stddev_pop_order_by
  stddev_samp: transactions_stddev_samp_order_by
  sum: transactions_sum_order_by
  var_pop: transactions_var_pop_order_by
  var_samp: transactions_var_samp_order_by
  variance: transactions_variance_order_by
}

"order by avg() on columns of table \"transactions\""
input transactions_avg_order_by {
  block_timestamp: order_by
  index_in_chunk: order_by
  nonce: order_by
  receipt_conversion_gas_burnt: order_by
  receipt_conversion_tokens_burnt: order_by
}

"Boolean expression to filter rows from the table \"transactions\". All fields are combined with a logical 'AND'."
input transactions_bool_exp {
  _and: [transactions_bool_exp!]
  _not: transactions_bool_exp
  _or: [transactions_bool_exp!]
  block: blocks_bool_exp
  block_timestamp: numeric_comparison_exp
  chunk: chunks_bool_exp
  converted_into_receipt_id: String_comparison_exp
  included_in_block_hash: String_comparison_exp
  included_in_chunk_hash: String_comparison_exp
  index_in_chunk: Int_comparison_exp
  nonce: numeric_comparison_exp
  receipt_conversion_gas_burnt: numeric_comparison_exp
  receipt_conversion_tokens_burnt: numeric_comparison_exp
  receipts: receipts_bool_exp
  receiver_account_id: String_comparison_exp
  signature: String_comparison_exp
  signer_account_id: String_comparison_exp
  signer_public_key: String_comparison_exp
  status: execution_outcome_status_comparison_exp
  transaction_actions: transaction_actions_bool_exp
  transaction_hash: String_comparison_exp
}

"order by max() on columns of table \"transactions\""
input transactions_max_order_by {
  block_timestamp: order_by
  converted_into_receipt_id: order_by
  included_in_block_hash: order_by
  included_in_chunk_hash: order_by
  index_in_chunk: order_by
  nonce: order_by
  receipt_conversion_gas_burnt: order_by
  receipt_conversion_tokens_burnt: order_by
  receiver_account_id: order_by
  signature: order_by
  signer_account_id: order_by
  signer_public_key: order_by
  status: order_by
  transaction_hash: order_by
}

"order by min() on columns of table \"transactions\""
input transactions_min_order_by {
  block_timestamp: order_by
  converted_into_receipt_id: order_by
  included_in_block_hash: order_by
  included_in_chunk_hash: order_by
  index_in_chunk: order_by
  nonce: order_by
  receipt_conversion_gas_burnt: order_by
  receipt_conversion_tokens_burnt: order_by
  receiver_account_id: order_by
  signature: order_by
  signer_account_id: order_by
  signer_public_key: order_by
  status: order_by
  transaction_hash: order_by
}

"Ordering options when selecting data from \"transactions\"."
input transactions_order_by {
  block: blocks_order_by
  block_timestamp: order_by
  chunk: chunks_order_by
  converted_into_receipt_id: order_by
  included_in_block_hash: order_by
  included_in_chunk_hash: order_by
  index_in_chunk: order_by
  nonce: order_by
  receipt_conversion_gas_burnt: order_by
  receipt_conversion_tokens_burnt: order_by
  receipts_aggregate: receipts_aggregate_order_by
  receiver_account_id: order_by
  signature: order_by
  signer_account_id: order_by
  signer_public_key: order_by
  status: order_by
  transaction_actions_aggregate: transaction_actions_aggregate_order_by
  transaction_hash: order_by
}

"order by stddev() on columns of table \"transactions\""
input transactions_stddev_order_by {
  block_timestamp: order_by
  index_in_chunk: order_by
  nonce: order_by
  receipt_conversion_gas_burnt: order_by
  receipt_conversion_tokens_burnt: order_by
}

"order by stddev_pop() on columns of table \"transactions\""
input transactions_stddev_pop_order_by {
  block_timestamp: order_by
  index_in_chunk: order_by
  nonce: order_by
  receipt_conversion_gas_burnt: order_by
  receipt_conversion_tokens_burnt: order_by
}

"order by stddev_samp() on columns of table \"transactions\""
input transactions_stddev_samp_order_by {
  block_timestamp: order_by
  index_in_chunk: order_by
  nonce: order_by
  receipt_conversion_gas_burnt: order_by
  receipt_conversion_tokens_burnt: order_by
}

"order by sum() on columns of table \"transactions\""
input transactions_sum_order_by {
  block_timestamp: order_by
  index_in_chunk: order_by
  nonce: order_by
  receipt_conversion_gas_burnt: order_by
  receipt_conversion_tokens_burnt: order_by
}

"order by var_pop() on columns of table \"transactions\""
input transactions_var_pop_order_by {
  block_timestamp: order_by
  index_in_chunk: order_by
  nonce: order_by
  receipt_conversion_gas_burnt: order_by
  receipt_conversion_tokens_burnt: order_by
}

"order by var_samp() on columns of table \"transactions\""
input transactions_var_samp_order_by {
  block_timestamp: order_by
  index_in_chunk: order_by
  nonce: order_by
  receipt_conversion_gas_burnt: order_by
  receipt_conversion_tokens_burnt: order_by
}

"order by variance() on columns of table \"transactions\""
input transactions_variance_order_by {
  block_timestamp: order_by
  index_in_chunk: order_by
  nonce: order_by
  receipt_conversion_gas_burnt: order_by
  receipt_conversion_tokens_burnt: order_by
}
