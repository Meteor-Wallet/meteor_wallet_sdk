# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
  query: query_root
  subscription: subscription_root
}

"whether this query should be cached (Hasura Cloud only)"
directive @cached(
  "refresh the cache entry"
  refresh: Boolean! = false
  "measured in seconds"
  ttl: Int! = 60
) on QUERY

"columns and relationships of \"access_keys\""
type access_keys {
  account_id: String!
  "An object relationship"
  block: blocks
  created_by_receipt_id: String
  deleted_by_receipt_id: String
  last_update_block_height: numeric!
  permission_kind: access_key_permission_kind!
  public_key: String!
  "An object relationship"
  receipt: receipts
  "An object relationship"
  receiptByDeletedByReceiptId: receipts
}

"aggregated selection of \"access_keys\""
type access_keys_aggregate {
  aggregate: access_keys_aggregate_fields
  nodes: [access_keys!]!
}

"aggregate fields of \"access_keys\""
type access_keys_aggregate_fields {
  avg: access_keys_avg_fields
  count(columns: [access_keys_select_column!], distinct: Boolean): Int!
  max: access_keys_max_fields
  min: access_keys_min_fields
  stddev: access_keys_stddev_fields
  stddev_pop: access_keys_stddev_pop_fields
  stddev_samp: access_keys_stddev_samp_fields
  sum: access_keys_sum_fields
  var_pop: access_keys_var_pop_fields
  var_samp: access_keys_var_samp_fields
  variance: access_keys_variance_fields
}

"aggregate avg on columns"
type access_keys_avg_fields {
  last_update_block_height: Float
}

"aggregate max on columns"
type access_keys_max_fields {
  account_id: String
  created_by_receipt_id: String
  deleted_by_receipt_id: String
  last_update_block_height: numeric
  permission_kind: access_key_permission_kind
  public_key: String
}

"aggregate min on columns"
type access_keys_min_fields {
  account_id: String
  created_by_receipt_id: String
  deleted_by_receipt_id: String
  last_update_block_height: numeric
  permission_kind: access_key_permission_kind
  public_key: String
}

"aggregate stddev on columns"
type access_keys_stddev_fields {
  last_update_block_height: Float
}

"aggregate stddev_pop on columns"
type access_keys_stddev_pop_fields {
  last_update_block_height: Float
}

"aggregate stddev_samp on columns"
type access_keys_stddev_samp_fields {
  last_update_block_height: Float
}

"aggregate sum on columns"
type access_keys_sum_fields {
  last_update_block_height: numeric
}

"aggregate var_pop on columns"
type access_keys_var_pop_fields {
  last_update_block_height: Float
}

"aggregate var_samp on columns"
type access_keys_var_samp_fields {
  last_update_block_height: Float
}

"aggregate variance on columns"
type access_keys_variance_fields {
  last_update_block_height: Float
}

"columns and relationships of \"accounts\""
type accounts {
  account_id: String!
  created_by_receipt_id: String
  deleted_by_receipt_id: String
  id: bigint!
  last_update_block_height: numeric!
  "An object relationship"
  receipt: receipts
  "An object relationship"
  receiptByDeletedByReceiptId: receipts
}

"aggregated selection of \"accounts\""
type accounts_aggregate {
  aggregate: accounts_aggregate_fields
  nodes: [accounts!]!
}

"aggregate fields of \"accounts\""
type accounts_aggregate_fields {
  avg: accounts_avg_fields
  count(columns: [accounts_select_column!], distinct: Boolean): Int!
  max: accounts_max_fields
  min: accounts_min_fields
  stddev: accounts_stddev_fields
  stddev_pop: accounts_stddev_pop_fields
  stddev_samp: accounts_stddev_samp_fields
  sum: accounts_sum_fields
  var_pop: accounts_var_pop_fields
  var_samp: accounts_var_samp_fields
  variance: accounts_variance_fields
}

"aggregate avg on columns"
type accounts_avg_fields {
  id: Float
  last_update_block_height: Float
}

"aggregate max on columns"
type accounts_max_fields {
  account_id: String
  created_by_receipt_id: String
  deleted_by_receipt_id: String
  id: bigint
  last_update_block_height: numeric
}

"aggregate min on columns"
type accounts_min_fields {
  account_id: String
  created_by_receipt_id: String
  deleted_by_receipt_id: String
  id: bigint
  last_update_block_height: numeric
}

"aggregate stddev on columns"
type accounts_stddev_fields {
  id: Float
  last_update_block_height: Float
}

"aggregate stddev_pop on columns"
type accounts_stddev_pop_fields {
  id: Float
  last_update_block_height: Float
}

"aggregate stddev_samp on columns"
type accounts_stddev_samp_fields {
  id: Float
  last_update_block_height: Float
}

"aggregate sum on columns"
type accounts_sum_fields {
  id: bigint
  last_update_block_height: numeric
}

"aggregate var_pop on columns"
type accounts_var_pop_fields {
  id: Float
  last_update_block_height: Float
}

"aggregate var_samp on columns"
type accounts_var_samp_fields {
  id: Float
  last_update_block_height: Float
}

"aggregate variance on columns"
type accounts_variance_fields {
  id: Float
  last_update_block_height: Float
}

"columns and relationships of \"action_receipt_actions\""
type action_receipt_actions {
  action_kind: action_kind!
  args("JSON select path" path: String): jsonb!
  index_in_action_receipt: Int!
  "An object relationship"
  receipt: receipts!
  receipt_id: String!
  receipt_included_in_block_timestamp: numeric!
  receipt_predecessor_account_id: String!
  receipt_receiver_account_id: String!
}

"aggregated selection of \"action_receipt_actions\""
type action_receipt_actions_aggregate {
  aggregate: action_receipt_actions_aggregate_fields
  nodes: [action_receipt_actions!]!
}

"aggregate fields of \"action_receipt_actions\""
type action_receipt_actions_aggregate_fields {
  avg: action_receipt_actions_avg_fields
  count(columns: [action_receipt_actions_select_column!], distinct: Boolean): Int!
  max: action_receipt_actions_max_fields
  min: action_receipt_actions_min_fields
  stddev: action_receipt_actions_stddev_fields
  stddev_pop: action_receipt_actions_stddev_pop_fields
  stddev_samp: action_receipt_actions_stddev_samp_fields
  sum: action_receipt_actions_sum_fields
  var_pop: action_receipt_actions_var_pop_fields
  var_samp: action_receipt_actions_var_samp_fields
  variance: action_receipt_actions_variance_fields
}

"aggregate avg on columns"
type action_receipt_actions_avg_fields {
  index_in_action_receipt: Float
  receipt_included_in_block_timestamp: Float
}

"aggregate max on columns"
type action_receipt_actions_max_fields {
  action_kind: action_kind
  index_in_action_receipt: Int
  receipt_id: String
  receipt_included_in_block_timestamp: numeric
  receipt_predecessor_account_id: String
  receipt_receiver_account_id: String
}

"aggregate min on columns"
type action_receipt_actions_min_fields {
  action_kind: action_kind
  index_in_action_receipt: Int
  receipt_id: String
  receipt_included_in_block_timestamp: numeric
  receipt_predecessor_account_id: String
  receipt_receiver_account_id: String
}

"aggregate stddev on columns"
type action_receipt_actions_stddev_fields {
  index_in_action_receipt: Float
  receipt_included_in_block_timestamp: Float
}

"aggregate stddev_pop on columns"
type action_receipt_actions_stddev_pop_fields {
  index_in_action_receipt: Float
  receipt_included_in_block_timestamp: Float
}

"aggregate stddev_samp on columns"
type action_receipt_actions_stddev_samp_fields {
  index_in_action_receipt: Float
  receipt_included_in_block_timestamp: Float
}

"aggregate sum on columns"
type action_receipt_actions_sum_fields {
  index_in_action_receipt: Int
  receipt_included_in_block_timestamp: numeric
}

"aggregate var_pop on columns"
type action_receipt_actions_var_pop_fields {
  index_in_action_receipt: Float
  receipt_included_in_block_timestamp: Float
}

"aggregate var_samp on columns"
type action_receipt_actions_var_samp_fields {
  index_in_action_receipt: Float
  receipt_included_in_block_timestamp: Float
}

"aggregate variance on columns"
type action_receipt_actions_variance_fields {
  index_in_action_receipt: Float
  receipt_included_in_block_timestamp: Float
}

"columns and relationships of \"assets__fungible_token_events\""
type assets__fungible_token_events {
  amount: String!
  emitted_at_block_timestamp: numeric!
  emitted_by_contract_account_id: String!
  emitted_for_event_type: Int!
  emitted_for_receipt_id: String!
  emitted_in_shard_id: numeric!
  emitted_index_of_event_entry_in_shard: Int!
  event_kind: ft_event_kind!
  event_memo: String!
  "An object relationship"
  ft_meta: ft_meta
  "An object relationship"
  receipt: receipts!
  token_new_owner_account_id: String!
  token_old_owner_account_id: String!
}

"aggregated selection of \"assets__fungible_token_events\""
type assets__fungible_token_events_aggregate {
  aggregate: assets__fungible_token_events_aggregate_fields
  nodes: [assets__fungible_token_events!]!
}

"aggregate fields of \"assets__fungible_token_events\""
type assets__fungible_token_events_aggregate_fields {
  avg: assets__fungible_token_events_avg_fields
  count(columns: [assets__fungible_token_events_select_column!], distinct: Boolean): Int!
  max: assets__fungible_token_events_max_fields
  min: assets__fungible_token_events_min_fields
  stddev: assets__fungible_token_events_stddev_fields
  stddev_pop: assets__fungible_token_events_stddev_pop_fields
  stddev_samp: assets__fungible_token_events_stddev_samp_fields
  sum: assets__fungible_token_events_sum_fields
  var_pop: assets__fungible_token_events_var_pop_fields
  var_samp: assets__fungible_token_events_var_samp_fields
  variance: assets__fungible_token_events_variance_fields
}

"aggregate avg on columns"
type assets__fungible_token_events_avg_fields {
  emitted_at_block_timestamp: Float
  emitted_for_event_type: Float
  emitted_in_shard_id: Float
  emitted_index_of_event_entry_in_shard: Float
}

"aggregate max on columns"
type assets__fungible_token_events_max_fields {
  amount: String
  emitted_at_block_timestamp: numeric
  emitted_by_contract_account_id: String
  emitted_for_event_type: Int
  emitted_for_receipt_id: String
  emitted_in_shard_id: numeric
  emitted_index_of_event_entry_in_shard: Int
  event_kind: ft_event_kind
  event_memo: String
  token_new_owner_account_id: String
  token_old_owner_account_id: String
}

"aggregate min on columns"
type assets__fungible_token_events_min_fields {
  amount: String
  emitted_at_block_timestamp: numeric
  emitted_by_contract_account_id: String
  emitted_for_event_type: Int
  emitted_for_receipt_id: String
  emitted_in_shard_id: numeric
  emitted_index_of_event_entry_in_shard: Int
  event_kind: ft_event_kind
  event_memo: String
  token_new_owner_account_id: String
  token_old_owner_account_id: String
}

"aggregate stddev on columns"
type assets__fungible_token_events_stddev_fields {
  emitted_at_block_timestamp: Float
  emitted_for_event_type: Float
  emitted_in_shard_id: Float
  emitted_index_of_event_entry_in_shard: Float
}

"aggregate stddev_pop on columns"
type assets__fungible_token_events_stddev_pop_fields {
  emitted_at_block_timestamp: Float
  emitted_for_event_type: Float
  emitted_in_shard_id: Float
  emitted_index_of_event_entry_in_shard: Float
}

"aggregate stddev_samp on columns"
type assets__fungible_token_events_stddev_samp_fields {
  emitted_at_block_timestamp: Float
  emitted_for_event_type: Float
  emitted_in_shard_id: Float
  emitted_index_of_event_entry_in_shard: Float
}

"aggregate sum on columns"
type assets__fungible_token_events_sum_fields {
  emitted_at_block_timestamp: numeric
  emitted_for_event_type: Int
  emitted_in_shard_id: numeric
  emitted_index_of_event_entry_in_shard: Int
}

"aggregate var_pop on columns"
type assets__fungible_token_events_var_pop_fields {
  emitted_at_block_timestamp: Float
  emitted_for_event_type: Float
  emitted_in_shard_id: Float
  emitted_index_of_event_entry_in_shard: Float
}

"aggregate var_samp on columns"
type assets__fungible_token_events_var_samp_fields {
  emitted_at_block_timestamp: Float
  emitted_for_event_type: Float
  emitted_in_shard_id: Float
  emitted_index_of_event_entry_in_shard: Float
}

"aggregate variance on columns"
type assets__fungible_token_events_variance_fields {
  emitted_at_block_timestamp: Float
  emitted_for_event_type: Float
  emitted_in_shard_id: Float
  emitted_index_of_event_entry_in_shard: Float
}

"columns and relationships of \"assets__non_fungible_token_events\""
type assets__non_fungible_token_events {
  emitted_at_block_timestamp: numeric!
  emitted_by_contract_account_id: String!
  emitted_for_event_type: Int!
  emitted_for_receipt_id: String!
  emitted_in_shard_id: numeric!
  emitted_index_of_event_entry_in_shard: Int!
  event_kind: nft_event_kind!
  event_memo: String!
  "An object relationship"
  nft_meta: nft_meta
  "An object relationship"
  nft_token_meta: nft_token_meta
  "An object relationship"
  receipt: receipts!
  token_authorized_account_id: String!
  token_id: String!
  token_new_owner_account_id: String!
  token_old_owner_account_id: String!
}

"aggregated selection of \"assets__non_fungible_token_events\""
type assets__non_fungible_token_events_aggregate {
  aggregate: assets__non_fungible_token_events_aggregate_fields
  nodes: [assets__non_fungible_token_events!]!
}

"aggregate fields of \"assets__non_fungible_token_events\""
type assets__non_fungible_token_events_aggregate_fields {
  avg: assets__non_fungible_token_events_avg_fields
  count(columns: [assets__non_fungible_token_events_select_column!], distinct: Boolean): Int!
  max: assets__non_fungible_token_events_max_fields
  min: assets__non_fungible_token_events_min_fields
  stddev: assets__non_fungible_token_events_stddev_fields
  stddev_pop: assets__non_fungible_token_events_stddev_pop_fields
  stddev_samp: assets__non_fungible_token_events_stddev_samp_fields
  sum: assets__non_fungible_token_events_sum_fields
  var_pop: assets__non_fungible_token_events_var_pop_fields
  var_samp: assets__non_fungible_token_events_var_samp_fields
  variance: assets__non_fungible_token_events_variance_fields
}

"aggregate avg on columns"
type assets__non_fungible_token_events_avg_fields {
  emitted_at_block_timestamp: Float
  emitted_for_event_type: Float
  emitted_in_shard_id: Float
  emitted_index_of_event_entry_in_shard: Float
}

"aggregate max on columns"
type assets__non_fungible_token_events_max_fields {
  emitted_at_block_timestamp: numeric
  emitted_by_contract_account_id: String
  emitted_for_event_type: Int
  emitted_for_receipt_id: String
  emitted_in_shard_id: numeric
  emitted_index_of_event_entry_in_shard: Int
  event_kind: nft_event_kind
  event_memo: String
  token_authorized_account_id: String
  token_id: String
  token_new_owner_account_id: String
  token_old_owner_account_id: String
}

"aggregate min on columns"
type assets__non_fungible_token_events_min_fields {
  emitted_at_block_timestamp: numeric
  emitted_by_contract_account_id: String
  emitted_for_event_type: Int
  emitted_for_receipt_id: String
  emitted_in_shard_id: numeric
  emitted_index_of_event_entry_in_shard: Int
  event_kind: nft_event_kind
  event_memo: String
  token_authorized_account_id: String
  token_id: String
  token_new_owner_account_id: String
  token_old_owner_account_id: String
}

"aggregate stddev on columns"
type assets__non_fungible_token_events_stddev_fields {
  emitted_at_block_timestamp: Float
  emitted_for_event_type: Float
  emitted_in_shard_id: Float
  emitted_index_of_event_entry_in_shard: Float
}

"aggregate stddev_pop on columns"
type assets__non_fungible_token_events_stddev_pop_fields {
  emitted_at_block_timestamp: Float
  emitted_for_event_type: Float
  emitted_in_shard_id: Float
  emitted_index_of_event_entry_in_shard: Float
}

"aggregate stddev_samp on columns"
type assets__non_fungible_token_events_stddev_samp_fields {
  emitted_at_block_timestamp: Float
  emitted_for_event_type: Float
  emitted_in_shard_id: Float
  emitted_index_of_event_entry_in_shard: Float
}

"aggregate sum on columns"
type assets__non_fungible_token_events_sum_fields {
  emitted_at_block_timestamp: numeric
  emitted_for_event_type: Int
  emitted_in_shard_id: numeric
  emitted_index_of_event_entry_in_shard: Int
}

"aggregate var_pop on columns"
type assets__non_fungible_token_events_var_pop_fields {
  emitted_at_block_timestamp: Float
  emitted_for_event_type: Float
  emitted_in_shard_id: Float
  emitted_index_of_event_entry_in_shard: Float
}

"aggregate var_samp on columns"
type assets__non_fungible_token_events_var_samp_fields {
  emitted_at_block_timestamp: Float
  emitted_for_event_type: Float
  emitted_in_shard_id: Float
  emitted_index_of_event_entry_in_shard: Float
}

"aggregate variance on columns"
type assets__non_fungible_token_events_variance_fields {
  emitted_at_block_timestamp: Float
  emitted_for_event_type: Float
  emitted_in_shard_id: Float
  emitted_index_of_event_entry_in_shard: Float
}

"columns and relationships of \"blocks\""
type blocks {
  author_account_id: String!
  block_hash: String!
  block_height: numeric!
  block_timestamp: numeric!
  "An array relationship"
  chunks(
    "distinct select on columns"
    distinct_on: [chunks_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [chunks_order_by!]
    "filter the rows returned"
    where: chunks_bool_exp
  ): [chunks!]!
  "An aggregate relationship"
  chunks_aggregate(
    "distinct select on columns"
    distinct_on: [chunks_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [chunks_order_by!]
    "filter the rows returned"
    where: chunks_bool_exp
  ): chunks_aggregate!
  "An array relationship"
  execution_outcomes(
    "distinct select on columns"
    distinct_on: [execution_outcomes_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [execution_outcomes_order_by!]
    "filter the rows returned"
    where: execution_outcomes_bool_exp
  ): [execution_outcomes!]!
  "An aggregate relationship"
  execution_outcomes_aggregate(
    "distinct select on columns"
    distinct_on: [execution_outcomes_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [execution_outcomes_order_by!]
    "filter the rows returned"
    where: execution_outcomes_bool_exp
  ): execution_outcomes_aggregate!
  gas_price: numeric!
  prev_block_hash: String!
  "An array relationship"
  receipts(
    "distinct select on columns"
    distinct_on: [receipts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [receipts_order_by!]
    "filter the rows returned"
    where: receipts_bool_exp
  ): [receipts!]!
  "An aggregate relationship"
  receipts_aggregate(
    "distinct select on columns"
    distinct_on: [receipts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [receipts_order_by!]
    "filter the rows returned"
    where: receipts_bool_exp
  ): receipts_aggregate!
  total_supply: numeric!
  "An array relationship"
  transactions(
    "distinct select on columns"
    distinct_on: [transactions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [transactions_order_by!]
    "filter the rows returned"
    where: transactions_bool_exp
  ): [transactions!]!
  "An aggregate relationship"
  transactions_aggregate(
    "distinct select on columns"
    distinct_on: [transactions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [transactions_order_by!]
    "filter the rows returned"
    where: transactions_bool_exp
  ): transactions_aggregate!
}

"aggregated selection of \"blocks\""
type blocks_aggregate {
  aggregate: blocks_aggregate_fields
  nodes: [blocks!]!
}

"aggregate fields of \"blocks\""
type blocks_aggregate_fields {
  avg: blocks_avg_fields
  count(columns: [blocks_select_column!], distinct: Boolean): Int!
  max: blocks_max_fields
  min: blocks_min_fields
  stddev: blocks_stddev_fields
  stddev_pop: blocks_stddev_pop_fields
  stddev_samp: blocks_stddev_samp_fields
  sum: blocks_sum_fields
  var_pop: blocks_var_pop_fields
  var_samp: blocks_var_samp_fields
  variance: blocks_variance_fields
}

"aggregate avg on columns"
type blocks_avg_fields {
  block_height: Float
  block_timestamp: Float
  gas_price: Float
  total_supply: Float
}

"aggregate max on columns"
type blocks_max_fields {
  author_account_id: String
  block_hash: String
  block_height: numeric
  block_timestamp: numeric
  gas_price: numeric
  prev_block_hash: String
  total_supply: numeric
}

"aggregate min on columns"
type blocks_min_fields {
  author_account_id: String
  block_hash: String
  block_height: numeric
  block_timestamp: numeric
  gas_price: numeric
  prev_block_hash: String
  total_supply: numeric
}

"aggregate stddev on columns"
type blocks_stddev_fields {
  block_height: Float
  block_timestamp: Float
  gas_price: Float
  total_supply: Float
}

"aggregate stddev_pop on columns"
type blocks_stddev_pop_fields {
  block_height: Float
  block_timestamp: Float
  gas_price: Float
  total_supply: Float
}

"aggregate stddev_samp on columns"
type blocks_stddev_samp_fields {
  block_height: Float
  block_timestamp: Float
  gas_price: Float
  total_supply: Float
}

"aggregate sum on columns"
type blocks_sum_fields {
  block_height: numeric
  block_timestamp: numeric
  gas_price: numeric
  total_supply: numeric
}

"aggregate var_pop on columns"
type blocks_var_pop_fields {
  block_height: Float
  block_timestamp: Float
  gas_price: Float
  total_supply: Float
}

"aggregate var_samp on columns"
type blocks_var_samp_fields {
  block_height: Float
  block_timestamp: Float
  gas_price: Float
  total_supply: Float
}

"aggregate variance on columns"
type blocks_variance_fields {
  block_height: Float
  block_timestamp: Float
  gas_price: Float
  total_supply: Float
}

"columns and relationships of \"chunks\""
type chunks {
  author_account_id: String!
  "An object relationship"
  block: blocks!
  chunk_hash: String!
  gas_limit: numeric!
  gas_used: numeric!
  included_in_block_hash: String!
  "An array relationship"
  receipts(
    "distinct select on columns"
    distinct_on: [receipts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [receipts_order_by!]
    "filter the rows returned"
    where: receipts_bool_exp
  ): [receipts!]!
  "An aggregate relationship"
  receipts_aggregate(
    "distinct select on columns"
    distinct_on: [receipts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [receipts_order_by!]
    "filter the rows returned"
    where: receipts_bool_exp
  ): receipts_aggregate!
  shard_id: numeric!
  signature: String!
  "An array relationship"
  transactions(
    "distinct select on columns"
    distinct_on: [transactions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [transactions_order_by!]
    "filter the rows returned"
    where: transactions_bool_exp
  ): [transactions!]!
  "An aggregate relationship"
  transactions_aggregate(
    "distinct select on columns"
    distinct_on: [transactions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [transactions_order_by!]
    "filter the rows returned"
    where: transactions_bool_exp
  ): transactions_aggregate!
}

"aggregated selection of \"chunks\""
type chunks_aggregate {
  aggregate: chunks_aggregate_fields
  nodes: [chunks!]!
}

"aggregate fields of \"chunks\""
type chunks_aggregate_fields {
  avg: chunks_avg_fields
  count(columns: [chunks_select_column!], distinct: Boolean): Int!
  max: chunks_max_fields
  min: chunks_min_fields
  stddev: chunks_stddev_fields
  stddev_pop: chunks_stddev_pop_fields
  stddev_samp: chunks_stddev_samp_fields
  sum: chunks_sum_fields
  var_pop: chunks_var_pop_fields
  var_samp: chunks_var_samp_fields
  variance: chunks_variance_fields
}

"aggregate avg on columns"
type chunks_avg_fields {
  gas_limit: Float
  gas_used: Float
  shard_id: Float
}

"aggregate max on columns"
type chunks_max_fields {
  author_account_id: String
  chunk_hash: String
  gas_limit: numeric
  gas_used: numeric
  included_in_block_hash: String
  shard_id: numeric
  signature: String
}

"aggregate min on columns"
type chunks_min_fields {
  author_account_id: String
  chunk_hash: String
  gas_limit: numeric
  gas_used: numeric
  included_in_block_hash: String
  shard_id: numeric
  signature: String
}

"aggregate stddev on columns"
type chunks_stddev_fields {
  gas_limit: Float
  gas_used: Float
  shard_id: Float
}

"aggregate stddev_pop on columns"
type chunks_stddev_pop_fields {
  gas_limit: Float
  gas_used: Float
  shard_id: Float
}

"aggregate stddev_samp on columns"
type chunks_stddev_samp_fields {
  gas_limit: Float
  gas_used: Float
  shard_id: Float
}

"aggregate sum on columns"
type chunks_sum_fields {
  gas_limit: numeric
  gas_used: numeric
  shard_id: numeric
}

"aggregate var_pop on columns"
type chunks_var_pop_fields {
  gas_limit: Float
  gas_used: Float
  shard_id: Float
}

"aggregate var_samp on columns"
type chunks_var_samp_fields {
  gas_limit: Float
  gas_used: Float
  shard_id: Float
}

"aggregate variance on columns"
type chunks_variance_fields {
  gas_limit: Float
  gas_used: Float
  shard_id: Float
}

"columns and relationships of \"daily_stats\""
type daily_stats {
  addresses: numeric!
  avg_gas_limit: numeric!
  avg_gas_price: numeric!
  blocks: numeric!
  date: date!
  gas_fee: numeric!
  gas_used: numeric!
  market_cap: numeric!
  near_price: numeric!
  total_addresses: numeric!
  total_supply: numeric!
  txn_fee: numeric!
  txn_fee_usd: numeric!
  txn_volume: numeric!
  txn_volume_usd: numeric!
  txns: numeric!
}

"aggregated selection of \"daily_stats\""
type daily_stats_aggregate {
  aggregate: daily_stats_aggregate_fields
  nodes: [daily_stats!]!
}

"aggregate fields of \"daily_stats\""
type daily_stats_aggregate_fields {
  avg: daily_stats_avg_fields
  count(columns: [daily_stats_select_column!], distinct: Boolean): Int!
  max: daily_stats_max_fields
  min: daily_stats_min_fields
  stddev: daily_stats_stddev_fields
  stddev_pop: daily_stats_stddev_pop_fields
  stddev_samp: daily_stats_stddev_samp_fields
  sum: daily_stats_sum_fields
  var_pop: daily_stats_var_pop_fields
  var_samp: daily_stats_var_samp_fields
  variance: daily_stats_variance_fields
}

"aggregate avg on columns"
type daily_stats_avg_fields {
  addresses: Float
  avg_gas_limit: Float
  avg_gas_price: Float
  blocks: Float
  gas_fee: Float
  gas_used: Float
  market_cap: Float
  near_price: Float
  total_addresses: Float
  total_supply: Float
  txn_fee: Float
  txn_fee_usd: Float
  txn_volume: Float
  txn_volume_usd: Float
  txns: Float
}

"aggregate max on columns"
type daily_stats_max_fields {
  addresses: numeric
  avg_gas_limit: numeric
  avg_gas_price: numeric
  blocks: numeric
  date: date
  gas_fee: numeric
  gas_used: numeric
  market_cap: numeric
  near_price: numeric
  total_addresses: numeric
  total_supply: numeric
  txn_fee: numeric
  txn_fee_usd: numeric
  txn_volume: numeric
  txn_volume_usd: numeric
  txns: numeric
}

"aggregate min on columns"
type daily_stats_min_fields {
  addresses: numeric
  avg_gas_limit: numeric
  avg_gas_price: numeric
  blocks: numeric
  date: date
  gas_fee: numeric
  gas_used: numeric
  market_cap: numeric
  near_price: numeric
  total_addresses: numeric
  total_supply: numeric
  txn_fee: numeric
  txn_fee_usd: numeric
  txn_volume: numeric
  txn_volume_usd: numeric
  txns: numeric
}

"aggregate stddev on columns"
type daily_stats_stddev_fields {
  addresses: Float
  avg_gas_limit: Float
  avg_gas_price: Float
  blocks: Float
  gas_fee: Float
  gas_used: Float
  market_cap: Float
  near_price: Float
  total_addresses: Float
  total_supply: Float
  txn_fee: Float
  txn_fee_usd: Float
  txn_volume: Float
  txn_volume_usd: Float
  txns: Float
}

"aggregate stddev_pop on columns"
type daily_stats_stddev_pop_fields {
  addresses: Float
  avg_gas_limit: Float
  avg_gas_price: Float
  blocks: Float
  gas_fee: Float
  gas_used: Float
  market_cap: Float
  near_price: Float
  total_addresses: Float
  total_supply: Float
  txn_fee: Float
  txn_fee_usd: Float
  txn_volume: Float
  txn_volume_usd: Float
  txns: Float
}

"aggregate stddev_samp on columns"
type daily_stats_stddev_samp_fields {
  addresses: Float
  avg_gas_limit: Float
  avg_gas_price: Float
  blocks: Float
  gas_fee: Float
  gas_used: Float
  market_cap: Float
  near_price: Float
  total_addresses: Float
  total_supply: Float
  txn_fee: Float
  txn_fee_usd: Float
  txn_volume: Float
  txn_volume_usd: Float
  txns: Float
}

"aggregate sum on columns"
type daily_stats_sum_fields {
  addresses: numeric
  avg_gas_limit: numeric
  avg_gas_price: numeric
  blocks: numeric
  gas_fee: numeric
  gas_used: numeric
  market_cap: numeric
  near_price: numeric
  total_addresses: numeric
  total_supply: numeric
  txn_fee: numeric
  txn_fee_usd: numeric
  txn_volume: numeric
  txn_volume_usd: numeric
  txns: numeric
}

"aggregate var_pop on columns"
type daily_stats_var_pop_fields {
  addresses: Float
  avg_gas_limit: Float
  avg_gas_price: Float
  blocks: Float
  gas_fee: Float
  gas_used: Float
  market_cap: Float
  near_price: Float
  total_addresses: Float
  total_supply: Float
  txn_fee: Float
  txn_fee_usd: Float
  txn_volume: Float
  txn_volume_usd: Float
  txns: Float
}

"aggregate var_samp on columns"
type daily_stats_var_samp_fields {
  addresses: Float
  avg_gas_limit: Float
  avg_gas_price: Float
  blocks: Float
  gas_fee: Float
  gas_used: Float
  market_cap: Float
  near_price: Float
  total_addresses: Float
  total_supply: Float
  txn_fee: Float
  txn_fee_usd: Float
  txn_volume: Float
  txn_volume_usd: Float
  txns: Float
}

"aggregate variance on columns"
type daily_stats_variance_fields {
  addresses: Float
  avg_gas_limit: Float
  avg_gas_price: Float
  blocks: Float
  gas_fee: Float
  gas_used: Float
  market_cap: Float
  near_price: Float
  total_addresses: Float
  total_supply: Float
  txn_fee: Float
  txn_fee_usd: Float
  txn_volume: Float
  txn_volume_usd: Float
  txns: Float
}

"columns and relationships of \"execution_outcomes\""
type execution_outcomes {
  "An object relationship"
  block: blocks!
  executed_in_block_hash: String!
  executed_in_block_timestamp: numeric!
  executor_account_id: String!
  gas_burnt: numeric!
  index_in_chunk: Int!
  logs("JSON select path" path: String): jsonb!
  "An object relationship"
  receipt: receipts!
  receipt_id: String!
  shard_id: numeric!
  status: execution_outcome_status!
  tokens_burnt: numeric!
}

"aggregated selection of \"execution_outcomes\""
type execution_outcomes_aggregate {
  aggregate: execution_outcomes_aggregate_fields
  nodes: [execution_outcomes!]!
}

"aggregate fields of \"execution_outcomes\""
type execution_outcomes_aggregate_fields {
  avg: execution_outcomes_avg_fields
  count(columns: [execution_outcomes_select_column!], distinct: Boolean): Int!
  max: execution_outcomes_max_fields
  min: execution_outcomes_min_fields
  stddev: execution_outcomes_stddev_fields
  stddev_pop: execution_outcomes_stddev_pop_fields
  stddev_samp: execution_outcomes_stddev_samp_fields
  sum: execution_outcomes_sum_fields
  var_pop: execution_outcomes_var_pop_fields
  var_samp: execution_outcomes_var_samp_fields
  variance: execution_outcomes_variance_fields
}

"aggregate avg on columns"
type execution_outcomes_avg_fields {
  executed_in_block_timestamp: Float
  gas_burnt: Float
  index_in_chunk: Float
  shard_id: Float
  tokens_burnt: Float
}

"aggregate max on columns"
type execution_outcomes_max_fields {
  executed_in_block_hash: String
  executed_in_block_timestamp: numeric
  executor_account_id: String
  gas_burnt: numeric
  index_in_chunk: Int
  receipt_id: String
  shard_id: numeric
  status: execution_outcome_status
  tokens_burnt: numeric
}

"aggregate min on columns"
type execution_outcomes_min_fields {
  executed_in_block_hash: String
  executed_in_block_timestamp: numeric
  executor_account_id: String
  gas_burnt: numeric
  index_in_chunk: Int
  receipt_id: String
  shard_id: numeric
  status: execution_outcome_status
  tokens_burnt: numeric
}

"aggregate stddev on columns"
type execution_outcomes_stddev_fields {
  executed_in_block_timestamp: Float
  gas_burnt: Float
  index_in_chunk: Float
  shard_id: Float
  tokens_burnt: Float
}

"aggregate stddev_pop on columns"
type execution_outcomes_stddev_pop_fields {
  executed_in_block_timestamp: Float
  gas_burnt: Float
  index_in_chunk: Float
  shard_id: Float
  tokens_burnt: Float
}

"aggregate stddev_samp on columns"
type execution_outcomes_stddev_samp_fields {
  executed_in_block_timestamp: Float
  gas_burnt: Float
  index_in_chunk: Float
  shard_id: Float
  tokens_burnt: Float
}

"aggregate sum on columns"
type execution_outcomes_sum_fields {
  executed_in_block_timestamp: numeric
  gas_burnt: numeric
  index_in_chunk: Int
  shard_id: numeric
  tokens_burnt: numeric
}

"aggregate var_pop on columns"
type execution_outcomes_var_pop_fields {
  executed_in_block_timestamp: Float
  gas_burnt: Float
  index_in_chunk: Float
  shard_id: Float
  tokens_burnt: Float
}

"aggregate var_samp on columns"
type execution_outcomes_var_samp_fields {
  executed_in_block_timestamp: Float
  gas_burnt: Float
  index_in_chunk: Float
  shard_id: Float
  tokens_burnt: Float
}

"aggregate variance on columns"
type execution_outcomes_variance_fields {
  executed_in_block_timestamp: Float
  gas_burnt: Float
  index_in_chunk: Float
  shard_id: Float
  tokens_burnt: Float
}

"columns and relationships of \"fn_ft_amount\""
type fn_ft_amount {
  account: String!
  amount: numeric
  contract: String!
  "An object relationship"
  ft_meta: ft_meta
  rank: bigint
}

"columns and relationships of \"fn_ft_count\""
type fn_ft_count {
  contract: String!
  count: bigint
  "An object relationship"
  ft_meta: ft_meta
}

"columns and relationships of \"fn_nft_amount\""
type fn_nft_amount {
  account: String!
  contract: String!
  "An object relationship"
  nft_meta: nft_meta
  quantity: numeric
  rank: bigint
}

"aggregated selection of \"fn_nft_amount\""
type fn_nft_amount_aggregate {
  aggregate: fn_nft_amount_aggregate_fields
  nodes: [fn_nft_amount!]!
}

"aggregate fields of \"fn_nft_amount\""
type fn_nft_amount_aggregate_fields {
  avg: fn_nft_amount_avg_fields
  count(columns: [fn_nft_amount_select_column!], distinct: Boolean): Int!
  max: fn_nft_amount_max_fields
  min: fn_nft_amount_min_fields
  stddev: fn_nft_amount_stddev_fields
  stddev_pop: fn_nft_amount_stddev_pop_fields
  stddev_samp: fn_nft_amount_stddev_samp_fields
  sum: fn_nft_amount_sum_fields
  var_pop: fn_nft_amount_var_pop_fields
  var_samp: fn_nft_amount_var_samp_fields
  variance: fn_nft_amount_variance_fields
}

"aggregate avg on columns"
type fn_nft_amount_avg_fields {
  quantity: Float
  rank: Float
}

"aggregate max on columns"
type fn_nft_amount_max_fields {
  account: String
  contract: String
  quantity: numeric
  rank: bigint
}

"aggregate min on columns"
type fn_nft_amount_min_fields {
  account: String
  contract: String
  quantity: numeric
  rank: bigint
}

"aggregate stddev on columns"
type fn_nft_amount_stddev_fields {
  quantity: Float
  rank: Float
}

"aggregate stddev_pop on columns"
type fn_nft_amount_stddev_pop_fields {
  quantity: Float
  rank: Float
}

"aggregate stddev_samp on columns"
type fn_nft_amount_stddev_samp_fields {
  quantity: Float
  rank: Float
}

"aggregate sum on columns"
type fn_nft_amount_sum_fields {
  quantity: numeric
  rank: bigint
}

"aggregate var_pop on columns"
type fn_nft_amount_var_pop_fields {
  quantity: Float
  rank: Float
}

"aggregate var_samp on columns"
type fn_nft_amount_var_samp_fields {
  quantity: Float
  rank: Float
}

"aggregate variance on columns"
type fn_nft_amount_variance_fields {
  quantity: Float
  rank: Float
}

"columns and relationships of \"fn_nft_count\""
type fn_nft_count {
  contract: String!
  count: bigint
  "An object relationship"
  nft_meta: nft_meta
}

"columns and relationships of \"ft_list\""
type ft_list {
  change_24: numeric
  contract: String
  "An object relationship"
  ft_meta: ft_meta
  holders: bigint
  market_cap: numeric
  name: String
  price: numeric
  symbol: String
  total_supply: numeric
  transfers: bigint
  volume_24h: numeric
}

"aggregated selection of \"ft_list\""
type ft_list_aggregate {
  aggregate: ft_list_aggregate_fields
  nodes: [ft_list!]!
}

"aggregate fields of \"ft_list\""
type ft_list_aggregate_fields {
  avg: ft_list_avg_fields
  count(columns: [ft_list_select_column!], distinct: Boolean): Int!
  max: ft_list_max_fields
  min: ft_list_min_fields
  stddev: ft_list_stddev_fields
  stddev_pop: ft_list_stddev_pop_fields
  stddev_samp: ft_list_stddev_samp_fields
  sum: ft_list_sum_fields
  var_pop: ft_list_var_pop_fields
  var_samp: ft_list_var_samp_fields
  variance: ft_list_variance_fields
}

"aggregate avg on columns"
type ft_list_avg_fields {
  change_24: Float
  holders: Float
  market_cap: Float
  price: Float
  total_supply: Float
  transfers: Float
  volume_24h: Float
}

"aggregate max on columns"
type ft_list_max_fields {
  change_24: numeric
  contract: String
  holders: bigint
  market_cap: numeric
  name: String
  price: numeric
  symbol: String
  total_supply: numeric
  transfers: bigint
  volume_24h: numeric
}

"aggregate min on columns"
type ft_list_min_fields {
  change_24: numeric
  contract: String
  holders: bigint
  market_cap: numeric
  name: String
  price: numeric
  symbol: String
  total_supply: numeric
  transfers: bigint
  volume_24h: numeric
}

"aggregate stddev on columns"
type ft_list_stddev_fields {
  change_24: Float
  holders: Float
  market_cap: Float
  price: Float
  total_supply: Float
  transfers: Float
  volume_24h: Float
}

"aggregate stddev_pop on columns"
type ft_list_stddev_pop_fields {
  change_24: Float
  holders: Float
  market_cap: Float
  price: Float
  total_supply: Float
  transfers: Float
  volume_24h: Float
}

"aggregate stddev_samp on columns"
type ft_list_stddev_samp_fields {
  change_24: Float
  holders: Float
  market_cap: Float
  price: Float
  total_supply: Float
  transfers: Float
  volume_24h: Float
}

"aggregate sum on columns"
type ft_list_sum_fields {
  change_24: numeric
  holders: bigint
  market_cap: numeric
  price: numeric
  total_supply: numeric
  transfers: bigint
  volume_24h: numeric
}

"aggregate var_pop on columns"
type ft_list_var_pop_fields {
  change_24: Float
  holders: Float
  market_cap: Float
  price: Float
  total_supply: Float
  transfers: Float
  volume_24h: Float
}

"aggregate var_samp on columns"
type ft_list_var_samp_fields {
  change_24: Float
  holders: Float
  market_cap: Float
  price: Float
  total_supply: Float
  transfers: Float
  volume_24h: Float
}

"aggregate variance on columns"
type ft_list_variance_fields {
  change_24: Float
  holders: Float
  market_cap: Float
  price: Float
  total_supply: Float
  transfers: Float
  volume_24h: Float
}

"columns and relationships of \"ft_meta\""
type ft_meta {
  "An array relationship"
  assets__fungible_token_events(
    "distinct select on columns"
    distinct_on: [assets__fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__fungible_token_events_bool_exp
  ): [assets__fungible_token_events!]!
  "An aggregate relationship"
  assets__fungible_token_events_aggregate(
    "distinct select on columns"
    distinct_on: [assets__fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__fungible_token_events_bool_exp
  ): assets__fungible_token_events_aggregate!
  change_24: numeric
  circulating_supply: numeric
  coingecko_id: String
  coinmarketcap_id: String
  contract: String!
  decimals: Int!
  description: String
  facebook: String
  "An object relationship"
  fn_ft_amount: fn_ft_amount
  "An object relationship"
  fn_ft_count: fn_ft_count
  fully_diluted_market_cap: numeric
  icon: String
  market_cap: numeric
  name: String!
  price: numeric
  price_btc: numeric
  price_eth: numeric
  reddit: String
  reference: String
  reference_hash: String
  spec: String
  symbol: String!
  telegram: String
  twitter: String
  volume_24h: numeric
  website: String
}

"aggregated selection of \"ft_meta\""
type ft_meta_aggregate {
  aggregate: ft_meta_aggregate_fields
  nodes: [ft_meta!]!
}

"aggregate fields of \"ft_meta\""
type ft_meta_aggregate_fields {
  avg: ft_meta_avg_fields
  count(columns: [ft_meta_select_column!], distinct: Boolean): Int!
  max: ft_meta_max_fields
  min: ft_meta_min_fields
  stddev: ft_meta_stddev_fields
  stddev_pop: ft_meta_stddev_pop_fields
  stddev_samp: ft_meta_stddev_samp_fields
  sum: ft_meta_sum_fields
  var_pop: ft_meta_var_pop_fields
  var_samp: ft_meta_var_samp_fields
  variance: ft_meta_variance_fields
}

"aggregate avg on columns"
type ft_meta_avg_fields {
  change_24: Float
  circulating_supply: Float
  decimals: Float
  fully_diluted_market_cap: Float
  market_cap: Float
  price: Float
  price_btc: Float
  price_eth: Float
  volume_24h: Float
}

"aggregate max on columns"
type ft_meta_max_fields {
  change_24: numeric
  circulating_supply: numeric
  coingecko_id: String
  coinmarketcap_id: String
  contract: String
  decimals: Int
  description: String
  facebook: String
  fully_diluted_market_cap: numeric
  icon: String
  market_cap: numeric
  name: String
  price: numeric
  price_btc: numeric
  price_eth: numeric
  reddit: String
  reference: String
  reference_hash: String
  spec: String
  symbol: String
  telegram: String
  twitter: String
  volume_24h: numeric
  website: String
}

"aggregate min on columns"
type ft_meta_min_fields {
  change_24: numeric
  circulating_supply: numeric
  coingecko_id: String
  coinmarketcap_id: String
  contract: String
  decimals: Int
  description: String
  facebook: String
  fully_diluted_market_cap: numeric
  icon: String
  market_cap: numeric
  name: String
  price: numeric
  price_btc: numeric
  price_eth: numeric
  reddit: String
  reference: String
  reference_hash: String
  spec: String
  symbol: String
  telegram: String
  twitter: String
  volume_24h: numeric
  website: String
}

"aggregate stddev on columns"
type ft_meta_stddev_fields {
  change_24: Float
  circulating_supply: Float
  decimals: Float
  fully_diluted_market_cap: Float
  market_cap: Float
  price: Float
  price_btc: Float
  price_eth: Float
  volume_24h: Float
}

"aggregate stddev_pop on columns"
type ft_meta_stddev_pop_fields {
  change_24: Float
  circulating_supply: Float
  decimals: Float
  fully_diluted_market_cap: Float
  market_cap: Float
  price: Float
  price_btc: Float
  price_eth: Float
  volume_24h: Float
}

"aggregate stddev_samp on columns"
type ft_meta_stddev_samp_fields {
  change_24: Float
  circulating_supply: Float
  decimals: Float
  fully_diluted_market_cap: Float
  market_cap: Float
  price: Float
  price_btc: Float
  price_eth: Float
  volume_24h: Float
}

"aggregate sum on columns"
type ft_meta_sum_fields {
  change_24: numeric
  circulating_supply: numeric
  decimals: Int
  fully_diluted_market_cap: numeric
  market_cap: numeric
  price: numeric
  price_btc: numeric
  price_eth: numeric
  volume_24h: numeric
}

"aggregate var_pop on columns"
type ft_meta_var_pop_fields {
  change_24: Float
  circulating_supply: Float
  decimals: Float
  fully_diluted_market_cap: Float
  market_cap: Float
  price: Float
  price_btc: Float
  price_eth: Float
  volume_24h: Float
}

"aggregate var_samp on columns"
type ft_meta_var_samp_fields {
  change_24: Float
  circulating_supply: Float
  decimals: Float
  fully_diluted_market_cap: Float
  market_cap: Float
  price: Float
  price_btc: Float
  price_eth: Float
  volume_24h: Float
}

"aggregate variance on columns"
type ft_meta_variance_fields {
  change_24: Float
  circulating_supply: Float
  decimals: Float
  fully_diluted_market_cap: Float
  market_cap: Float
  price: Float
  price_btc: Float
  price_eth: Float
  volume_24h: Float
}

"columns and relationships of \"nft_list\""
type nft_list {
  contract: String
  name: String
  "An object relationship"
  nft_meta: nft_meta
  symbol: String
  tokens: bigint
  transfers: bigint
  transfers_3days: bigint
  transfers_day: bigint
}

"aggregated selection of \"nft_list\""
type nft_list_aggregate {
  aggregate: nft_list_aggregate_fields
  nodes: [nft_list!]!
}

"aggregate fields of \"nft_list\""
type nft_list_aggregate_fields {
  avg: nft_list_avg_fields
  count(columns: [nft_list_select_column!], distinct: Boolean): Int!
  max: nft_list_max_fields
  min: nft_list_min_fields
  stddev: nft_list_stddev_fields
  stddev_pop: nft_list_stddev_pop_fields
  stddev_samp: nft_list_stddev_samp_fields
  sum: nft_list_sum_fields
  var_pop: nft_list_var_pop_fields
  var_samp: nft_list_var_samp_fields
  variance: nft_list_variance_fields
}

"aggregate avg on columns"
type nft_list_avg_fields {
  tokens: Float
  transfers: Float
  transfers_3days: Float
  transfers_day: Float
}

"aggregate max on columns"
type nft_list_max_fields {
  contract: String
  name: String
  symbol: String
  tokens: bigint
  transfers: bigint
  transfers_3days: bigint
  transfers_day: bigint
}

"aggregate min on columns"
type nft_list_min_fields {
  contract: String
  name: String
  symbol: String
  tokens: bigint
  transfers: bigint
  transfers_3days: bigint
  transfers_day: bigint
}

"aggregate stddev on columns"
type nft_list_stddev_fields {
  tokens: Float
  transfers: Float
  transfers_3days: Float
  transfers_day: Float
}

"aggregate stddev_pop on columns"
type nft_list_stddev_pop_fields {
  tokens: Float
  transfers: Float
  transfers_3days: Float
  transfers_day: Float
}

"aggregate stddev_samp on columns"
type nft_list_stddev_samp_fields {
  tokens: Float
  transfers: Float
  transfers_3days: Float
  transfers_day: Float
}

"aggregate sum on columns"
type nft_list_sum_fields {
  tokens: bigint
  transfers: bigint
  transfers_3days: bigint
  transfers_day: bigint
}

"aggregate var_pop on columns"
type nft_list_var_pop_fields {
  tokens: Float
  transfers: Float
  transfers_3days: Float
  transfers_day: Float
}

"aggregate var_samp on columns"
type nft_list_var_samp_fields {
  tokens: Float
  transfers: Float
  transfers_3days: Float
  transfers_day: Float
}

"aggregate variance on columns"
type nft_list_variance_fields {
  tokens: Float
  transfers: Float
  transfers_3days: Float
  transfers_day: Float
}

"columns and relationships of \"nft_meta\""
type nft_meta {
  base_uri: String
  contract: String!
  description: String
  facebook: String
  icon: String
  name: String!
  reddit: String
  reference: String
  reference_hash: String
  spec: String
  symbol: String!
  telegram: String
  twitter: String
  website: String
}

"aggregated selection of \"nft_meta\""
type nft_meta_aggregate {
  aggregate: nft_meta_aggregate_fields
  nodes: [nft_meta!]!
}

"aggregate fields of \"nft_meta\""
type nft_meta_aggregate_fields {
  count(columns: [nft_meta_select_column!], distinct: Boolean): Int!
  max: nft_meta_max_fields
  min: nft_meta_min_fields
}

"aggregate max on columns"
type nft_meta_max_fields {
  base_uri: String
  contract: String
  description: String
  facebook: String
  icon: String
  name: String
  reddit: String
  reference: String
  reference_hash: String
  spec: String
  symbol: String
  telegram: String
  twitter: String
  website: String
}

"aggregate min on columns"
type nft_meta_min_fields {
  base_uri: String
  contract: String
  description: String
  facebook: String
  icon: String
  name: String
  reddit: String
  reference: String
  reference_hash: String
  spec: String
  symbol: String
  telegram: String
  twitter: String
  website: String
}

"columns and relationships of \"nft_token_meta\""
type nft_token_meta {
  "An array relationship"
  assets__non_fungible_token_events(
    "distinct select on columns"
    distinct_on: [assets__non_fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__non_fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__non_fungible_token_events_bool_exp
  ): [assets__non_fungible_token_events!]!
  "An aggregate relationship"
  assets__non_fungible_token_events_aggregate(
    "distinct select on columns"
    distinct_on: [assets__non_fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__non_fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__non_fungible_token_events_bool_exp
  ): assets__non_fungible_token_events_aggregate!
  contract: String!
  copies: Int
  description: String
  extra: String
  media: String
  media_hash: String
  "An object relationship"
  nft_meta: nft_meta
  reference: String
  reference_hash: String
  title: String
  token: String!
}

"aggregated selection of \"nft_token_meta\""
type nft_token_meta_aggregate {
  aggregate: nft_token_meta_aggregate_fields
  nodes: [nft_token_meta!]!
}

"aggregate fields of \"nft_token_meta\""
type nft_token_meta_aggregate_fields {
  avg: nft_token_meta_avg_fields
  count(columns: [nft_token_meta_select_column!], distinct: Boolean): Int!
  max: nft_token_meta_max_fields
  min: nft_token_meta_min_fields
  stddev: nft_token_meta_stddev_fields
  stddev_pop: nft_token_meta_stddev_pop_fields
  stddev_samp: nft_token_meta_stddev_samp_fields
  sum: nft_token_meta_sum_fields
  var_pop: nft_token_meta_var_pop_fields
  var_samp: nft_token_meta_var_samp_fields
  variance: nft_token_meta_variance_fields
}

"aggregate avg on columns"
type nft_token_meta_avg_fields {
  copies: Float
}

"aggregate max on columns"
type nft_token_meta_max_fields {
  contract: String
  copies: Int
  description: String
  extra: String
  media: String
  media_hash: String
  reference: String
  reference_hash: String
  title: String
  token: String
}

"aggregate min on columns"
type nft_token_meta_min_fields {
  contract: String
  copies: Int
  description: String
  extra: String
  media: String
  media_hash: String
  reference: String
  reference_hash: String
  title: String
  token: String
}

"aggregate stddev on columns"
type nft_token_meta_stddev_fields {
  copies: Float
}

"aggregate stddev_pop on columns"
type nft_token_meta_stddev_pop_fields {
  copies: Float
}

"aggregate stddev_samp on columns"
type nft_token_meta_stddev_samp_fields {
  copies: Float
}

"aggregate sum on columns"
type nft_token_meta_sum_fields {
  copies: Int
}

"aggregate var_pop on columns"
type nft_token_meta_var_pop_fields {
  copies: Float
}

"aggregate var_samp on columns"
type nft_token_meta_var_samp_fields {
  copies: Float
}

"aggregate variance on columns"
type nft_token_meta_variance_fields {
  copies: Float
}

type query_root {
  "An array relationship"
  access_keys(
    "distinct select on columns"
    distinct_on: [access_keys_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [access_keys_order_by!]
    "filter the rows returned"
    where: access_keys_bool_exp
  ): [access_keys!]!
  "An aggregate relationship"
  access_keys_aggregate(
    "distinct select on columns"
    distinct_on: [access_keys_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [access_keys_order_by!]
    "filter the rows returned"
    where: access_keys_bool_exp
  ): access_keys_aggregate!
  "fetch data from the table: \"access_keys\" using primary key columns"
  access_keys_by_pk(account_id: String!, public_key: String!): access_keys
  "An array relationship"
  accounts(
    "distinct select on columns"
    distinct_on: [accounts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [accounts_order_by!]
    "filter the rows returned"
    where: accounts_bool_exp
  ): [accounts!]!
  "An aggregate relationship"
  accounts_aggregate(
    "distinct select on columns"
    distinct_on: [accounts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [accounts_order_by!]
    "filter the rows returned"
    where: accounts_bool_exp
  ): accounts_aggregate!
  "fetch data from the table: \"accounts\" using primary key columns"
  accounts_by_pk(id: bigint!): accounts
  "An array relationship"
  action_receipt_actions(
    "distinct select on columns"
    distinct_on: [action_receipt_actions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [action_receipt_actions_order_by!]
    "filter the rows returned"
    where: action_receipt_actions_bool_exp
  ): [action_receipt_actions!]!
  "An aggregate relationship"
  action_receipt_actions_aggregate(
    "distinct select on columns"
    distinct_on: [action_receipt_actions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [action_receipt_actions_order_by!]
    "filter the rows returned"
    where: action_receipt_actions_bool_exp
  ): action_receipt_actions_aggregate!
  "fetch data from the table: \"action_receipt_actions\" using primary key columns"
  action_receipt_actions_by_pk(
    index_in_action_receipt: Int!
    receipt_id: String!
  ): action_receipt_actions
  "An array relationship"
  assets__fungible_token_events(
    "distinct select on columns"
    distinct_on: [assets__fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__fungible_token_events_bool_exp
  ): [assets__fungible_token_events!]!
  "An aggregate relationship"
  assets__fungible_token_events_aggregate(
    "distinct select on columns"
    distinct_on: [assets__fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__fungible_token_events_bool_exp
  ): assets__fungible_token_events_aggregate!
  "fetch data from the table: \"assets__fungible_token_events\" using primary key columns"
  assets__fungible_token_events_by_pk(
    emitted_at_block_timestamp: numeric!
    emitted_for_event_type: Int!
    emitted_for_receipt_id: String!
    emitted_in_shard_id: numeric!
    emitted_index_of_event_entry_in_shard: Int!
  ): assets__fungible_token_events
  "An array relationship"
  assets__non_fungible_token_events(
    "distinct select on columns"
    distinct_on: [assets__non_fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__non_fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__non_fungible_token_events_bool_exp
  ): [assets__non_fungible_token_events!]!
  "An aggregate relationship"
  assets__non_fungible_token_events_aggregate(
    "distinct select on columns"
    distinct_on: [assets__non_fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__non_fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__non_fungible_token_events_bool_exp
  ): assets__non_fungible_token_events_aggregate!
  "fetch data from the table: \"assets__non_fungible_token_events\" using primary key columns"
  assets__non_fungible_token_events_by_pk(
    emitted_at_block_timestamp: numeric!
    emitted_for_event_type: Int!
    emitted_for_receipt_id: String!
    emitted_in_shard_id: numeric!
    emitted_index_of_event_entry_in_shard: Int!
  ): assets__non_fungible_token_events
  "fetch data from the table: \"blocks\""
  blocks(
    "distinct select on columns"
    distinct_on: [blocks_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [blocks_order_by!]
    "filter the rows returned"
    where: blocks_bool_exp
  ): [blocks!]!
  "fetch aggregated fields from the table: \"blocks\""
  blocks_aggregate(
    "distinct select on columns"
    distinct_on: [blocks_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [blocks_order_by!]
    "filter the rows returned"
    where: blocks_bool_exp
  ): blocks_aggregate!
  "fetch data from the table: \"blocks\" using primary key columns"
  blocks_by_pk(block_hash: String!): blocks
  "An array relationship"
  chunks(
    "distinct select on columns"
    distinct_on: [chunks_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [chunks_order_by!]
    "filter the rows returned"
    where: chunks_bool_exp
  ): [chunks!]!
  "An aggregate relationship"
  chunks_aggregate(
    "distinct select on columns"
    distinct_on: [chunks_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [chunks_order_by!]
    "filter the rows returned"
    where: chunks_bool_exp
  ): chunks_aggregate!
  "fetch data from the table: \"chunks\" using primary key columns"
  chunks_by_pk(chunk_hash: String!): chunks
  "fetch data from the table: \"daily_stats\""
  daily_stats(
    "distinct select on columns"
    distinct_on: [daily_stats_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [daily_stats_order_by!]
    "filter the rows returned"
    where: daily_stats_bool_exp
  ): [daily_stats!]!
  "fetch aggregated fields from the table: \"daily_stats\""
  daily_stats_aggregate(
    "distinct select on columns"
    distinct_on: [daily_stats_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [daily_stats_order_by!]
    "filter the rows returned"
    where: daily_stats_bool_exp
  ): daily_stats_aggregate!
  "fetch data from the table: \"daily_stats\" using primary key columns"
  daily_stats_by_pk(date: date!): daily_stats
  "An array relationship"
  execution_outcomes(
    "distinct select on columns"
    distinct_on: [execution_outcomes_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [execution_outcomes_order_by!]
    "filter the rows returned"
    where: execution_outcomes_bool_exp
  ): [execution_outcomes!]!
  "An aggregate relationship"
  execution_outcomes_aggregate(
    "distinct select on columns"
    distinct_on: [execution_outcomes_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [execution_outcomes_order_by!]
    "filter the rows returned"
    where: execution_outcomes_bool_exp
  ): execution_outcomes_aggregate!
  "fetch data from the table: \"execution_outcomes\" using primary key columns"
  execution_outcomes_by_pk(receipt_id: String!): execution_outcomes
  "fetch data from the table: \"fn_ft_amount\""
  fn_ft_amount(
    "distinct select on columns"
    distinct_on: [fn_ft_amount_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [fn_ft_amount_order_by!]
    "filter the rows returned"
    where: fn_ft_amount_bool_exp
  ): [fn_ft_amount!]!
  "fetch data from the table: \"fn_ft_amount\" using primary key columns"
  fn_ft_amount_by_pk(account: String!, contract: String!): fn_ft_amount
  "fetch data from the table: \"fn_ft_count\""
  fn_ft_count(
    "distinct select on columns"
    distinct_on: [fn_ft_count_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [fn_ft_count_order_by!]
    "filter the rows returned"
    where: fn_ft_count_bool_exp
  ): [fn_ft_count!]!
  "fetch data from the table: \"fn_ft_count\" using primary key columns"
  fn_ft_count_by_pk(contract: String!): fn_ft_count
  "fetch data from the table: \"fn_nft_amount\""
  fn_nft_amount(
    "distinct select on columns"
    distinct_on: [fn_nft_amount_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [fn_nft_amount_order_by!]
    "filter the rows returned"
    where: fn_nft_amount_bool_exp
  ): [fn_nft_amount!]!
  "fetch aggregated fields from the table: \"fn_nft_amount\""
  fn_nft_amount_aggregate(
    "distinct select on columns"
    distinct_on: [fn_nft_amount_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [fn_nft_amount_order_by!]
    "filter the rows returned"
    where: fn_nft_amount_bool_exp
  ): fn_nft_amount_aggregate!
  "fetch data from the table: \"fn_nft_amount\" using primary key columns"
  fn_nft_amount_by_pk(account: String!, contract: String!): fn_nft_amount
  "fetch data from the table: \"fn_nft_count\""
  fn_nft_count(
    "distinct select on columns"
    distinct_on: [fn_nft_count_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [fn_nft_count_order_by!]
    "filter the rows returned"
    where: fn_nft_count_bool_exp
  ): [fn_nft_count!]!
  "fetch data from the table: \"fn_nft_count\" using primary key columns"
  fn_nft_count_by_pk(contract: String!): fn_nft_count
  "execute function \"ft_holders\" which returns \"fn_ft_amount\""
  ft_holders(
    "input parameters for function \"ft_holders\""
    args: ft_holders_args!
    "distinct select on columns"
    distinct_on: [fn_ft_amount_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [fn_ft_amount_order_by!]
    "filter the rows returned"
    where: fn_ft_amount_bool_exp
  ): [fn_ft_amount!]!
  "execute function \"ft_holders_count\" which returns \"fn_ft_count\""
  ft_holders_count(
    "input parameters for function \"ft_holders_count\""
    args: ft_holders_count_args!
    "distinct select on columns"
    distinct_on: [fn_ft_count_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [fn_ft_count_order_by!]
    "filter the rows returned"
    where: fn_ft_count_bool_exp
  ): [fn_ft_count!]!
  "execute function \"ft_inventory\" which returns \"fn_ft_amount\""
  ft_inventory(
    "input parameters for function \"ft_inventory\""
    args: ft_inventory_args!
    "distinct select on columns"
    distinct_on: [fn_ft_amount_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [fn_ft_amount_order_by!]
    "filter the rows returned"
    where: fn_ft_amount_bool_exp
  ): [fn_ft_amount!]!
  "execute function \"ft_inventory_count\" which returns \"fn_ft_count\""
  ft_inventory_count(
    "input parameters for function \"ft_inventory_count\""
    args: ft_inventory_count_args!
    "distinct select on columns"
    distinct_on: [fn_ft_count_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [fn_ft_count_order_by!]
    "filter the rows returned"
    where: fn_ft_count_bool_exp
  ): [fn_ft_count!]!
  "fetch data from the table: \"ft_list\""
  ft_list(
    "distinct select on columns"
    distinct_on: [ft_list_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_list_order_by!]
    "filter the rows returned"
    where: ft_list_bool_exp
  ): [ft_list!]!
  "fetch aggregated fields from the table: \"ft_list\""
  ft_list_aggregate(
    "distinct select on columns"
    distinct_on: [ft_list_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_list_order_by!]
    "filter the rows returned"
    where: ft_list_bool_exp
  ): ft_list_aggregate!
  "fetch data from the table: \"ft_meta\""
  ft_meta(
    "distinct select on columns"
    distinct_on: [ft_meta_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_meta_order_by!]
    "filter the rows returned"
    where: ft_meta_bool_exp
  ): [ft_meta!]!
  "fetch aggregated fields from the table: \"ft_meta\""
  ft_meta_aggregate(
    "distinct select on columns"
    distinct_on: [ft_meta_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_meta_order_by!]
    "filter the rows returned"
    where: ft_meta_bool_exp
  ): ft_meta_aggregate!
  "fetch data from the table: \"ft_meta\" using primary key columns"
  ft_meta_by_pk(contract: String!): ft_meta
  "execute function \"nft_holders\" which returns \"fn_nft_amount\""
  nft_holders(
    "input parameters for function \"nft_holders\""
    args: nft_holders_args!
    "distinct select on columns"
    distinct_on: [fn_nft_amount_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [fn_nft_amount_order_by!]
    "filter the rows returned"
    where: fn_nft_amount_bool_exp
  ): [fn_nft_amount!]!
  "execute function \"nft_holders\" and query aggregates on result of table type \"fn_nft_amount\""
  nft_holders_aggregate(
    "input parameters for function \"nft_holders_aggregate\""
    args: nft_holders_args!
    "distinct select on columns"
    distinct_on: [fn_nft_amount_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [fn_nft_amount_order_by!]
    "filter the rows returned"
    where: fn_nft_amount_bool_exp
  ): fn_nft_amount_aggregate!
  "execute function \"nft_holders_count\" which returns \"fn_nft_count\""
  nft_holders_count(
    "input parameters for function \"nft_holders_count\""
    args: nft_holders_count_args!
    "distinct select on columns"
    distinct_on: [fn_nft_count_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [fn_nft_count_order_by!]
    "filter the rows returned"
    where: fn_nft_count_bool_exp
  ): [fn_nft_count!]!
  "fetch data from the table: \"nft_list\""
  nft_list(
    "distinct select on columns"
    distinct_on: [nft_list_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [nft_list_order_by!]
    "filter the rows returned"
    where: nft_list_bool_exp
  ): [nft_list!]!
  "fetch aggregated fields from the table: \"nft_list\""
  nft_list_aggregate(
    "distinct select on columns"
    distinct_on: [nft_list_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [nft_list_order_by!]
    "filter the rows returned"
    where: nft_list_bool_exp
  ): nft_list_aggregate!
  "fetch data from the table: \"nft_meta\""
  nft_meta(
    "distinct select on columns"
    distinct_on: [nft_meta_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [nft_meta_order_by!]
    "filter the rows returned"
    where: nft_meta_bool_exp
  ): [nft_meta!]!
  "fetch aggregated fields from the table: \"nft_meta\""
  nft_meta_aggregate(
    "distinct select on columns"
    distinct_on: [nft_meta_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [nft_meta_order_by!]
    "filter the rows returned"
    where: nft_meta_bool_exp
  ): nft_meta_aggregate!
  "fetch data from the table: \"nft_meta\" using primary key columns"
  nft_meta_by_pk(contract: String!): nft_meta
  "fetch data from the table: \"nft_token_meta\""
  nft_token_meta(
    "distinct select on columns"
    distinct_on: [nft_token_meta_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [nft_token_meta_order_by!]
    "filter the rows returned"
    where: nft_token_meta_bool_exp
  ): [nft_token_meta!]!
  "fetch aggregated fields from the table: \"nft_token_meta\""
  nft_token_meta_aggregate(
    "distinct select on columns"
    distinct_on: [nft_token_meta_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [nft_token_meta_order_by!]
    "filter the rows returned"
    where: nft_token_meta_bool_exp
  ): nft_token_meta_aggregate!
  "fetch data from the table: \"nft_token_meta\" using primary key columns"
  nft_token_meta_by_pk(contract: String!, token: String!): nft_token_meta
  "An array relationship"
  receipts(
    "distinct select on columns"
    distinct_on: [receipts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [receipts_order_by!]
    "filter the rows returned"
    where: receipts_bool_exp
  ): [receipts!]!
  "An aggregate relationship"
  receipts_aggregate(
    "distinct select on columns"
    distinct_on: [receipts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [receipts_order_by!]
    "filter the rows returned"
    where: receipts_bool_exp
  ): receipts_aggregate!
  "fetch data from the table: \"receipts\" using primary key columns"
  receipts_by_pk(receipt_id: String!): receipts
  "fetch data from the table: \"stats\""
  stats(
    "distinct select on columns"
    distinct_on: [stats_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [stats_order_by!]
    "filter the rows returned"
    where: stats_bool_exp
  ): [stats!]!
  "fetch aggregated fields from the table: \"stats\""
  stats_aggregate(
    "distinct select on columns"
    distinct_on: [stats_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [stats_order_by!]
    "filter the rows returned"
    where: stats_bool_exp
  ): stats_aggregate!
  "fetch data from the table: \"stats\" using primary key columns"
  stats_by_pk(id: Int!): stats
  "An array relationship"
  transactions(
    "distinct select on columns"
    distinct_on: [transactions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [transactions_order_by!]
    "filter the rows returned"
    where: transactions_bool_exp
  ): [transactions!]!
  "An aggregate relationship"
  transactions_aggregate(
    "distinct select on columns"
    distinct_on: [transactions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [transactions_order_by!]
    "filter the rows returned"
    where: transactions_bool_exp
  ): transactions_aggregate!
  "fetch data from the table: \"transactions\" using primary key columns"
  transactions_by_pk(transaction_hash: String!): transactions
  "execute function \"txn_export\" which returns \"transactions\""
  txn_export(
    "input parameters for function \"txn_export\""
    args: txn_export_args!
    "distinct select on columns"
    distinct_on: [transactions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [transactions_order_by!]
    "filter the rows returned"
    where: transactions_bool_exp
  ): [transactions!]!
  "execute function \"txn_export\" and query aggregates on result of table type \"transactions\""
  txn_export_aggregate(
    "input parameters for function \"txn_export_aggregate\""
    args: txn_export_args!
    "distinct select on columns"
    distinct_on: [transactions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [transactions_order_by!]
    "filter the rows returned"
    where: transactions_bool_exp
  ): transactions_aggregate!
}

"columns and relationships of \"receipts\""
type receipts {
  "An array relationship"
  accessKeysByDeletedByReceiptId(
    "distinct select on columns"
    distinct_on: [access_keys_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [access_keys_order_by!]
    "filter the rows returned"
    where: access_keys_bool_exp
  ): [access_keys!]!
  "An aggregate relationship"
  accessKeysByDeletedByReceiptId_aggregate(
    "distinct select on columns"
    distinct_on: [access_keys_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [access_keys_order_by!]
    "filter the rows returned"
    where: access_keys_bool_exp
  ): access_keys_aggregate!
  "An array relationship"
  access_keys(
    "distinct select on columns"
    distinct_on: [access_keys_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [access_keys_order_by!]
    "filter the rows returned"
    where: access_keys_bool_exp
  ): [access_keys!]!
  "An aggregate relationship"
  access_keys_aggregate(
    "distinct select on columns"
    distinct_on: [access_keys_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [access_keys_order_by!]
    "filter the rows returned"
    where: access_keys_bool_exp
  ): access_keys_aggregate!
  "An array relationship"
  accounts(
    "distinct select on columns"
    distinct_on: [accounts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [accounts_order_by!]
    "filter the rows returned"
    where: accounts_bool_exp
  ): [accounts!]!
  "An array relationship"
  accountsByDeletedByReceiptId(
    "distinct select on columns"
    distinct_on: [accounts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [accounts_order_by!]
    "filter the rows returned"
    where: accounts_bool_exp
  ): [accounts!]!
  "An aggregate relationship"
  accountsByDeletedByReceiptId_aggregate(
    "distinct select on columns"
    distinct_on: [accounts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [accounts_order_by!]
    "filter the rows returned"
    where: accounts_bool_exp
  ): accounts_aggregate!
  "An aggregate relationship"
  accounts_aggregate(
    "distinct select on columns"
    distinct_on: [accounts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [accounts_order_by!]
    "filter the rows returned"
    where: accounts_bool_exp
  ): accounts_aggregate!
  "An array relationship"
  action_receipt_actions(
    "distinct select on columns"
    distinct_on: [action_receipt_actions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [action_receipt_actions_order_by!]
    "filter the rows returned"
    where: action_receipt_actions_bool_exp
  ): [action_receipt_actions!]!
  "An aggregate relationship"
  action_receipt_actions_aggregate(
    "distinct select on columns"
    distinct_on: [action_receipt_actions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [action_receipt_actions_order_by!]
    "filter the rows returned"
    where: action_receipt_actions_bool_exp
  ): action_receipt_actions_aggregate!
  "An array relationship"
  assets__fungible_token_events(
    "distinct select on columns"
    distinct_on: [assets__fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__fungible_token_events_bool_exp
  ): [assets__fungible_token_events!]!
  "An aggregate relationship"
  assets__fungible_token_events_aggregate(
    "distinct select on columns"
    distinct_on: [assets__fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__fungible_token_events_bool_exp
  ): assets__fungible_token_events_aggregate!
  "An array relationship"
  assets__non_fungible_token_events(
    "distinct select on columns"
    distinct_on: [assets__non_fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__non_fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__non_fungible_token_events_bool_exp
  ): [assets__non_fungible_token_events!]!
  "An aggregate relationship"
  assets__non_fungible_token_events_aggregate(
    "distinct select on columns"
    distinct_on: [assets__non_fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__non_fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__non_fungible_token_events_bool_exp
  ): assets__non_fungible_token_events_aggregate!
  "An object relationship"
  block: blocks!
  "An object relationship"
  chunk: chunks!
  "An object relationship"
  execution_outcome: execution_outcomes
  included_in_block_hash: String!
  included_in_block_timestamp: numeric!
  included_in_chunk_hash: String!
  index_in_chunk: Int!
  originated_from_transaction_hash: String!
  predecessor_account_id: String!
  receipt_id: String!
  receipt_kind: receipt_kind!
  receiver_account_id: String!
  "An object relationship"
  transaction: transactions!
}

"aggregated selection of \"receipts\""
type receipts_aggregate {
  aggregate: receipts_aggregate_fields
  nodes: [receipts!]!
}

"aggregate fields of \"receipts\""
type receipts_aggregate_fields {
  avg: receipts_avg_fields
  count(columns: [receipts_select_column!], distinct: Boolean): Int!
  max: receipts_max_fields
  min: receipts_min_fields
  stddev: receipts_stddev_fields
  stddev_pop: receipts_stddev_pop_fields
  stddev_samp: receipts_stddev_samp_fields
  sum: receipts_sum_fields
  var_pop: receipts_var_pop_fields
  var_samp: receipts_var_samp_fields
  variance: receipts_variance_fields
}

"aggregate avg on columns"
type receipts_avg_fields {
  included_in_block_timestamp: Float
  index_in_chunk: Float
}

"aggregate max on columns"
type receipts_max_fields {
  included_in_block_hash: String
  included_in_block_timestamp: numeric
  included_in_chunk_hash: String
  index_in_chunk: Int
  originated_from_transaction_hash: String
  predecessor_account_id: String
  receipt_id: String
  receipt_kind: receipt_kind
  receiver_account_id: String
}

"aggregate min on columns"
type receipts_min_fields {
  included_in_block_hash: String
  included_in_block_timestamp: numeric
  included_in_chunk_hash: String
  index_in_chunk: Int
  originated_from_transaction_hash: String
  predecessor_account_id: String
  receipt_id: String
  receipt_kind: receipt_kind
  receiver_account_id: String
}

"aggregate stddev on columns"
type receipts_stddev_fields {
  included_in_block_timestamp: Float
  index_in_chunk: Float
}

"aggregate stddev_pop on columns"
type receipts_stddev_pop_fields {
  included_in_block_timestamp: Float
  index_in_chunk: Float
}

"aggregate stddev_samp on columns"
type receipts_stddev_samp_fields {
  included_in_block_timestamp: Float
  index_in_chunk: Float
}

"aggregate sum on columns"
type receipts_sum_fields {
  included_in_block_timestamp: numeric
  index_in_chunk: Int
}

"aggregate var_pop on columns"
type receipts_var_pop_fields {
  included_in_block_timestamp: Float
  index_in_chunk: Float
}

"aggregate var_samp on columns"
type receipts_var_samp_fields {
  included_in_block_timestamp: Float
  index_in_chunk: Float
}

"aggregate variance on columns"
type receipts_variance_fields {
  included_in_block_timestamp: Float
  index_in_chunk: Float
}

"columns and relationships of \"stats\""
type stats {
  avg_block_time: numeric!
  block: numeric!
  change_24: numeric!
  gas_price: numeric!
  high_24h: numeric!
  high_all: numeric!
  id: Int!
  low_24h: numeric!
  low_all: numeric!
  market_cap: numeric!
  near_btc_price: numeric!
  near_price: numeric!
  nodes: numeric!
  nodes_online: numeric!
  total_supply: numeric!
  total_txns: numeric!
  volume: numeric!
}

"aggregated selection of \"stats\""
type stats_aggregate {
  aggregate: stats_aggregate_fields
  nodes: [stats!]!
}

"aggregate fields of \"stats\""
type stats_aggregate_fields {
  avg: stats_avg_fields
  count(columns: [stats_select_column!], distinct: Boolean): Int!
  max: stats_max_fields
  min: stats_min_fields
  stddev: stats_stddev_fields
  stddev_pop: stats_stddev_pop_fields
  stddev_samp: stats_stddev_samp_fields
  sum: stats_sum_fields
  var_pop: stats_var_pop_fields
  var_samp: stats_var_samp_fields
  variance: stats_variance_fields
}

"aggregate avg on columns"
type stats_avg_fields {
  avg_block_time: Float
  block: Float
  change_24: Float
  gas_price: Float
  high_24h: Float
  high_all: Float
  id: Float
  low_24h: Float
  low_all: Float
  market_cap: Float
  near_btc_price: Float
  near_price: Float
  nodes: Float
  nodes_online: Float
  total_supply: Float
  total_txns: Float
  volume: Float
}

"aggregate max on columns"
type stats_max_fields {
  avg_block_time: numeric
  block: numeric
  change_24: numeric
  gas_price: numeric
  high_24h: numeric
  high_all: numeric
  id: Int
  low_24h: numeric
  low_all: numeric
  market_cap: numeric
  near_btc_price: numeric
  near_price: numeric
  nodes: numeric
  nodes_online: numeric
  total_supply: numeric
  total_txns: numeric
  volume: numeric
}

"aggregate min on columns"
type stats_min_fields {
  avg_block_time: numeric
  block: numeric
  change_24: numeric
  gas_price: numeric
  high_24h: numeric
  high_all: numeric
  id: Int
  low_24h: numeric
  low_all: numeric
  market_cap: numeric
  near_btc_price: numeric
  near_price: numeric
  nodes: numeric
  nodes_online: numeric
  total_supply: numeric
  total_txns: numeric
  volume: numeric
}

"aggregate stddev on columns"
type stats_stddev_fields {
  avg_block_time: Float
  block: Float
  change_24: Float
  gas_price: Float
  high_24h: Float
  high_all: Float
  id: Float
  low_24h: Float
  low_all: Float
  market_cap: Float
  near_btc_price: Float
  near_price: Float
  nodes: Float
  nodes_online: Float
  total_supply: Float
  total_txns: Float
  volume: Float
}

"aggregate stddev_pop on columns"
type stats_stddev_pop_fields {
  avg_block_time: Float
  block: Float
  change_24: Float
  gas_price: Float
  high_24h: Float
  high_all: Float
  id: Float
  low_24h: Float
  low_all: Float
  market_cap: Float
  near_btc_price: Float
  near_price: Float
  nodes: Float
  nodes_online: Float
  total_supply: Float
  total_txns: Float
  volume: Float
}

"aggregate stddev_samp on columns"
type stats_stddev_samp_fields {
  avg_block_time: Float
  block: Float
  change_24: Float
  gas_price: Float
  high_24h: Float
  high_all: Float
  id: Float
  low_24h: Float
  low_all: Float
  market_cap: Float
  near_btc_price: Float
  near_price: Float
  nodes: Float
  nodes_online: Float
  total_supply: Float
  total_txns: Float
  volume: Float
}

"aggregate sum on columns"
type stats_sum_fields {
  avg_block_time: numeric
  block: numeric
  change_24: numeric
  gas_price: numeric
  high_24h: numeric
  high_all: numeric
  id: Int
  low_24h: numeric
  low_all: numeric
  market_cap: numeric
  near_btc_price: numeric
  near_price: numeric
  nodes: numeric
  nodes_online: numeric
  total_supply: numeric
  total_txns: numeric
  volume: numeric
}

"aggregate var_pop on columns"
type stats_var_pop_fields {
  avg_block_time: Float
  block: Float
  change_24: Float
  gas_price: Float
  high_24h: Float
  high_all: Float
  id: Float
  low_24h: Float
  low_all: Float
  market_cap: Float
  near_btc_price: Float
  near_price: Float
  nodes: Float
  nodes_online: Float
  total_supply: Float
  total_txns: Float
  volume: Float
}

"aggregate var_samp on columns"
type stats_var_samp_fields {
  avg_block_time: Float
  block: Float
  change_24: Float
  gas_price: Float
  high_24h: Float
  high_all: Float
  id: Float
  low_24h: Float
  low_all: Float
  market_cap: Float
  near_btc_price: Float
  near_price: Float
  nodes: Float
  nodes_online: Float
  total_supply: Float
  total_txns: Float
  volume: Float
}

"aggregate variance on columns"
type stats_variance_fields {
  avg_block_time: Float
  block: Float
  change_24: Float
  gas_price: Float
  high_24h: Float
  high_all: Float
  id: Float
  low_24h: Float
  low_all: Float
  market_cap: Float
  near_btc_price: Float
  near_price: Float
  nodes: Float
  nodes_online: Float
  total_supply: Float
  total_txns: Float
  volume: Float
}

type subscription_root {
  "An array relationship"
  access_keys(
    "distinct select on columns"
    distinct_on: [access_keys_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [access_keys_order_by!]
    "filter the rows returned"
    where: access_keys_bool_exp
  ): [access_keys!]!
  "An aggregate relationship"
  access_keys_aggregate(
    "distinct select on columns"
    distinct_on: [access_keys_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [access_keys_order_by!]
    "filter the rows returned"
    where: access_keys_bool_exp
  ): access_keys_aggregate!
  "fetch data from the table: \"access_keys\" using primary key columns"
  access_keys_by_pk(account_id: String!, public_key: String!): access_keys
  "An array relationship"
  accounts(
    "distinct select on columns"
    distinct_on: [accounts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [accounts_order_by!]
    "filter the rows returned"
    where: accounts_bool_exp
  ): [accounts!]!
  "An aggregate relationship"
  accounts_aggregate(
    "distinct select on columns"
    distinct_on: [accounts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [accounts_order_by!]
    "filter the rows returned"
    where: accounts_bool_exp
  ): accounts_aggregate!
  "fetch data from the table: \"accounts\" using primary key columns"
  accounts_by_pk(id: bigint!): accounts
  "An array relationship"
  action_receipt_actions(
    "distinct select on columns"
    distinct_on: [action_receipt_actions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [action_receipt_actions_order_by!]
    "filter the rows returned"
    where: action_receipt_actions_bool_exp
  ): [action_receipt_actions!]!
  "An aggregate relationship"
  action_receipt_actions_aggregate(
    "distinct select on columns"
    distinct_on: [action_receipt_actions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [action_receipt_actions_order_by!]
    "filter the rows returned"
    where: action_receipt_actions_bool_exp
  ): action_receipt_actions_aggregate!
  "fetch data from the table: \"action_receipt_actions\" using primary key columns"
  action_receipt_actions_by_pk(
    index_in_action_receipt: Int!
    receipt_id: String!
  ): action_receipt_actions
  "An array relationship"
  assets__fungible_token_events(
    "distinct select on columns"
    distinct_on: [assets__fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__fungible_token_events_bool_exp
  ): [assets__fungible_token_events!]!
  "An aggregate relationship"
  assets__fungible_token_events_aggregate(
    "distinct select on columns"
    distinct_on: [assets__fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__fungible_token_events_bool_exp
  ): assets__fungible_token_events_aggregate!
  "fetch data from the table: \"assets__fungible_token_events\" using primary key columns"
  assets__fungible_token_events_by_pk(
    emitted_at_block_timestamp: numeric!
    emitted_for_event_type: Int!
    emitted_for_receipt_id: String!
    emitted_in_shard_id: numeric!
    emitted_index_of_event_entry_in_shard: Int!
  ): assets__fungible_token_events
  "An array relationship"
  assets__non_fungible_token_events(
    "distinct select on columns"
    distinct_on: [assets__non_fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__non_fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__non_fungible_token_events_bool_exp
  ): [assets__non_fungible_token_events!]!
  "An aggregate relationship"
  assets__non_fungible_token_events_aggregate(
    "distinct select on columns"
    distinct_on: [assets__non_fungible_token_events_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assets__non_fungible_token_events_order_by!]
    "filter the rows returned"
    where: assets__non_fungible_token_events_bool_exp
  ): assets__non_fungible_token_events_aggregate!
  "fetch data from the table: \"assets__non_fungible_token_events\" using primary key columns"
  assets__non_fungible_token_events_by_pk(
    emitted_at_block_timestamp: numeric!
    emitted_for_event_type: Int!
    emitted_for_receipt_id: String!
    emitted_in_shard_id: numeric!
    emitted_index_of_event_entry_in_shard: Int!
  ): assets__non_fungible_token_events
  "fetch data from the table: \"blocks\""
  blocks(
    "distinct select on columns"
    distinct_on: [blocks_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [blocks_order_by!]
    "filter the rows returned"
    where: blocks_bool_exp
  ): [blocks!]!
  "fetch aggregated fields from the table: \"blocks\""
  blocks_aggregate(
    "distinct select on columns"
    distinct_on: [blocks_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [blocks_order_by!]
    "filter the rows returned"
    where: blocks_bool_exp
  ): blocks_aggregate!
  "fetch data from the table: \"blocks\" using primary key columns"
  blocks_by_pk(block_hash: String!): blocks
  "An array relationship"
  chunks(
    "distinct select on columns"
    distinct_on: [chunks_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [chunks_order_by!]
    "filter the rows returned"
    where: chunks_bool_exp
  ): [chunks!]!
  "An aggregate relationship"
  chunks_aggregate(
    "distinct select on columns"
    distinct_on: [chunks_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [chunks_order_by!]
    "filter the rows returned"
    where: chunks_bool_exp
  ): chunks_aggregate!
  "fetch data from the table: \"chunks\" using primary key columns"
  chunks_by_pk(chunk_hash: String!): chunks
  "fetch data from the table: \"daily_stats\""
  daily_stats(
    "distinct select on columns"
    distinct_on: [daily_stats_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [daily_stats_order_by!]
    "filter the rows returned"
    where: daily_stats_bool_exp
  ): [daily_stats!]!
  "fetch aggregated fields from the table: \"daily_stats\""
  daily_stats_aggregate(
    "distinct select on columns"
    distinct_on: [daily_stats_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [daily_stats_order_by!]
    "filter the rows returned"
    where: daily_stats_bool_exp
  ): daily_stats_aggregate!
  "fetch data from the table: \"daily_stats\" using primary key columns"
  daily_stats_by_pk(date: date!): daily_stats
  "An array relationship"
  execution_outcomes(
    "distinct select on columns"
    distinct_on: [execution_outcomes_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [execution_outcomes_order_by!]
    "filter the rows returned"
    where: execution_outcomes_bool_exp
  ): [execution_outcomes!]!
  "An aggregate relationship"
  execution_outcomes_aggregate(
    "distinct select on columns"
    distinct_on: [execution_outcomes_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [execution_outcomes_order_by!]
    "filter the rows returned"
    where: execution_outcomes_bool_exp
  ): execution_outcomes_aggregate!
  "fetch data from the table: \"execution_outcomes\" using primary key columns"
  execution_outcomes_by_pk(receipt_id: String!): execution_outcomes
  "fetch data from the table: \"fn_ft_amount\""
  fn_ft_amount(
    "distinct select on columns"
    distinct_on: [fn_ft_amount_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [fn_ft_amount_order_by!]
    "filter the rows returned"
    where: fn_ft_amount_bool_exp
  ): [fn_ft_amount!]!
  "fetch data from the table: \"fn_ft_amount\" using primary key columns"
  fn_ft_amount_by_pk(account: String!, contract: String!): fn_ft_amount
  "fetch data from the table: \"fn_ft_count\""
  fn_ft_count(
    "distinct select on columns"
    distinct_on: [fn_ft_count_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [fn_ft_count_order_by!]
    "filter the rows returned"
    where: fn_ft_count_bool_exp
  ): [fn_ft_count!]!
  "fetch data from the table: \"fn_ft_count\" using primary key columns"
  fn_ft_count_by_pk(contract: String!): fn_ft_count
  "fetch data from the table: \"fn_nft_amount\""
  fn_nft_amount(
    "distinct select on columns"
    distinct_on: [fn_nft_amount_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [fn_nft_amount_order_by!]
    "filter the rows returned"
    where: fn_nft_amount_bool_exp
  ): [fn_nft_amount!]!
  "fetch aggregated fields from the table: \"fn_nft_amount\""
  fn_nft_amount_aggregate(
    "distinct select on columns"
    distinct_on: [fn_nft_amount_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [fn_nft_amount_order_by!]
    "filter the rows returned"
    where: fn_nft_amount_bool_exp
  ): fn_nft_amount_aggregate!
  "fetch data from the table: \"fn_nft_amount\" using primary key columns"
  fn_nft_amount_by_pk(account: String!, contract: String!): fn_nft_amount
  "fetch data from the table: \"fn_nft_count\""
  fn_nft_count(
    "distinct select on columns"
    distinct_on: [fn_nft_count_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [fn_nft_count_order_by!]
    "filter the rows returned"
    where: fn_nft_count_bool_exp
  ): [fn_nft_count!]!
  "fetch data from the table: \"fn_nft_count\" using primary key columns"
  fn_nft_count_by_pk(contract: String!): fn_nft_count
  "execute function \"ft_holders\" which returns \"fn_ft_amount\""
  ft_holders(
    "input parameters for function \"ft_holders\""
    args: ft_holders_args!
    "distinct select on columns"
    distinct_on: [fn_ft_amount_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [fn_ft_amount_order_by!]
    "filter the rows returned"
    where: fn_ft_amount_bool_exp
  ): [fn_ft_amount!]!
  "execute function \"ft_holders_count\" which returns \"fn_ft_count\""
  ft_holders_count(
    "input parameters for function \"ft_holders_count\""
    args: ft_holders_count_args!
    "distinct select on columns"
    distinct_on: [fn_ft_count_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [fn_ft_count_order_by!]
    "filter the rows returned"
    where: fn_ft_count_bool_exp
  ): [fn_ft_count!]!
  "execute function \"ft_inventory\" which returns \"fn_ft_amount\""
  ft_inventory(
    "input parameters for function \"ft_inventory\""
    args: ft_inventory_args!
    "distinct select on columns"
    distinct_on: [fn_ft_amount_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [fn_ft_amount_order_by!]
    "filter the rows returned"
    where: fn_ft_amount_bool_exp
  ): [fn_ft_amount!]!
  "execute function \"ft_inventory_count\" which returns \"fn_ft_count\""
  ft_inventory_count(
    "input parameters for function \"ft_inventory_count\""
    args: ft_inventory_count_args!
    "distinct select on columns"
    distinct_on: [fn_ft_count_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [fn_ft_count_order_by!]
    "filter the rows returned"
    where: fn_ft_count_bool_exp
  ): [fn_ft_count!]!
  "fetch data from the table: \"ft_list\""
  ft_list(
    "distinct select on columns"
    distinct_on: [ft_list_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_list_order_by!]
    "filter the rows returned"
    where: ft_list_bool_exp
  ): [ft_list!]!
  "fetch aggregated fields from the table: \"ft_list\""
  ft_list_aggregate(
    "distinct select on columns"
    distinct_on: [ft_list_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_list_order_by!]
    "filter the rows returned"
    where: ft_list_bool_exp
  ): ft_list_aggregate!
  "fetch data from the table: \"ft_meta\""
  ft_meta(
    "distinct select on columns"
    distinct_on: [ft_meta_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_meta_order_by!]
    "filter the rows returned"
    where: ft_meta_bool_exp
  ): [ft_meta!]!
  "fetch aggregated fields from the table: \"ft_meta\""
  ft_meta_aggregate(
    "distinct select on columns"
    distinct_on: [ft_meta_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [ft_meta_order_by!]
    "filter the rows returned"
    where: ft_meta_bool_exp
  ): ft_meta_aggregate!
  "fetch data from the table: \"ft_meta\" using primary key columns"
  ft_meta_by_pk(contract: String!): ft_meta
  "execute function \"nft_holders\" which returns \"fn_nft_amount\""
  nft_holders(
    "input parameters for function \"nft_holders\""
    args: nft_holders_args!
    "distinct select on columns"
    distinct_on: [fn_nft_amount_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [fn_nft_amount_order_by!]
    "filter the rows returned"
    where: fn_nft_amount_bool_exp
  ): [fn_nft_amount!]!
  "execute function \"nft_holders\" and query aggregates on result of table type \"fn_nft_amount\""
  nft_holders_aggregate(
    "input parameters for function \"nft_holders_aggregate\""
    args: nft_holders_args!
    "distinct select on columns"
    distinct_on: [fn_nft_amount_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [fn_nft_amount_order_by!]
    "filter the rows returned"
    where: fn_nft_amount_bool_exp
  ): fn_nft_amount_aggregate!
  "execute function \"nft_holders_count\" which returns \"fn_nft_count\""
  nft_holders_count(
    "input parameters for function \"nft_holders_count\""
    args: nft_holders_count_args!
    "distinct select on columns"
    distinct_on: [fn_nft_count_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [fn_nft_count_order_by!]
    "filter the rows returned"
    where: fn_nft_count_bool_exp
  ): [fn_nft_count!]!
  "fetch data from the table: \"nft_list\""
  nft_list(
    "distinct select on columns"
    distinct_on: [nft_list_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [nft_list_order_by!]
    "filter the rows returned"
    where: nft_list_bool_exp
  ): [nft_list!]!
  "fetch aggregated fields from the table: \"nft_list\""
  nft_list_aggregate(
    "distinct select on columns"
    distinct_on: [nft_list_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [nft_list_order_by!]
    "filter the rows returned"
    where: nft_list_bool_exp
  ): nft_list_aggregate!
  "fetch data from the table: \"nft_meta\""
  nft_meta(
    "distinct select on columns"
    distinct_on: [nft_meta_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [nft_meta_order_by!]
    "filter the rows returned"
    where: nft_meta_bool_exp
  ): [nft_meta!]!
  "fetch aggregated fields from the table: \"nft_meta\""
  nft_meta_aggregate(
    "distinct select on columns"
    distinct_on: [nft_meta_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [nft_meta_order_by!]
    "filter the rows returned"
    where: nft_meta_bool_exp
  ): nft_meta_aggregate!
  "fetch data from the table: \"nft_meta\" using primary key columns"
  nft_meta_by_pk(contract: String!): nft_meta
  "fetch data from the table: \"nft_token_meta\""
  nft_token_meta(
    "distinct select on columns"
    distinct_on: [nft_token_meta_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [nft_token_meta_order_by!]
    "filter the rows returned"
    where: nft_token_meta_bool_exp
  ): [nft_token_meta!]!
  "fetch aggregated fields from the table: \"nft_token_meta\""
  nft_token_meta_aggregate(
    "distinct select on columns"
    distinct_on: [nft_token_meta_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [nft_token_meta_order_by!]
    "filter the rows returned"
    where: nft_token_meta_bool_exp
  ): nft_token_meta_aggregate!
  "fetch data from the table: \"nft_token_meta\" using primary key columns"
  nft_token_meta_by_pk(contract: String!, token: String!): nft_token_meta
  "An array relationship"
  receipts(
    "distinct select on columns"
    distinct_on: [receipts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [receipts_order_by!]
    "filter the rows returned"
    where: receipts_bool_exp
  ): [receipts!]!
  "An aggregate relationship"
  receipts_aggregate(
    "distinct select on columns"
    distinct_on: [receipts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [receipts_order_by!]
    "filter the rows returned"
    where: receipts_bool_exp
  ): receipts_aggregate!
  "fetch data from the table: \"receipts\" using primary key columns"
  receipts_by_pk(receipt_id: String!): receipts
  "fetch data from the table: \"stats\""
  stats(
    "distinct select on columns"
    distinct_on: [stats_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [stats_order_by!]
    "filter the rows returned"
    where: stats_bool_exp
  ): [stats!]!
  "fetch aggregated fields from the table: \"stats\""
  stats_aggregate(
    "distinct select on columns"
    distinct_on: [stats_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [stats_order_by!]
    "filter the rows returned"
    where: stats_bool_exp
  ): stats_aggregate!
  "fetch data from the table: \"stats\" using primary key columns"
  stats_by_pk(id: Int!): stats
  "An array relationship"
  transactions(
    "distinct select on columns"
    distinct_on: [transactions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [transactions_order_by!]
    "filter the rows returned"
    where: transactions_bool_exp
  ): [transactions!]!
  "An aggregate relationship"
  transactions_aggregate(
    "distinct select on columns"
    distinct_on: [transactions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [transactions_order_by!]
    "filter the rows returned"
    where: transactions_bool_exp
  ): transactions_aggregate!
  "fetch data from the table: \"transactions\" using primary key columns"
  transactions_by_pk(transaction_hash: String!): transactions
  "execute function \"txn_export\" which returns \"transactions\""
  txn_export(
    "input parameters for function \"txn_export\""
    args: txn_export_args!
    "distinct select on columns"
    distinct_on: [transactions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [transactions_order_by!]
    "filter the rows returned"
    where: transactions_bool_exp
  ): [transactions!]!
  "execute function \"txn_export\" and query aggregates on result of table type \"transactions\""
  txn_export_aggregate(
    "input parameters for function \"txn_export_aggregate\""
    args: txn_export_args!
    "distinct select on columns"
    distinct_on: [transactions_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [transactions_order_by!]
    "filter the rows returned"
    where: transactions_bool_exp
  ): transactions_aggregate!
}

"columns and relationships of \"transactions\""
type transactions {
  "An object relationship"
  block: blocks!
  block_timestamp: numeric!
  "An object relationship"
  chunk: chunks!
  converted_into_receipt_id: String!
  included_in_block_hash: String!
  included_in_chunk_hash: String!
  index_in_chunk: Int!
  nonce: numeric!
  receipt_conversion_gas_burnt: numeric
  receipt_conversion_tokens_burnt: numeric
  "An array relationship"
  receipts(
    "distinct select on columns"
    distinct_on: [receipts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [receipts_order_by!]
    "filter the rows returned"
    where: receipts_bool_exp
  ): [receipts!]!
  "An aggregate relationship"
  receipts_aggregate(
    "distinct select on columns"
    distinct_on: [receipts_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [receipts_order_by!]
    "filter the rows returned"
    where: receipts_bool_exp
  ): receipts_aggregate!
  receiver_account_id: String!
  signature: String!
  signer_account_id: String!
  signer_public_key: String!
  status: execution_outcome_status!
  transaction_hash: String!
}

"aggregated selection of \"transactions\""
type transactions_aggregate {
  aggregate: transactions_aggregate_fields
  nodes: [transactions!]!
}

"aggregate fields of \"transactions\""
type transactions_aggregate_fields {
  avg: transactions_avg_fields
  count(columns: [transactions_select_column!], distinct: Boolean): Int!
  max: transactions_max_fields
  min: transactions_min_fields
  stddev: transactions_stddev_fields
  stddev_pop: transactions_stddev_pop_fields
  stddev_samp: transactions_stddev_samp_fields
  sum: transactions_sum_fields
  var_pop: transactions_var_pop_fields
  var_samp: transactions_var_samp_fields
  variance: transactions_variance_fields
}

"aggregate avg on columns"
type transactions_avg_fields {
  block_timestamp: Float
  index_in_chunk: Float
  nonce: Float
  receipt_conversion_gas_burnt: Float
  receipt_conversion_tokens_burnt: Float
}

"aggregate max on columns"
type transactions_max_fields {
  block_timestamp: numeric
  converted_into_receipt_id: String
  included_in_block_hash: String
  included_in_chunk_hash: String
  index_in_chunk: Int
  nonce: numeric
  receipt_conversion_gas_burnt: numeric
  receipt_conversion_tokens_burnt: numeric
  receiver_account_id: String
  signature: String
  signer_account_id: String
  signer_public_key: String
  status: execution_outcome_status
  transaction_hash: String
}

"aggregate min on columns"
type transactions_min_fields {
  block_timestamp: numeric
  converted_into_receipt_id: String
  included_in_block_hash: String
  included_in_chunk_hash: String
  index_in_chunk: Int
  nonce: numeric
  receipt_conversion_gas_burnt: numeric
  receipt_conversion_tokens_burnt: numeric
  receiver_account_id: String
  signature: String
  signer_account_id: String
  signer_public_key: String
  status: execution_outcome_status
  transaction_hash: String
}

"aggregate stddev on columns"
type transactions_stddev_fields {
  block_timestamp: Float
  index_in_chunk: Float
  nonce: Float
  receipt_conversion_gas_burnt: Float
  receipt_conversion_tokens_burnt: Float
}

"aggregate stddev_pop on columns"
type transactions_stddev_pop_fields {
  block_timestamp: Float
  index_in_chunk: Float
  nonce: Float
  receipt_conversion_gas_burnt: Float
  receipt_conversion_tokens_burnt: Float
}

"aggregate stddev_samp on columns"
type transactions_stddev_samp_fields {
  block_timestamp: Float
  index_in_chunk: Float
  nonce: Float
  receipt_conversion_gas_burnt: Float
  receipt_conversion_tokens_burnt: Float
}

"aggregate sum on columns"
type transactions_sum_fields {
  block_timestamp: numeric
  index_in_chunk: Int
  nonce: numeric
  receipt_conversion_gas_burnt: numeric
  receipt_conversion_tokens_burnt: numeric
}

"aggregate var_pop on columns"
type transactions_var_pop_fields {
  block_timestamp: Float
  index_in_chunk: Float
  nonce: Float
  receipt_conversion_gas_burnt: Float
  receipt_conversion_tokens_burnt: Float
}

"aggregate var_samp on columns"
type transactions_var_samp_fields {
  block_timestamp: Float
  index_in_chunk: Float
  nonce: Float
  receipt_conversion_gas_burnt: Float
  receipt_conversion_tokens_burnt: Float
}

"aggregate variance on columns"
type transactions_variance_fields {
  block_timestamp: Float
  index_in_chunk: Float
  nonce: Float
  receipt_conversion_gas_burnt: Float
  receipt_conversion_tokens_burnt: Float
}

"select columns of table \"access_keys\""
enum access_keys_select_column {
  "column name"
  account_id
  "column name"
  created_by_receipt_id
  "column name"
  deleted_by_receipt_id
  "column name"
  last_update_block_height
  "column name"
  permission_kind
  "column name"
  public_key
}

"select columns of table \"accounts\""
enum accounts_select_column {
  "column name"
  account_id
  "column name"
  created_by_receipt_id
  "column name"
  deleted_by_receipt_id
  "column name"
  id
  "column name"
  last_update_block_height
}

"select columns of table \"action_receipt_actions\""
enum action_receipt_actions_select_column {
  "column name"
  action_kind
  "column name"
  args
  "column name"
  index_in_action_receipt
  "column name"
  receipt_id
  "column name"
  receipt_included_in_block_timestamp
  "column name"
  receipt_predecessor_account_id
  "column name"
  receipt_receiver_account_id
}

"select columns of table \"assets__fungible_token_events\""
enum assets__fungible_token_events_select_column {
  "column name"
  amount
  "column name"
  emitted_at_block_timestamp
  "column name"
  emitted_by_contract_account_id
  "column name"
  emitted_for_event_type
  "column name"
  emitted_for_receipt_id
  "column name"
  emitted_in_shard_id
  "column name"
  emitted_index_of_event_entry_in_shard
  "column name"
  event_kind
  "column name"
  event_memo
  "column name"
  token_new_owner_account_id
  "column name"
  token_old_owner_account_id
}

"select columns of table \"assets__non_fungible_token_events\""
enum assets__non_fungible_token_events_select_column {
  "column name"
  emitted_at_block_timestamp
  "column name"
  emitted_by_contract_account_id
  "column name"
  emitted_for_event_type
  "column name"
  emitted_for_receipt_id
  "column name"
  emitted_in_shard_id
  "column name"
  emitted_index_of_event_entry_in_shard
  "column name"
  event_kind
  "column name"
  event_memo
  "column name"
  token_authorized_account_id
  "column name"
  token_id
  "column name"
  token_new_owner_account_id
  "column name"
  token_old_owner_account_id
}

"select columns of table \"blocks\""
enum blocks_select_column {
  "column name"
  author_account_id
  "column name"
  block_hash
  "column name"
  block_height
  "column name"
  block_timestamp
  "column name"
  gas_price
  "column name"
  prev_block_hash
  "column name"
  total_supply
}

"select columns of table \"chunks\""
enum chunks_select_column {
  "column name"
  author_account_id
  "column name"
  chunk_hash
  "column name"
  gas_limit
  "column name"
  gas_used
  "column name"
  included_in_block_hash
  "column name"
  shard_id
  "column name"
  signature
}

"select columns of table \"daily_stats\""
enum daily_stats_select_column {
  "column name"
  addresses
  "column name"
  avg_gas_limit
  "column name"
  avg_gas_price
  "column name"
  blocks
  "column name"
  date
  "column name"
  gas_fee
  "column name"
  gas_used
  "column name"
  market_cap
  "column name"
  near_price
  "column name"
  total_addresses
  "column name"
  total_supply
  "column name"
  txn_fee
  "column name"
  txn_fee_usd
  "column name"
  txn_volume
  "column name"
  txn_volume_usd
  "column name"
  txns
}

"select columns of table \"execution_outcomes\""
enum execution_outcomes_select_column {
  "column name"
  executed_in_block_hash
  "column name"
  executed_in_block_timestamp
  "column name"
  executor_account_id
  "column name"
  gas_burnt
  "column name"
  index_in_chunk
  "column name"
  logs
  "column name"
  receipt_id
  "column name"
  shard_id
  "column name"
  status
  "column name"
  tokens_burnt
}

"select columns of table \"fn_ft_amount\""
enum fn_ft_amount_select_column {
  "column name"
  account
  "column name"
  amount
  "column name"
  contract
  "column name"
  rank
}

"select columns of table \"fn_ft_count\""
enum fn_ft_count_select_column {
  "column name"
  contract
  "column name"
  count
}

"select columns of table \"fn_nft_amount\""
enum fn_nft_amount_select_column {
  "column name"
  account
  "column name"
  contract
  "column name"
  quantity
  "column name"
  rank
}

"select columns of table \"fn_nft_count\""
enum fn_nft_count_select_column {
  "column name"
  contract
  "column name"
  count
}

"select columns of table \"ft_list\""
enum ft_list_select_column {
  "column name"
  change_24
  "column name"
  contract
  "column name"
  holders
  "column name"
  market_cap
  "column name"
  name
  "column name"
  price
  "column name"
  symbol
  "column name"
  total_supply
  "column name"
  transfers
  "column name"
  volume_24h
}

"select columns of table \"ft_meta\""
enum ft_meta_select_column {
  "column name"
  change_24
  "column name"
  circulating_supply
  "column name"
  coingecko_id
  "column name"
  coinmarketcap_id
  "column name"
  contract
  "column name"
  decimals
  "column name"
  description
  "column name"
  facebook
  "column name"
  fully_diluted_market_cap
  "column name"
  icon
  "column name"
  market_cap
  "column name"
  name
  "column name"
  price
  "column name"
  price_btc
  "column name"
  price_eth
  "column name"
  reddit
  "column name"
  reference
  "column name"
  reference_hash
  "column name"
  spec
  "column name"
  symbol
  "column name"
  telegram
  "column name"
  twitter
  "column name"
  volume_24h
  "column name"
  website
}

"select columns of table \"nft_list\""
enum nft_list_select_column {
  "column name"
  contract
  "column name"
  name
  "column name"
  symbol
  "column name"
  tokens
  "column name"
  transfers
  "column name"
  transfers_3days
  "column name"
  transfers_day
}

"select columns of table \"nft_meta\""
enum nft_meta_select_column {
  "column name"
  base_uri
  "column name"
  contract
  "column name"
  description
  "column name"
  facebook
  "column name"
  icon
  "column name"
  name
  "column name"
  reddit
  "column name"
  reference
  "column name"
  reference_hash
  "column name"
  spec
  "column name"
  symbol
  "column name"
  telegram
  "column name"
  twitter
  "column name"
  website
}

"select columns of table \"nft_token_meta\""
enum nft_token_meta_select_column {
  "column name"
  contract
  "column name"
  copies
  "column name"
  description
  "column name"
  extra
  "column name"
  media
  "column name"
  media_hash
  "column name"
  reference
  "column name"
  reference_hash
  "column name"
  title
  "column name"
  token
}

"column ordering options"
enum order_by {
  "in ascending order, nulls last"
  asc
  "in ascending order, nulls first"
  asc_nulls_first
  "in ascending order, nulls last"
  asc_nulls_last
  "in descending order, nulls first"
  desc
  "in descending order, nulls first"
  desc_nulls_first
  "in descending order, nulls last"
  desc_nulls_last
}

"select columns of table \"receipts\""
enum receipts_select_column {
  "column name"
  included_in_block_hash
  "column name"
  included_in_block_timestamp
  "column name"
  included_in_chunk_hash
  "column name"
  index_in_chunk
  "column name"
  originated_from_transaction_hash
  "column name"
  predecessor_account_id
  "column name"
  receipt_id
  "column name"
  receipt_kind
  "column name"
  receiver_account_id
}

"select columns of table \"stats\""
enum stats_select_column {
  "column name"
  avg_block_time
  "column name"
  block
  "column name"
  change_24
  "column name"
  gas_price
  "column name"
  high_24h
  "column name"
  high_all
  "column name"
  id
  "column name"
  low_24h
  "column name"
  low_all
  "column name"
  market_cap
  "column name"
  near_btc_price
  "column name"
  near_price
  "column name"
  nodes
  "column name"
  nodes_online
  "column name"
  total_supply
  "column name"
  total_txns
  "column name"
  volume
}

"select columns of table \"transactions\""
enum transactions_select_column {
  "column name"
  block_timestamp
  "column name"
  converted_into_receipt_id
  "column name"
  included_in_block_hash
  "column name"
  included_in_chunk_hash
  "column name"
  index_in_chunk
  "column name"
  nonce
  "column name"
  receipt_conversion_gas_burnt
  "column name"
  receipt_conversion_tokens_burnt
  "column name"
  receiver_account_id
  "column name"
  signature
  "column name"
  signer_account_id
  "column name"
  signer_public_key
  "column name"
  status
  "column name"
  transaction_hash
}

scalar access_key_permission_kind

scalar action_kind

scalar bigint

scalar date

scalar execution_outcome_status

scalar ft_event_kind

scalar jsonb

scalar nft_event_kind

scalar numeric

scalar receipt_kind

"Boolean expression to compare columns of type \"Int\". All fields are combined with logical 'AND'."
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"Boolean expression to compare columns of type \"String\". All fields are combined with logical 'AND'."
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  "does the column match the given case-insensitive pattern"
  _ilike: String
  _in: [String!]
  "does the column match the given POSIX regular expression, case insensitive"
  _iregex: String
  _is_null: Boolean
  "does the column match the given pattern"
  _like: String
  _lt: String
  _lte: String
  _neq: String
  "does the column NOT match the given case-insensitive pattern"
  _nilike: String
  _nin: [String!]
  "does the column NOT match the given POSIX regular expression, case insensitive"
  _niregex: String
  "does the column NOT match the given pattern"
  _nlike: String
  "does the column NOT match the given POSIX regular expression, case sensitive"
  _nregex: String
  "does the column NOT match the given SQL regular expression"
  _nsimilar: String
  "does the column match the given POSIX regular expression, case sensitive"
  _regex: String
  "does the column match the given SQL regular expression"
  _similar: String
}

"Boolean expression to compare columns of type \"access_key_permission_kind\". All fields are combined with logical 'AND'."
input access_key_permission_kind_comparison_exp {
  _eq: access_key_permission_kind
  _gt: access_key_permission_kind
  _gte: access_key_permission_kind
  _in: [access_key_permission_kind!]
  _is_null: Boolean
  _lt: access_key_permission_kind
  _lte: access_key_permission_kind
  _neq: access_key_permission_kind
  _nin: [access_key_permission_kind!]
}

"order by aggregate values of table \"access_keys\""
input access_keys_aggregate_order_by {
  avg: access_keys_avg_order_by
  count: order_by
  max: access_keys_max_order_by
  min: access_keys_min_order_by
  stddev: access_keys_stddev_order_by
  stddev_pop: access_keys_stddev_pop_order_by
  stddev_samp: access_keys_stddev_samp_order_by
  sum: access_keys_sum_order_by
  var_pop: access_keys_var_pop_order_by
  var_samp: access_keys_var_samp_order_by
  variance: access_keys_variance_order_by
}

"order by avg() on columns of table \"access_keys\""
input access_keys_avg_order_by {
  last_update_block_height: order_by
}

"Boolean expression to filter rows from the table \"access_keys\". All fields are combined with a logical 'AND'."
input access_keys_bool_exp {
  _and: [access_keys_bool_exp!]
  _not: access_keys_bool_exp
  _or: [access_keys_bool_exp!]
  account_id: String_comparison_exp
  block: blocks_bool_exp
  created_by_receipt_id: String_comparison_exp
  deleted_by_receipt_id: String_comparison_exp
  last_update_block_height: numeric_comparison_exp
  permission_kind: access_key_permission_kind_comparison_exp
  public_key: String_comparison_exp
  receipt: receipts_bool_exp
  receiptByDeletedByReceiptId: receipts_bool_exp
}

"order by max() on columns of table \"access_keys\""
input access_keys_max_order_by {
  account_id: order_by
  created_by_receipt_id: order_by
  deleted_by_receipt_id: order_by
  last_update_block_height: order_by
  permission_kind: order_by
  public_key: order_by
}

"order by min() on columns of table \"access_keys\""
input access_keys_min_order_by {
  account_id: order_by
  created_by_receipt_id: order_by
  deleted_by_receipt_id: order_by
  last_update_block_height: order_by
  permission_kind: order_by
  public_key: order_by
}

"Ordering options when selecting data from \"access_keys\"."
input access_keys_order_by {
  account_id: order_by
  block: blocks_order_by
  created_by_receipt_id: order_by
  deleted_by_receipt_id: order_by
  last_update_block_height: order_by
  permission_kind: order_by
  public_key: order_by
  receipt: receipts_order_by
  receiptByDeletedByReceiptId: receipts_order_by
}

"order by stddev() on columns of table \"access_keys\""
input access_keys_stddev_order_by {
  last_update_block_height: order_by
}

"order by stddev_pop() on columns of table \"access_keys\""
input access_keys_stddev_pop_order_by {
  last_update_block_height: order_by
}

"order by stddev_samp() on columns of table \"access_keys\""
input access_keys_stddev_samp_order_by {
  last_update_block_height: order_by
}

"order by sum() on columns of table \"access_keys\""
input access_keys_sum_order_by {
  last_update_block_height: order_by
}

"order by var_pop() on columns of table \"access_keys\""
input access_keys_var_pop_order_by {
  last_update_block_height: order_by
}

"order by var_samp() on columns of table \"access_keys\""
input access_keys_var_samp_order_by {
  last_update_block_height: order_by
}

"order by variance() on columns of table \"access_keys\""
input access_keys_variance_order_by {
  last_update_block_height: order_by
}

"order by aggregate values of table \"accounts\""
input accounts_aggregate_order_by {
  avg: accounts_avg_order_by
  count: order_by
  max: accounts_max_order_by
  min: accounts_min_order_by
  stddev: accounts_stddev_order_by
  stddev_pop: accounts_stddev_pop_order_by
  stddev_samp: accounts_stddev_samp_order_by
  sum: accounts_sum_order_by
  var_pop: accounts_var_pop_order_by
  var_samp: accounts_var_samp_order_by
  variance: accounts_variance_order_by
}

"order by avg() on columns of table \"accounts\""
input accounts_avg_order_by {
  id: order_by
  last_update_block_height: order_by
}

"Boolean expression to filter rows from the table \"accounts\". All fields are combined with a logical 'AND'."
input accounts_bool_exp {
  _and: [accounts_bool_exp!]
  _not: accounts_bool_exp
  _or: [accounts_bool_exp!]
  account_id: String_comparison_exp
  created_by_receipt_id: String_comparison_exp
  deleted_by_receipt_id: String_comparison_exp
  id: bigint_comparison_exp
  last_update_block_height: numeric_comparison_exp
  receipt: receipts_bool_exp
  receiptByDeletedByReceiptId: receipts_bool_exp
}

"order by max() on columns of table \"accounts\""
input accounts_max_order_by {
  account_id: order_by
  created_by_receipt_id: order_by
  deleted_by_receipt_id: order_by
  id: order_by
  last_update_block_height: order_by
}

"order by min() on columns of table \"accounts\""
input accounts_min_order_by {
  account_id: order_by
  created_by_receipt_id: order_by
  deleted_by_receipt_id: order_by
  id: order_by
  last_update_block_height: order_by
}

"Ordering options when selecting data from \"accounts\"."
input accounts_order_by {
  account_id: order_by
  created_by_receipt_id: order_by
  deleted_by_receipt_id: order_by
  id: order_by
  last_update_block_height: order_by
  receipt: receipts_order_by
  receiptByDeletedByReceiptId: receipts_order_by
}

"order by stddev() on columns of table \"accounts\""
input accounts_stddev_order_by {
  id: order_by
  last_update_block_height: order_by
}

"order by stddev_pop() on columns of table \"accounts\""
input accounts_stddev_pop_order_by {
  id: order_by
  last_update_block_height: order_by
}

"order by stddev_samp() on columns of table \"accounts\""
input accounts_stddev_samp_order_by {
  id: order_by
  last_update_block_height: order_by
}

"order by sum() on columns of table \"accounts\""
input accounts_sum_order_by {
  id: order_by
  last_update_block_height: order_by
}

"order by var_pop() on columns of table \"accounts\""
input accounts_var_pop_order_by {
  id: order_by
  last_update_block_height: order_by
}

"order by var_samp() on columns of table \"accounts\""
input accounts_var_samp_order_by {
  id: order_by
  last_update_block_height: order_by
}

"order by variance() on columns of table \"accounts\""
input accounts_variance_order_by {
  id: order_by
  last_update_block_height: order_by
}

"Boolean expression to compare columns of type \"action_kind\". All fields are combined with logical 'AND'."
input action_kind_comparison_exp {
  _eq: action_kind
  _gt: action_kind
  _gte: action_kind
  _in: [action_kind!]
  _is_null: Boolean
  _lt: action_kind
  _lte: action_kind
  _neq: action_kind
  _nin: [action_kind!]
}

"order by aggregate values of table \"action_receipt_actions\""
input action_receipt_actions_aggregate_order_by {
  avg: action_receipt_actions_avg_order_by
  count: order_by
  max: action_receipt_actions_max_order_by
  min: action_receipt_actions_min_order_by
  stddev: action_receipt_actions_stddev_order_by
  stddev_pop: action_receipt_actions_stddev_pop_order_by
  stddev_samp: action_receipt_actions_stddev_samp_order_by
  sum: action_receipt_actions_sum_order_by
  var_pop: action_receipt_actions_var_pop_order_by
  var_samp: action_receipt_actions_var_samp_order_by
  variance: action_receipt_actions_variance_order_by
}

"order by avg() on columns of table \"action_receipt_actions\""
input action_receipt_actions_avg_order_by {
  index_in_action_receipt: order_by
  receipt_included_in_block_timestamp: order_by
}

"Boolean expression to filter rows from the table \"action_receipt_actions\". All fields are combined with a logical 'AND'."
input action_receipt_actions_bool_exp {
  _and: [action_receipt_actions_bool_exp!]
  _not: action_receipt_actions_bool_exp
  _or: [action_receipt_actions_bool_exp!]
  action_kind: action_kind_comparison_exp
  args: jsonb_comparison_exp
  index_in_action_receipt: Int_comparison_exp
  receipt: receipts_bool_exp
  receipt_id: String_comparison_exp
  receipt_included_in_block_timestamp: numeric_comparison_exp
  receipt_predecessor_account_id: String_comparison_exp
  receipt_receiver_account_id: String_comparison_exp
}

"order by max() on columns of table \"action_receipt_actions\""
input action_receipt_actions_max_order_by {
  action_kind: order_by
  index_in_action_receipt: order_by
  receipt_id: order_by
  receipt_included_in_block_timestamp: order_by
  receipt_predecessor_account_id: order_by
  receipt_receiver_account_id: order_by
}

"order by min() on columns of table \"action_receipt_actions\""
input action_receipt_actions_min_order_by {
  action_kind: order_by
  index_in_action_receipt: order_by
  receipt_id: order_by
  receipt_included_in_block_timestamp: order_by
  receipt_predecessor_account_id: order_by
  receipt_receiver_account_id: order_by
}

"Ordering options when selecting data from \"action_receipt_actions\"."
input action_receipt_actions_order_by {
  action_kind: order_by
  args: order_by
  index_in_action_receipt: order_by
  receipt: receipts_order_by
  receipt_id: order_by
  receipt_included_in_block_timestamp: order_by
  receipt_predecessor_account_id: order_by
  receipt_receiver_account_id: order_by
}

"order by stddev() on columns of table \"action_receipt_actions\""
input action_receipt_actions_stddev_order_by {
  index_in_action_receipt: order_by
  receipt_included_in_block_timestamp: order_by
}

"order by stddev_pop() on columns of table \"action_receipt_actions\""
input action_receipt_actions_stddev_pop_order_by {
  index_in_action_receipt: order_by
  receipt_included_in_block_timestamp: order_by
}

"order by stddev_samp() on columns of table \"action_receipt_actions\""
input action_receipt_actions_stddev_samp_order_by {
  index_in_action_receipt: order_by
  receipt_included_in_block_timestamp: order_by
}

"order by sum() on columns of table \"action_receipt_actions\""
input action_receipt_actions_sum_order_by {
  index_in_action_receipt: order_by
  receipt_included_in_block_timestamp: order_by
}

"order by var_pop() on columns of table \"action_receipt_actions\""
input action_receipt_actions_var_pop_order_by {
  index_in_action_receipt: order_by
  receipt_included_in_block_timestamp: order_by
}

"order by var_samp() on columns of table \"action_receipt_actions\""
input action_receipt_actions_var_samp_order_by {
  index_in_action_receipt: order_by
  receipt_included_in_block_timestamp: order_by
}

"order by variance() on columns of table \"action_receipt_actions\""
input action_receipt_actions_variance_order_by {
  index_in_action_receipt: order_by
  receipt_included_in_block_timestamp: order_by
}

"order by aggregate values of table \"assets__fungible_token_events\""
input assets__fungible_token_events_aggregate_order_by {
  avg: assets__fungible_token_events_avg_order_by
  count: order_by
  max: assets__fungible_token_events_max_order_by
  min: assets__fungible_token_events_min_order_by
  stddev: assets__fungible_token_events_stddev_order_by
  stddev_pop: assets__fungible_token_events_stddev_pop_order_by
  stddev_samp: assets__fungible_token_events_stddev_samp_order_by
  sum: assets__fungible_token_events_sum_order_by
  var_pop: assets__fungible_token_events_var_pop_order_by
  var_samp: assets__fungible_token_events_var_samp_order_by
  variance: assets__fungible_token_events_variance_order_by
}

"order by avg() on columns of table \"assets__fungible_token_events\""
input assets__fungible_token_events_avg_order_by {
  emitted_at_block_timestamp: order_by
  emitted_for_event_type: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
}

"Boolean expression to filter rows from the table \"assets__fungible_token_events\". All fields are combined with a logical 'AND'."
input assets__fungible_token_events_bool_exp {
  _and: [assets__fungible_token_events_bool_exp!]
  _not: assets__fungible_token_events_bool_exp
  _or: [assets__fungible_token_events_bool_exp!]
  amount: String_comparison_exp
  emitted_at_block_timestamp: numeric_comparison_exp
  emitted_by_contract_account_id: String_comparison_exp
  emitted_for_event_type: Int_comparison_exp
  emitted_for_receipt_id: String_comparison_exp
  emitted_in_shard_id: numeric_comparison_exp
  emitted_index_of_event_entry_in_shard: Int_comparison_exp
  event_kind: ft_event_kind_comparison_exp
  event_memo: String_comparison_exp
  ft_meta: ft_meta_bool_exp
  receipt: receipts_bool_exp
  token_new_owner_account_id: String_comparison_exp
  token_old_owner_account_id: String_comparison_exp
}

"order by max() on columns of table \"assets__fungible_token_events\""
input assets__fungible_token_events_max_order_by {
  amount: order_by
  emitted_at_block_timestamp: order_by
  emitted_by_contract_account_id: order_by
  emitted_for_event_type: order_by
  emitted_for_receipt_id: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
  event_kind: order_by
  event_memo: order_by
  token_new_owner_account_id: order_by
  token_old_owner_account_id: order_by
}

"order by min() on columns of table \"assets__fungible_token_events\""
input assets__fungible_token_events_min_order_by {
  amount: order_by
  emitted_at_block_timestamp: order_by
  emitted_by_contract_account_id: order_by
  emitted_for_event_type: order_by
  emitted_for_receipt_id: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
  event_kind: order_by
  event_memo: order_by
  token_new_owner_account_id: order_by
  token_old_owner_account_id: order_by
}

"Ordering options when selecting data from \"assets__fungible_token_events\"."
input assets__fungible_token_events_order_by {
  amount: order_by
  emitted_at_block_timestamp: order_by
  emitted_by_contract_account_id: order_by
  emitted_for_event_type: order_by
  emitted_for_receipt_id: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
  event_kind: order_by
  event_memo: order_by
  ft_meta: ft_meta_order_by
  receipt: receipts_order_by
  token_new_owner_account_id: order_by
  token_old_owner_account_id: order_by
}

"order by stddev() on columns of table \"assets__fungible_token_events\""
input assets__fungible_token_events_stddev_order_by {
  emitted_at_block_timestamp: order_by
  emitted_for_event_type: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
}

"order by stddev_pop() on columns of table \"assets__fungible_token_events\""
input assets__fungible_token_events_stddev_pop_order_by {
  emitted_at_block_timestamp: order_by
  emitted_for_event_type: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
}

"order by stddev_samp() on columns of table \"assets__fungible_token_events\""
input assets__fungible_token_events_stddev_samp_order_by {
  emitted_at_block_timestamp: order_by
  emitted_for_event_type: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
}

"order by sum() on columns of table \"assets__fungible_token_events\""
input assets__fungible_token_events_sum_order_by {
  emitted_at_block_timestamp: order_by
  emitted_for_event_type: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
}

"order by var_pop() on columns of table \"assets__fungible_token_events\""
input assets__fungible_token_events_var_pop_order_by {
  emitted_at_block_timestamp: order_by
  emitted_for_event_type: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
}

"order by var_samp() on columns of table \"assets__fungible_token_events\""
input assets__fungible_token_events_var_samp_order_by {
  emitted_at_block_timestamp: order_by
  emitted_for_event_type: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
}

"order by variance() on columns of table \"assets__fungible_token_events\""
input assets__fungible_token_events_variance_order_by {
  emitted_at_block_timestamp: order_by
  emitted_for_event_type: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
}

"order by aggregate values of table \"assets__non_fungible_token_events\""
input assets__non_fungible_token_events_aggregate_order_by {
  avg: assets__non_fungible_token_events_avg_order_by
  count: order_by
  max: assets__non_fungible_token_events_max_order_by
  min: assets__non_fungible_token_events_min_order_by
  stddev: assets__non_fungible_token_events_stddev_order_by
  stddev_pop: assets__non_fungible_token_events_stddev_pop_order_by
  stddev_samp: assets__non_fungible_token_events_stddev_samp_order_by
  sum: assets__non_fungible_token_events_sum_order_by
  var_pop: assets__non_fungible_token_events_var_pop_order_by
  var_samp: assets__non_fungible_token_events_var_samp_order_by
  variance: assets__non_fungible_token_events_variance_order_by
}

"order by avg() on columns of table \"assets__non_fungible_token_events\""
input assets__non_fungible_token_events_avg_order_by {
  emitted_at_block_timestamp: order_by
  emitted_for_event_type: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
}

"Boolean expression to filter rows from the table \"assets__non_fungible_token_events\". All fields are combined with a logical 'AND'."
input assets__non_fungible_token_events_bool_exp {
  _and: [assets__non_fungible_token_events_bool_exp!]
  _not: assets__non_fungible_token_events_bool_exp
  _or: [assets__non_fungible_token_events_bool_exp!]
  emitted_at_block_timestamp: numeric_comparison_exp
  emitted_by_contract_account_id: String_comparison_exp
  emitted_for_event_type: Int_comparison_exp
  emitted_for_receipt_id: String_comparison_exp
  emitted_in_shard_id: numeric_comparison_exp
  emitted_index_of_event_entry_in_shard: Int_comparison_exp
  event_kind: nft_event_kind_comparison_exp
  event_memo: String_comparison_exp
  nft_meta: nft_meta_bool_exp
  nft_token_meta: nft_token_meta_bool_exp
  receipt: receipts_bool_exp
  token_authorized_account_id: String_comparison_exp
  token_id: String_comparison_exp
  token_new_owner_account_id: String_comparison_exp
  token_old_owner_account_id: String_comparison_exp
}

"order by max() on columns of table \"assets__non_fungible_token_events\""
input assets__non_fungible_token_events_max_order_by {
  emitted_at_block_timestamp: order_by
  emitted_by_contract_account_id: order_by
  emitted_for_event_type: order_by
  emitted_for_receipt_id: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
  event_kind: order_by
  event_memo: order_by
  token_authorized_account_id: order_by
  token_id: order_by
  token_new_owner_account_id: order_by
  token_old_owner_account_id: order_by
}

"order by min() on columns of table \"assets__non_fungible_token_events\""
input assets__non_fungible_token_events_min_order_by {
  emitted_at_block_timestamp: order_by
  emitted_by_contract_account_id: order_by
  emitted_for_event_type: order_by
  emitted_for_receipt_id: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
  event_kind: order_by
  event_memo: order_by
  token_authorized_account_id: order_by
  token_id: order_by
  token_new_owner_account_id: order_by
  token_old_owner_account_id: order_by
}

"Ordering options when selecting data from \"assets__non_fungible_token_events\"."
input assets__non_fungible_token_events_order_by {
  emitted_at_block_timestamp: order_by
  emitted_by_contract_account_id: order_by
  emitted_for_event_type: order_by
  emitted_for_receipt_id: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
  event_kind: order_by
  event_memo: order_by
  nft_meta: nft_meta_order_by
  nft_token_meta: nft_token_meta_order_by
  receipt: receipts_order_by
  token_authorized_account_id: order_by
  token_id: order_by
  token_new_owner_account_id: order_by
  token_old_owner_account_id: order_by
}

"order by stddev() on columns of table \"assets__non_fungible_token_events\""
input assets__non_fungible_token_events_stddev_order_by {
  emitted_at_block_timestamp: order_by
  emitted_for_event_type: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
}

"order by stddev_pop() on columns of table \"assets__non_fungible_token_events\""
input assets__non_fungible_token_events_stddev_pop_order_by {
  emitted_at_block_timestamp: order_by
  emitted_for_event_type: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
}

"order by stddev_samp() on columns of table \"assets__non_fungible_token_events\""
input assets__non_fungible_token_events_stddev_samp_order_by {
  emitted_at_block_timestamp: order_by
  emitted_for_event_type: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
}

"order by sum() on columns of table \"assets__non_fungible_token_events\""
input assets__non_fungible_token_events_sum_order_by {
  emitted_at_block_timestamp: order_by
  emitted_for_event_type: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
}

"order by var_pop() on columns of table \"assets__non_fungible_token_events\""
input assets__non_fungible_token_events_var_pop_order_by {
  emitted_at_block_timestamp: order_by
  emitted_for_event_type: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
}

"order by var_samp() on columns of table \"assets__non_fungible_token_events\""
input assets__non_fungible_token_events_var_samp_order_by {
  emitted_at_block_timestamp: order_by
  emitted_for_event_type: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
}

"order by variance() on columns of table \"assets__non_fungible_token_events\""
input assets__non_fungible_token_events_variance_order_by {
  emitted_at_block_timestamp: order_by
  emitted_for_event_type: order_by
  emitted_in_shard_id: order_by
  emitted_index_of_event_entry_in_shard: order_by
}

"Boolean expression to compare columns of type \"bigint\". All fields are combined with logical 'AND'."
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"Boolean expression to filter rows from the table \"blocks\". All fields are combined with a logical 'AND'."
input blocks_bool_exp {
  _and: [blocks_bool_exp!]
  _not: blocks_bool_exp
  _or: [blocks_bool_exp!]
  author_account_id: String_comparison_exp
  block_hash: String_comparison_exp
  block_height: numeric_comparison_exp
  block_timestamp: numeric_comparison_exp
  chunks: chunks_bool_exp
  execution_outcomes: execution_outcomes_bool_exp
  gas_price: numeric_comparison_exp
  prev_block_hash: String_comparison_exp
  receipts: receipts_bool_exp
  total_supply: numeric_comparison_exp
  transactions: transactions_bool_exp
}

"Ordering options when selecting data from \"blocks\"."
input blocks_order_by {
  author_account_id: order_by
  block_hash: order_by
  block_height: order_by
  block_timestamp: order_by
  chunks_aggregate: chunks_aggregate_order_by
  execution_outcomes_aggregate: execution_outcomes_aggregate_order_by
  gas_price: order_by
  prev_block_hash: order_by
  receipts_aggregate: receipts_aggregate_order_by
  total_supply: order_by
  transactions_aggregate: transactions_aggregate_order_by
}

"order by aggregate values of table \"chunks\""
input chunks_aggregate_order_by {
  avg: chunks_avg_order_by
  count: order_by
  max: chunks_max_order_by
  min: chunks_min_order_by
  stddev: chunks_stddev_order_by
  stddev_pop: chunks_stddev_pop_order_by
  stddev_samp: chunks_stddev_samp_order_by
  sum: chunks_sum_order_by
  var_pop: chunks_var_pop_order_by
  var_samp: chunks_var_samp_order_by
  variance: chunks_variance_order_by
}

"order by avg() on columns of table \"chunks\""
input chunks_avg_order_by {
  gas_limit: order_by
  gas_used: order_by
  shard_id: order_by
}

"Boolean expression to filter rows from the table \"chunks\". All fields are combined with a logical 'AND'."
input chunks_bool_exp {
  _and: [chunks_bool_exp!]
  _not: chunks_bool_exp
  _or: [chunks_bool_exp!]
  author_account_id: String_comparison_exp
  block: blocks_bool_exp
  chunk_hash: String_comparison_exp
  gas_limit: numeric_comparison_exp
  gas_used: numeric_comparison_exp
  included_in_block_hash: String_comparison_exp
  receipts: receipts_bool_exp
  shard_id: numeric_comparison_exp
  signature: String_comparison_exp
  transactions: transactions_bool_exp
}

"order by max() on columns of table \"chunks\""
input chunks_max_order_by {
  author_account_id: order_by
  chunk_hash: order_by
  gas_limit: order_by
  gas_used: order_by
  included_in_block_hash: order_by
  shard_id: order_by
  signature: order_by
}

"order by min() on columns of table \"chunks\""
input chunks_min_order_by {
  author_account_id: order_by
  chunk_hash: order_by
  gas_limit: order_by
  gas_used: order_by
  included_in_block_hash: order_by
  shard_id: order_by
  signature: order_by
}

"Ordering options when selecting data from \"chunks\"."
input chunks_order_by {
  author_account_id: order_by
  block: blocks_order_by
  chunk_hash: order_by
  gas_limit: order_by
  gas_used: order_by
  included_in_block_hash: order_by
  receipts_aggregate: receipts_aggregate_order_by
  shard_id: order_by
  signature: order_by
  transactions_aggregate: transactions_aggregate_order_by
}

"order by stddev() on columns of table \"chunks\""
input chunks_stddev_order_by {
  gas_limit: order_by
  gas_used: order_by
  shard_id: order_by
}

"order by stddev_pop() on columns of table \"chunks\""
input chunks_stddev_pop_order_by {
  gas_limit: order_by
  gas_used: order_by
  shard_id: order_by
}

"order by stddev_samp() on columns of table \"chunks\""
input chunks_stddev_samp_order_by {
  gas_limit: order_by
  gas_used: order_by
  shard_id: order_by
}

"order by sum() on columns of table \"chunks\""
input chunks_sum_order_by {
  gas_limit: order_by
  gas_used: order_by
  shard_id: order_by
}

"order by var_pop() on columns of table \"chunks\""
input chunks_var_pop_order_by {
  gas_limit: order_by
  gas_used: order_by
  shard_id: order_by
}

"order by var_samp() on columns of table \"chunks\""
input chunks_var_samp_order_by {
  gas_limit: order_by
  gas_used: order_by
  shard_id: order_by
}

"order by variance() on columns of table \"chunks\""
input chunks_variance_order_by {
  gas_limit: order_by
  gas_used: order_by
  shard_id: order_by
}

"Boolean expression to filter rows from the table \"daily_stats\". All fields are combined with a logical 'AND'."
input daily_stats_bool_exp {
  _and: [daily_stats_bool_exp!]
  _not: daily_stats_bool_exp
  _or: [daily_stats_bool_exp!]
  addresses: numeric_comparison_exp
  avg_gas_limit: numeric_comparison_exp
  avg_gas_price: numeric_comparison_exp
  blocks: numeric_comparison_exp
  date: date_comparison_exp
  gas_fee: numeric_comparison_exp
  gas_used: numeric_comparison_exp
  market_cap: numeric_comparison_exp
  near_price: numeric_comparison_exp
  total_addresses: numeric_comparison_exp
  total_supply: numeric_comparison_exp
  txn_fee: numeric_comparison_exp
  txn_fee_usd: numeric_comparison_exp
  txn_volume: numeric_comparison_exp
  txn_volume_usd: numeric_comparison_exp
  txns: numeric_comparison_exp
}

"Ordering options when selecting data from \"daily_stats\"."
input daily_stats_order_by {
  addresses: order_by
  avg_gas_limit: order_by
  avg_gas_price: order_by
  blocks: order_by
  date: order_by
  gas_fee: order_by
  gas_used: order_by
  market_cap: order_by
  near_price: order_by
  total_addresses: order_by
  total_supply: order_by
  txn_fee: order_by
  txn_fee_usd: order_by
  txn_volume: order_by
  txn_volume_usd: order_by
  txns: order_by
}

"Boolean expression to compare columns of type \"date\". All fields are combined with logical 'AND'."
input date_comparison_exp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _is_null: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

"Boolean expression to compare columns of type \"execution_outcome_status\". All fields are combined with logical 'AND'."
input execution_outcome_status_comparison_exp {
  _eq: execution_outcome_status
  _gt: execution_outcome_status
  _gte: execution_outcome_status
  _in: [execution_outcome_status!]
  _is_null: Boolean
  _lt: execution_outcome_status
  _lte: execution_outcome_status
  _neq: execution_outcome_status
  _nin: [execution_outcome_status!]
}

"order by aggregate values of table \"execution_outcomes\""
input execution_outcomes_aggregate_order_by {
  avg: execution_outcomes_avg_order_by
  count: order_by
  max: execution_outcomes_max_order_by
  min: execution_outcomes_min_order_by
  stddev: execution_outcomes_stddev_order_by
  stddev_pop: execution_outcomes_stddev_pop_order_by
  stddev_samp: execution_outcomes_stddev_samp_order_by
  sum: execution_outcomes_sum_order_by
  var_pop: execution_outcomes_var_pop_order_by
  var_samp: execution_outcomes_var_samp_order_by
  variance: execution_outcomes_variance_order_by
}

"order by avg() on columns of table \"execution_outcomes\""
input execution_outcomes_avg_order_by {
  executed_in_block_timestamp: order_by
  gas_burnt: order_by
  index_in_chunk: order_by
  shard_id: order_by
  tokens_burnt: order_by
}

"Boolean expression to filter rows from the table \"execution_outcomes\". All fields are combined with a logical 'AND'."
input execution_outcomes_bool_exp {
  _and: [execution_outcomes_bool_exp!]
  _not: execution_outcomes_bool_exp
  _or: [execution_outcomes_bool_exp!]
  block: blocks_bool_exp
  executed_in_block_hash: String_comparison_exp
  executed_in_block_timestamp: numeric_comparison_exp
  executor_account_id: String_comparison_exp
  gas_burnt: numeric_comparison_exp
  index_in_chunk: Int_comparison_exp
  logs: jsonb_comparison_exp
  receipt: receipts_bool_exp
  receipt_id: String_comparison_exp
  shard_id: numeric_comparison_exp
  status: execution_outcome_status_comparison_exp
  tokens_burnt: numeric_comparison_exp
}

"order by max() on columns of table \"execution_outcomes\""
input execution_outcomes_max_order_by {
  executed_in_block_hash: order_by
  executed_in_block_timestamp: order_by
  executor_account_id: order_by
  gas_burnt: order_by
  index_in_chunk: order_by
  receipt_id: order_by
  shard_id: order_by
  status: order_by
  tokens_burnt: order_by
}

"order by min() on columns of table \"execution_outcomes\""
input execution_outcomes_min_order_by {
  executed_in_block_hash: order_by
  executed_in_block_timestamp: order_by
  executor_account_id: order_by
  gas_burnt: order_by
  index_in_chunk: order_by
  receipt_id: order_by
  shard_id: order_by
  status: order_by
  tokens_burnt: order_by
}

"Ordering options when selecting data from \"execution_outcomes\"."
input execution_outcomes_order_by {
  block: blocks_order_by
  executed_in_block_hash: order_by
  executed_in_block_timestamp: order_by
  executor_account_id: order_by
  gas_burnt: order_by
  index_in_chunk: order_by
  logs: order_by
  receipt: receipts_order_by
  receipt_id: order_by
  shard_id: order_by
  status: order_by
  tokens_burnt: order_by
}

"order by stddev() on columns of table \"execution_outcomes\""
input execution_outcomes_stddev_order_by {
  executed_in_block_timestamp: order_by
  gas_burnt: order_by
  index_in_chunk: order_by
  shard_id: order_by
  tokens_burnt: order_by
}

"order by stddev_pop() on columns of table \"execution_outcomes\""
input execution_outcomes_stddev_pop_order_by {
  executed_in_block_timestamp: order_by
  gas_burnt: order_by
  index_in_chunk: order_by
  shard_id: order_by
  tokens_burnt: order_by
}

"order by stddev_samp() on columns of table \"execution_outcomes\""
input execution_outcomes_stddev_samp_order_by {
  executed_in_block_timestamp: order_by
  gas_burnt: order_by
  index_in_chunk: order_by
  shard_id: order_by
  tokens_burnt: order_by
}

"order by sum() on columns of table \"execution_outcomes\""
input execution_outcomes_sum_order_by {
  executed_in_block_timestamp: order_by
  gas_burnt: order_by
  index_in_chunk: order_by
  shard_id: order_by
  tokens_burnt: order_by
}

"order by var_pop() on columns of table \"execution_outcomes\""
input execution_outcomes_var_pop_order_by {
  executed_in_block_timestamp: order_by
  gas_burnt: order_by
  index_in_chunk: order_by
  shard_id: order_by
  tokens_burnt: order_by
}

"order by var_samp() on columns of table \"execution_outcomes\""
input execution_outcomes_var_samp_order_by {
  executed_in_block_timestamp: order_by
  gas_burnt: order_by
  index_in_chunk: order_by
  shard_id: order_by
  tokens_burnt: order_by
}

"order by variance() on columns of table \"execution_outcomes\""
input execution_outcomes_variance_order_by {
  executed_in_block_timestamp: order_by
  gas_burnt: order_by
  index_in_chunk: order_by
  shard_id: order_by
  tokens_burnt: order_by
}

"Boolean expression to filter rows from the table \"fn_ft_amount\". All fields are combined with a logical 'AND'."
input fn_ft_amount_bool_exp {
  _and: [fn_ft_amount_bool_exp!]
  _not: fn_ft_amount_bool_exp
  _or: [fn_ft_amount_bool_exp!]
  account: String_comparison_exp
  amount: numeric_comparison_exp
  contract: String_comparison_exp
  ft_meta: ft_meta_bool_exp
  rank: bigint_comparison_exp
}

"Ordering options when selecting data from \"fn_ft_amount\"."
input fn_ft_amount_order_by {
  account: order_by
  amount: order_by
  contract: order_by
  ft_meta: ft_meta_order_by
  rank: order_by
}

"Boolean expression to filter rows from the table \"fn_ft_count\". All fields are combined with a logical 'AND'."
input fn_ft_count_bool_exp {
  _and: [fn_ft_count_bool_exp!]
  _not: fn_ft_count_bool_exp
  _or: [fn_ft_count_bool_exp!]
  contract: String_comparison_exp
  count: bigint_comparison_exp
  ft_meta: ft_meta_bool_exp
}

"Ordering options when selecting data from \"fn_ft_count\"."
input fn_ft_count_order_by {
  contract: order_by
  count: order_by
  ft_meta: ft_meta_order_by
}

"Boolean expression to filter rows from the table \"fn_nft_amount\". All fields are combined with a logical 'AND'."
input fn_nft_amount_bool_exp {
  _and: [fn_nft_amount_bool_exp!]
  _not: fn_nft_amount_bool_exp
  _or: [fn_nft_amount_bool_exp!]
  account: String_comparison_exp
  contract: String_comparison_exp
  nft_meta: nft_meta_bool_exp
  quantity: numeric_comparison_exp
  rank: bigint_comparison_exp
}

"Ordering options when selecting data from \"fn_nft_amount\"."
input fn_nft_amount_order_by {
  account: order_by
  contract: order_by
  nft_meta: nft_meta_order_by
  quantity: order_by
  rank: order_by
}

"Boolean expression to filter rows from the table \"fn_nft_count\". All fields are combined with a logical 'AND'."
input fn_nft_count_bool_exp {
  _and: [fn_nft_count_bool_exp!]
  _not: fn_nft_count_bool_exp
  _or: [fn_nft_count_bool_exp!]
  contract: String_comparison_exp
  count: bigint_comparison_exp
  nft_meta: nft_meta_bool_exp
}

"Ordering options when selecting data from \"fn_nft_count\"."
input fn_nft_count_order_by {
  contract: order_by
  count: order_by
  nft_meta: nft_meta_order_by
}

"Boolean expression to compare columns of type \"ft_event_kind\". All fields are combined with logical 'AND'."
input ft_event_kind_comparison_exp {
  _eq: ft_event_kind
  _gt: ft_event_kind
  _gte: ft_event_kind
  _in: [ft_event_kind!]
  _is_null: Boolean
  _lt: ft_event_kind
  _lte: ft_event_kind
  _neq: ft_event_kind
  _nin: [ft_event_kind!]
}

input ft_holders_args {
  contract: String
  skip: Int
  take: Int
}

input ft_holders_count_args {
  contract: String
}

input ft_inventory_args {
  address: String
  skip: Int
  take: Int
}

input ft_inventory_count_args {
  address: String
}

"Boolean expression to filter rows from the table \"ft_list\". All fields are combined with a logical 'AND'."
input ft_list_bool_exp {
  _and: [ft_list_bool_exp!]
  _not: ft_list_bool_exp
  _or: [ft_list_bool_exp!]
  change_24: numeric_comparison_exp
  contract: String_comparison_exp
  ft_meta: ft_meta_bool_exp
  holders: bigint_comparison_exp
  market_cap: numeric_comparison_exp
  name: String_comparison_exp
  price: numeric_comparison_exp
  symbol: String_comparison_exp
  total_supply: numeric_comparison_exp
  transfers: bigint_comparison_exp
  volume_24h: numeric_comparison_exp
}

"Ordering options when selecting data from \"ft_list\"."
input ft_list_order_by {
  change_24: order_by
  contract: order_by
  ft_meta: ft_meta_order_by
  holders: order_by
  market_cap: order_by
  name: order_by
  price: order_by
  symbol: order_by
  total_supply: order_by
  transfers: order_by
  volume_24h: order_by
}

"Boolean expression to filter rows from the table \"ft_meta\". All fields are combined with a logical 'AND'."
input ft_meta_bool_exp {
  _and: [ft_meta_bool_exp!]
  _not: ft_meta_bool_exp
  _or: [ft_meta_bool_exp!]
  assets__fungible_token_events: assets__fungible_token_events_bool_exp
  change_24: numeric_comparison_exp
  circulating_supply: numeric_comparison_exp
  coingecko_id: String_comparison_exp
  coinmarketcap_id: String_comparison_exp
  contract: String_comparison_exp
  decimals: Int_comparison_exp
  description: String_comparison_exp
  facebook: String_comparison_exp
  fn_ft_amount: fn_ft_amount_bool_exp
  fn_ft_count: fn_ft_count_bool_exp
  fully_diluted_market_cap: numeric_comparison_exp
  icon: String_comparison_exp
  market_cap: numeric_comparison_exp
  name: String_comparison_exp
  price: numeric_comparison_exp
  price_btc: numeric_comparison_exp
  price_eth: numeric_comparison_exp
  reddit: String_comparison_exp
  reference: String_comparison_exp
  reference_hash: String_comparison_exp
  spec: String_comparison_exp
  symbol: String_comparison_exp
  telegram: String_comparison_exp
  twitter: String_comparison_exp
  volume_24h: numeric_comparison_exp
  website: String_comparison_exp
}

"Ordering options when selecting data from \"ft_meta\"."
input ft_meta_order_by {
  assets__fungible_token_events_aggregate: assets__fungible_token_events_aggregate_order_by
  change_24: order_by
  circulating_supply: order_by
  coingecko_id: order_by
  coinmarketcap_id: order_by
  contract: order_by
  decimals: order_by
  description: order_by
  facebook: order_by
  fn_ft_amount: fn_ft_amount_order_by
  fn_ft_count: fn_ft_count_order_by
  fully_diluted_market_cap: order_by
  icon: order_by
  market_cap: order_by
  name: order_by
  price: order_by
  price_btc: order_by
  price_eth: order_by
  reddit: order_by
  reference: order_by
  reference_hash: order_by
  spec: order_by
  symbol: order_by
  telegram: order_by
  twitter: order_by
  volume_24h: order_by
  website: order_by
}

input jsonb_cast_exp {
  String: String_comparison_exp
}

"Boolean expression to compare columns of type \"jsonb\". All fields are combined with logical 'AND'."
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp
  "is the column contained in the given json value"
  _contained_in: jsonb
  "does the column contain the given json value at the top level"
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb
  "does the string exist as a top-level key in the column"
  _has_key: String
  "do all of these strings exist as top-level keys in the column"
  _has_keys_all: [String!]
  "do any of these strings exist as top-level keys in the column"
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"Boolean expression to compare columns of type \"nft_event_kind\". All fields are combined with logical 'AND'."
input nft_event_kind_comparison_exp {
  _eq: nft_event_kind
  _gt: nft_event_kind
  _gte: nft_event_kind
  _in: [nft_event_kind!]
  _is_null: Boolean
  _lt: nft_event_kind
  _lte: nft_event_kind
  _neq: nft_event_kind
  _nin: [nft_event_kind!]
}

input nft_holders_args {
  contract: String
  skip: Int
  take: Int
}

input nft_holders_count_args {
  contract: String
}

"Boolean expression to filter rows from the table \"nft_list\". All fields are combined with a logical 'AND'."
input nft_list_bool_exp {
  _and: [nft_list_bool_exp!]
  _not: nft_list_bool_exp
  _or: [nft_list_bool_exp!]
  contract: String_comparison_exp
  name: String_comparison_exp
  nft_meta: nft_meta_bool_exp
  symbol: String_comparison_exp
  tokens: bigint_comparison_exp
  transfers: bigint_comparison_exp
  transfers_3days: bigint_comparison_exp
  transfers_day: bigint_comparison_exp
}

"Ordering options when selecting data from \"nft_list\"."
input nft_list_order_by {
  contract: order_by
  name: order_by
  nft_meta: nft_meta_order_by
  symbol: order_by
  tokens: order_by
  transfers: order_by
  transfers_3days: order_by
  transfers_day: order_by
}

"Boolean expression to filter rows from the table \"nft_meta\". All fields are combined with a logical 'AND'."
input nft_meta_bool_exp {
  _and: [nft_meta_bool_exp!]
  _not: nft_meta_bool_exp
  _or: [nft_meta_bool_exp!]
  base_uri: String_comparison_exp
  contract: String_comparison_exp
  description: String_comparison_exp
  facebook: String_comparison_exp
  icon: String_comparison_exp
  name: String_comparison_exp
  reddit: String_comparison_exp
  reference: String_comparison_exp
  reference_hash: String_comparison_exp
  spec: String_comparison_exp
  symbol: String_comparison_exp
  telegram: String_comparison_exp
  twitter: String_comparison_exp
  website: String_comparison_exp
}

"Ordering options when selecting data from \"nft_meta\"."
input nft_meta_order_by {
  base_uri: order_by
  contract: order_by
  description: order_by
  facebook: order_by
  icon: order_by
  name: order_by
  reddit: order_by
  reference: order_by
  reference_hash: order_by
  spec: order_by
  symbol: order_by
  telegram: order_by
  twitter: order_by
  website: order_by
}

"Boolean expression to filter rows from the table \"nft_token_meta\". All fields are combined with a logical 'AND'."
input nft_token_meta_bool_exp {
  _and: [nft_token_meta_bool_exp!]
  _not: nft_token_meta_bool_exp
  _or: [nft_token_meta_bool_exp!]
  assets__non_fungible_token_events: assets__non_fungible_token_events_bool_exp
  contract: String_comparison_exp
  copies: Int_comparison_exp
  description: String_comparison_exp
  extra: String_comparison_exp
  media: String_comparison_exp
  media_hash: String_comparison_exp
  nft_meta: nft_meta_bool_exp
  reference: String_comparison_exp
  reference_hash: String_comparison_exp
  title: String_comparison_exp
  token: String_comparison_exp
}

"Ordering options when selecting data from \"nft_token_meta\"."
input nft_token_meta_order_by {
  assets__non_fungible_token_events_aggregate: assets__non_fungible_token_events_aggregate_order_by
  contract: order_by
  copies: order_by
  description: order_by
  extra: order_by
  media: order_by
  media_hash: order_by
  nft_meta: nft_meta_order_by
  reference: order_by
  reference_hash: order_by
  title: order_by
  token: order_by
}

"Boolean expression to compare columns of type \"numeric\". All fields are combined with logical 'AND'."
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"Boolean expression to compare columns of type \"receipt_kind\". All fields are combined with logical 'AND'."
input receipt_kind_comparison_exp {
  _eq: receipt_kind
  _gt: receipt_kind
  _gte: receipt_kind
  _in: [receipt_kind!]
  _is_null: Boolean
  _lt: receipt_kind
  _lte: receipt_kind
  _neq: receipt_kind
  _nin: [receipt_kind!]
}

"order by aggregate values of table \"receipts\""
input receipts_aggregate_order_by {
  avg: receipts_avg_order_by
  count: order_by
  max: receipts_max_order_by
  min: receipts_min_order_by
  stddev: receipts_stddev_order_by
  stddev_pop: receipts_stddev_pop_order_by
  stddev_samp: receipts_stddev_samp_order_by
  sum: receipts_sum_order_by
  var_pop: receipts_var_pop_order_by
  var_samp: receipts_var_samp_order_by
  variance: receipts_variance_order_by
}

"order by avg() on columns of table \"receipts\""
input receipts_avg_order_by {
  included_in_block_timestamp: order_by
  index_in_chunk: order_by
}

"Boolean expression to filter rows from the table \"receipts\". All fields are combined with a logical 'AND'."
input receipts_bool_exp {
  _and: [receipts_bool_exp!]
  _not: receipts_bool_exp
  _or: [receipts_bool_exp!]
  accessKeysByDeletedByReceiptId: access_keys_bool_exp
  access_keys: access_keys_bool_exp
  accounts: accounts_bool_exp
  accountsByDeletedByReceiptId: accounts_bool_exp
  action_receipt_actions: action_receipt_actions_bool_exp
  assets__fungible_token_events: assets__fungible_token_events_bool_exp
  assets__non_fungible_token_events: assets__non_fungible_token_events_bool_exp
  block: blocks_bool_exp
  chunk: chunks_bool_exp
  execution_outcome: execution_outcomes_bool_exp
  included_in_block_hash: String_comparison_exp
  included_in_block_timestamp: numeric_comparison_exp
  included_in_chunk_hash: String_comparison_exp
  index_in_chunk: Int_comparison_exp
  originated_from_transaction_hash: String_comparison_exp
  predecessor_account_id: String_comparison_exp
  receipt_id: String_comparison_exp
  receipt_kind: receipt_kind_comparison_exp
  receiver_account_id: String_comparison_exp
  transaction: transactions_bool_exp
}

"order by max() on columns of table \"receipts\""
input receipts_max_order_by {
  included_in_block_hash: order_by
  included_in_block_timestamp: order_by
  included_in_chunk_hash: order_by
  index_in_chunk: order_by
  originated_from_transaction_hash: order_by
  predecessor_account_id: order_by
  receipt_id: order_by
  receipt_kind: order_by
  receiver_account_id: order_by
}

"order by min() on columns of table \"receipts\""
input receipts_min_order_by {
  included_in_block_hash: order_by
  included_in_block_timestamp: order_by
  included_in_chunk_hash: order_by
  index_in_chunk: order_by
  originated_from_transaction_hash: order_by
  predecessor_account_id: order_by
  receipt_id: order_by
  receipt_kind: order_by
  receiver_account_id: order_by
}

"Ordering options when selecting data from \"receipts\"."
input receipts_order_by {
  accessKeysByDeletedByReceiptId_aggregate: access_keys_aggregate_order_by
  access_keys_aggregate: access_keys_aggregate_order_by
  accountsByDeletedByReceiptId_aggregate: accounts_aggregate_order_by
  accounts_aggregate: accounts_aggregate_order_by
  action_receipt_actions_aggregate: action_receipt_actions_aggregate_order_by
  assets__fungible_token_events_aggregate: assets__fungible_token_events_aggregate_order_by
  assets__non_fungible_token_events_aggregate: assets__non_fungible_token_events_aggregate_order_by
  block: blocks_order_by
  chunk: chunks_order_by
  execution_outcome: execution_outcomes_order_by
  included_in_block_hash: order_by
  included_in_block_timestamp: order_by
  included_in_chunk_hash: order_by
  index_in_chunk: order_by
  originated_from_transaction_hash: order_by
  predecessor_account_id: order_by
  receipt_id: order_by
  receipt_kind: order_by
  receiver_account_id: order_by
  transaction: transactions_order_by
}

"order by stddev() on columns of table \"receipts\""
input receipts_stddev_order_by {
  included_in_block_timestamp: order_by
  index_in_chunk: order_by
}

"order by stddev_pop() on columns of table \"receipts\""
input receipts_stddev_pop_order_by {
  included_in_block_timestamp: order_by
  index_in_chunk: order_by
}

"order by stddev_samp() on columns of table \"receipts\""
input receipts_stddev_samp_order_by {
  included_in_block_timestamp: order_by
  index_in_chunk: order_by
}

"order by sum() on columns of table \"receipts\""
input receipts_sum_order_by {
  included_in_block_timestamp: order_by
  index_in_chunk: order_by
}

"order by var_pop() on columns of table \"receipts\""
input receipts_var_pop_order_by {
  included_in_block_timestamp: order_by
  index_in_chunk: order_by
}

"order by var_samp() on columns of table \"receipts\""
input receipts_var_samp_order_by {
  included_in_block_timestamp: order_by
  index_in_chunk: order_by
}

"order by variance() on columns of table \"receipts\""
input receipts_variance_order_by {
  included_in_block_timestamp: order_by
  index_in_chunk: order_by
}

"Boolean expression to filter rows from the table \"stats\". All fields are combined with a logical 'AND'."
input stats_bool_exp {
  _and: [stats_bool_exp!]
  _not: stats_bool_exp
  _or: [stats_bool_exp!]
  avg_block_time: numeric_comparison_exp
  block: numeric_comparison_exp
  change_24: numeric_comparison_exp
  gas_price: numeric_comparison_exp
  high_24h: numeric_comparison_exp
  high_all: numeric_comparison_exp
  id: Int_comparison_exp
  low_24h: numeric_comparison_exp
  low_all: numeric_comparison_exp
  market_cap: numeric_comparison_exp
  near_btc_price: numeric_comparison_exp
  near_price: numeric_comparison_exp
  nodes: numeric_comparison_exp
  nodes_online: numeric_comparison_exp
  total_supply: numeric_comparison_exp
  total_txns: numeric_comparison_exp
  volume: numeric_comparison_exp
}

"Ordering options when selecting data from \"stats\"."
input stats_order_by {
  avg_block_time: order_by
  block: order_by
  change_24: order_by
  gas_price: order_by
  high_24h: order_by
  high_all: order_by
  id: order_by
  low_24h: order_by
  low_all: order_by
  market_cap: order_by
  near_btc_price: order_by
  near_price: order_by
  nodes: order_by
  nodes_online: order_by
  total_supply: order_by
  total_txns: order_by
  volume: order_by
}

"order by aggregate values of table \"transactions\""
input transactions_aggregate_order_by {
  avg: transactions_avg_order_by
  count: order_by
  max: transactions_max_order_by
  min: transactions_min_order_by
  stddev: transactions_stddev_order_by
  stddev_pop: transactions_stddev_pop_order_by
  stddev_samp: transactions_stddev_samp_order_by
  sum: transactions_sum_order_by
  var_pop: transactions_var_pop_order_by
  var_samp: transactions_var_samp_order_by
  variance: transactions_variance_order_by
}

"order by avg() on columns of table \"transactions\""
input transactions_avg_order_by {
  block_timestamp: order_by
  index_in_chunk: order_by
  nonce: order_by
  receipt_conversion_gas_burnt: order_by
  receipt_conversion_tokens_burnt: order_by
}

"Boolean expression to filter rows from the table \"transactions\". All fields are combined with a logical 'AND'."
input transactions_bool_exp {
  _and: [transactions_bool_exp!]
  _not: transactions_bool_exp
  _or: [transactions_bool_exp!]
  block: blocks_bool_exp
  block_timestamp: numeric_comparison_exp
  chunk: chunks_bool_exp
  converted_into_receipt_id: String_comparison_exp
  included_in_block_hash: String_comparison_exp
  included_in_chunk_hash: String_comparison_exp
  index_in_chunk: Int_comparison_exp
  nonce: numeric_comparison_exp
  receipt_conversion_gas_burnt: numeric_comparison_exp
  receipt_conversion_tokens_burnt: numeric_comparison_exp
  receipts: receipts_bool_exp
  receiver_account_id: String_comparison_exp
  signature: String_comparison_exp
  signer_account_id: String_comparison_exp
  signer_public_key: String_comparison_exp
  status: execution_outcome_status_comparison_exp
  transaction_hash: String_comparison_exp
}

"order by max() on columns of table \"transactions\""
input transactions_max_order_by {
  block_timestamp: order_by
  converted_into_receipt_id: order_by
  included_in_block_hash: order_by
  included_in_chunk_hash: order_by
  index_in_chunk: order_by
  nonce: order_by
  receipt_conversion_gas_burnt: order_by
  receipt_conversion_tokens_burnt: order_by
  receiver_account_id: order_by
  signature: order_by
  signer_account_id: order_by
  signer_public_key: order_by
  status: order_by
  transaction_hash: order_by
}

"order by min() on columns of table \"transactions\""
input transactions_min_order_by {
  block_timestamp: order_by
  converted_into_receipt_id: order_by
  included_in_block_hash: order_by
  included_in_chunk_hash: order_by
  index_in_chunk: order_by
  nonce: order_by
  receipt_conversion_gas_burnt: order_by
  receipt_conversion_tokens_burnt: order_by
  receiver_account_id: order_by
  signature: order_by
  signer_account_id: order_by
  signer_public_key: order_by
  status: order_by
  transaction_hash: order_by
}

"Ordering options when selecting data from \"transactions\"."
input transactions_order_by {
  block: blocks_order_by
  block_timestamp: order_by
  chunk: chunks_order_by
  converted_into_receipt_id: order_by
  included_in_block_hash: order_by
  included_in_chunk_hash: order_by
  index_in_chunk: order_by
  nonce: order_by
  receipt_conversion_gas_burnt: order_by
  receipt_conversion_tokens_burnt: order_by
  receipts_aggregate: receipts_aggregate_order_by
  receiver_account_id: order_by
  signature: order_by
  signer_account_id: order_by
  signer_public_key: order_by
  status: order_by
  transaction_hash: order_by
}

"order by stddev() on columns of table \"transactions\""
input transactions_stddev_order_by {
  block_timestamp: order_by
  index_in_chunk: order_by
  nonce: order_by
  receipt_conversion_gas_burnt: order_by
  receipt_conversion_tokens_burnt: order_by
}

"order by stddev_pop() on columns of table \"transactions\""
input transactions_stddev_pop_order_by {
  block_timestamp: order_by
  index_in_chunk: order_by
  nonce: order_by
  receipt_conversion_gas_burnt: order_by
  receipt_conversion_tokens_burnt: order_by
}

"order by stddev_samp() on columns of table \"transactions\""
input transactions_stddev_samp_order_by {
  block_timestamp: order_by
  index_in_chunk: order_by
  nonce: order_by
  receipt_conversion_gas_burnt: order_by
  receipt_conversion_tokens_burnt: order_by
}

"order by sum() on columns of table \"transactions\""
input transactions_sum_order_by {
  block_timestamp: order_by
  index_in_chunk: order_by
  nonce: order_by
  receipt_conversion_gas_burnt: order_by
  receipt_conversion_tokens_burnt: order_by
}

"order by var_pop() on columns of table \"transactions\""
input transactions_var_pop_order_by {
  block_timestamp: order_by
  index_in_chunk: order_by
  nonce: order_by
  receipt_conversion_gas_burnt: order_by
  receipt_conversion_tokens_burnt: order_by
}

"order by var_samp() on columns of table \"transactions\""
input transactions_var_samp_order_by {
  block_timestamp: order_by
  index_in_chunk: order_by
  nonce: order_by
  receipt_conversion_gas_burnt: order_by
  receipt_conversion_tokens_burnt: order_by
}

"order by variance() on columns of table \"transactions\""
input transactions_variance_order_by {
  block_timestamp: order_by
  index_in_chunk: order_by
  nonce: order_by
  receipt_conversion_gas_burnt: order_by
  receipt_conversion_tokens_burnt: order_by
}

input txn_export_args {
  address: String
  endtime: String
  starttime: String
}
